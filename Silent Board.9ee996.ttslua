function waitFrames(frames) --This function can only be used inside a coroutine because it is using coroutine.yield()
   while frames > 0 do --loop until frames = 0
      coroutine.yield(0) --this will wait 1 frame, reguardless of the number put inside coroutine.yield(#)
      frames = frames - 1 --decrement frames every loop
   end
end

function onLoad(saved_game_data)
  CHARACTER_NAME = "Silent"
  TRACK_INFO = {
    ["Energy"] = {
      ["Starting"] = 3,
      ["Total"] = 6
    },
    ["Block"] = {
      ["Starting"] = 0,
      ["Total"] = 10
    },
    ["HP"] = {
      -- NOTE: This one is off by 1 from the display as the others go from 0-max, and HP goes from 1-max
      ["Starting"] = 8,
      ["Total"] = 8
    },
  }
  CUBE_GUIDS = {"72011a", "2c34de", "89276e"}
  STANDEE_GUID = "64b541"
  PLAYMAT_GUID = "b3ff33"

  DECK_GUIDS = {
    ["Starter"] = {
      ["Base"] = "4da11c",
      ["Upgrades"] = "a6e9ad",
    },
    ["Rewards"] = {
      ["Base"] = "db37c0",
      ["Upgrades"] = "0b9dcc",
    },
    ["Rare"] = {
      ["Base"] = "1641bf",
      ["Upgrades"] = "cdb9a0",
    },
  }

  ASCENSION_2_CUBE_GUID = "bc216e"

  -- Class specific globals
  DAGGER_GUIDS = {"b761a9", "581fec", "ff57eb", "f9eed5", "334e7e"}
  DECAY_GUIDS = {
    ["Single"] = {
      ["Step"] = -0.89,
      ["Tokens"] = {"57febf", "2d0be0", "ac70e3", "395713", "49344f", "556752", "0e9a20", "e2551a"},
    },
    ["Five"] = {
      ["Step"] = -1.06,
      ["Tokens"] = {"c593c4"}
    },
    ["Ten"] = {
      ["Step"] = -1.15,
      ["Tokens"] = {"b1b715"}
    }
  }
end

function setupForPlayer(arguments)
  function setupCoroutine()
    local OBJECTS = Global.getTable("OBJECTS")
    local players = Global.getTable("GAME_DATA").players
    local color = arguments.color
    local handZone = getObjectFromGUID(OBJECTS.playerHands[color])
    local character = players[color].character
    local characterBoard = getObjectFromGUID(OBJECTS.characterBoards[character])
    local characterBag = getObjectFromGUID(OBJECTS.characterBags[character])
    characterBoard.scale(1.8)
    local boardBounds = characterBoard.getBoundsNormalized()
    local handZonePosition = handZone.getPosition()
    characterBoard.setPositionSmooth({
      x = handZonePosition.x,
      y = handZonePosition.y,
      z = handZonePosition.z + 10
    }, false, false)
    characterBoard.interactable = false

    waitFrames(500)

    local boardPosition = characterBoard.getPosition()
    local energyToken = characterBag.takeObject({
      position = {
        x = boardPosition.x - 4.1,
        y = boardPosition.y + 1,
        z = boardPosition.z + boardBounds.size.z / 2 + -1.4,
      }
    })
    energyToken.interactable = false
    local blockToken = characterBag.takeObject({
      position = {
        x = boardPosition.x - 6.2,
        y = boardPosition.y + 1,
        z = boardPosition.z + boardBounds.size.z / 2 + -3.6,
      }
    })
    blockToken.interactable = false
    local hpToken = characterBag.takeObject({
      position = {
        x = boardPosition.x + 1.1,
        y = boardPosition.y + 1,
        z = boardPosition.z + boardBounds.size.z / 2 + -5.8,
      }
    })
    hpToken.interactable = false

    return 1
  end

  startLuaCoroutine(self, "setupCoroutine")
end

function setupSnapPoints()
  local mat_scale = self.getScale()
  local snap_points = {}

  for track_type, cur_track_info in pairs(TRACK_INFO) do
    for i=0, cur_track_info["Total"] do
      local x_offset = Global.getVar("PLAYER_BOARD_TRACK_HORIZ_OFFSET") + (Global.getTable("PLAYER_BOARD_STEP")[track_type] * i)
      local z_offset = Global.getTable("PLAYER_BOARD_TRACK_VERT_OFFSET")[track_type]

      local total_offset = {x_offset, 0, z_offset}
      table.insert(snap_points, {position = {total_offset[1] / mat_scale[1], 0.0, total_offset[3] / mat_scale[3]}, rotation_snap = true})
    end
  end

  self.setSnapPoints(snap_points)
end

function deployPlaymat()
  local characterBag = getObjectFromGUID(Global.getTable("CHARACTER_INFO")[CHARACTER_NAME]["Bag"])
  local target_pos = GetWorldPosFromBoardOffset({-1.55, -0.02, -1.87})
  local playMat = characterBag.takeObject({guid=PLAYMAT_GUID, position=target_pos, rotation=self.getRotation()})
  Wait.frames(function()
    local playMatScale = playMat.getScale()
    playMat.setSnapPoints({
      {position = {-1.35/playMatScale[1], 0, 1.92/playMatScale[3]}, rotation_snap = true},    -- Draw
      {position = {-2.37/playMatScale[1], 0, 1.92/playMatScale[3]}, rotation_snap = true},    -- Discard
      {position = {2.37/playMatScale[1], 0, 1.92/playMatScale[3]}, rotation_snap = true},     -- Exhaust
    })
  end, 1)

  Global.call("delayedComponentLock", {PLAYMAT_GUID, 2})

  self.setPositionSmooth({self.getPosition().x, self.getPosition().y + 0.5, self.getPosition().z})
end

function setupBoard()
  local characterBag = getObjectFromGUID(Global.getTable("CHARACTER_INFO")[CHARACTER_NAME]["Bag"])

  setupSnapPoints()

  -- Make adjustments for ascension levels
  local ascensionLevel = Global.getVar("ASCENSION_LEVEL")
  if ascensionLevel >= 2 then
    -- Put a black cube on the old starting HP value
    local blackCube = getObjectFromGUID(ASCENSION_2_CUBE_GUID)
    if blackCube then
      local x_offset = Global.getVar("PLAYER_BOARD_TRACK_HORIZ_OFFSET") + (Global.getTable("PLAYER_BOARD_STEP")["HP"] * TRACK_INFO["HP"]["Starting"])
      local target_pos = GetWorldPosFromBoardOffset({x_offset, 1, Global.getTable("PLAYER_BOARD_TRACK_VERT_OFFSET")["HP"]})
      blackCube.setPositionSmooth(target_pos)
    else
      broadcastToAll("WARNING: Unable find Black Cube to lower starting health for " .. tostring(CHARACTER_NAME))
    end

    -- Lower max HP by 1
    TRACK_INFO["HP"]["Starting"] = TRACK_INFO["HP"]["Starting"] - 1
  end

  if ascensionLevel >= 8 then
    -- Lower max HP by 1
    TRACK_INFO["HP"]["Starting"] = TRACK_INFO["HP"]["Starting"] - 1
  end

  -- Setup the cubes
  local cur_idx = 1
  for track_type, cur_track_info in pairs(TRACK_INFO) do
    local x_offset = Global.getVar("PLAYER_BOARD_TRACK_HORIZ_OFFSET") + (Global.getTable("PLAYER_BOARD_STEP")[track_type] * TRACK_INFO[track_type]["Starting"])

    local target_pos = GetWorldPosFromBoardOffset({x_offset, 1, Global.getTable("PLAYER_BOARD_TRACK_VERT_OFFSET")[track_type]})
    characterBag.takeObject({guid = CUBE_GUIDS[cur_idx], position=target_pos})
    cur_idx = cur_idx + 1
  end

  -- Deploy the standee and the model to the right of the board
  local target_pos = GetWorldPosFromBoardOffset({-6.0, 0.5, -3.5})
  local target_rot = {0, 180, 0}
  local standee = getObjectFromGUID(STANDEE_GUID)
  if standee then
    standee.setPositionSmooth(target_pos)
    standee.setRotationSmooth(target_rot)
  else
    characterBag.takeObject({guid=STANDEE_GUID, position=target_pos, rotation=target_rot})
  end

  -- Setup Decks
  local face_down_rot = self.getRotation()
  face_down_rot[3] = 180
  local face_up_rot = self.getRotation()
  local starterDeck = getObjectFromGUID(DECK_GUIDS["Starter"]["Base"])
  if starterDeck then
    local starter_target_pos = GetWorldPosFromBoardOffset({-5.65, 0.5, 0.05})
    starterDeck.shuffle()
    starterDeck.setPositionSmooth(starter_target_pos)
    starterDeck.setRotationSmooth(face_down_rot)
  else
    broadcastToAll("WARNING: Unable to find " .. CHARACTER_NAME .. " starter deck")
  end

  -- If ascension is >=5, then take an "Ascender's Bane" card
  if ascensionLevel >= 5 then
    local ascendersBaneDeck = Global.getVar("ASCENDERS_BANE_DECK")
    if ascendersBaneDeck then
      if ascendersBaneDeck.name == "Deck" or ascendersBaneDeck.name == "DeckCustom" then
        starterDeck.putObject(ascendersBaneDeck.takeObject())
        if ascendersBaneDeck.remainder then
          Global.setVar("ASCENDERS_BANE_DECK", ascendersBaneDeck.remainder)
        end
      else
        starterDeck.putObject(ascendersBaneDeck)
      end

      Wait.frames(function()
        starterDeck.shuffle()
      end, 1)
    else
      broadcastToAll("WARNING: Unable to find Ascender's ")
    end
  end


  local rewardDeck = getObjectFromGUID(DECK_GUIDS["Rewards"]["Base"])
  local deck_info = Global.getTable("PLAYER_REWARD_DECKS")[Global.call('getPlayerColorForCharacter', CHARACTER_NAME)]
  if rewardDeck then
    --local reward_target_pos = GetWorldPosFromBoardOffset({5.5, 0.5, 0})
    local reward_target_pos = deck_info["Reward"]
    rewardDeck.shuffle()
    rewardDeck.setPositionSmooth(reward_target_pos)
    rewardDeck.setRotationSmooth(deck_info["Rotation"])

    -- Add the text object
    local rewardText = getObjectFromGUID(deck_info["RewardText"])
    if rewardText then
      rewardText.setPosition(deck_info["RewardTextPos"])
      rewardText.TextTool.setValue("Reward\nDeck")
    end
  else
    broadcastToAll("WARNING: Unable to find " .. CHARACTER_NAME .. " reward deck")
  end

  local rareRewardDeck = getObjectFromGUID(DECK_GUIDS["Rare"]["Base"])
  if rareRewardDeck then
    --local rare_target_pos = GetWorldPosFromBoardOffset({8.25, 0.5, 0})
    local rare_target_pos = deck_info["Rare"]
    rareRewardDeck.shuffle()
    rareRewardDeck.setPositionSmooth(rare_target_pos)
    rareRewardDeck.setRotationSmooth(deck_info["Rotation"])

    -- Add the text object
    local rewardText = getObjectFromGUID(deck_info["RareText"])
    if rewardText then
      rewardText.setPosition(deck_info["RareTextPos"])
      rewardText.TextTool.setValue("Rare\nDeck")
    end
  else
    broadcastToAll("WARNING: Unable to find " .. CHARACTER_NAME .. " rare reward deck")
  end

  -- Upgrade decks get combined
  local starterUpgradeDeck = getObjectFromGUID(DECK_GUIDS["Starter"]["Upgrades"])
  local upgrade_target_pos = deck_info["Upgrade"]
  local upgrade_target_rot = {0, 180, 180}
  if starterUpgradeDeck then
    starterUpgradeDeck.setPositionSmooth(upgrade_target_pos)
    starterUpgradeDeck.setRotationSmooth(upgrade_target_rot)
  else
    broadcastToAll("WARNING: Unable to find " .. CHARACTER_NAME .. " starter upgrade deck")
  end

  local rewardUpgradeDeck = getObjectFromGUID(DECK_GUIDS["Rewards"]["Upgrades"])
  if rewardUpgradeDeck then
    rewardUpgradeDeck.setPositionSmooth(upgrade_target_pos)
    rewardUpgradeDeck.setRotationSmooth(upgrade_target_rot)
  else
    broadcastToAll("WARNING: Unable to find " .. CHARACTER_NAME .. " reward upgrade deck")
  end

  local rareUpgradeDeck = getObjectFromGUID(DECK_GUIDS["Rare"]["Upgrades"])
  if rareUpgradeDeck then
    rareUpgradeDeck.setPositionSmooth(upgrade_target_pos)
    rareUpgradeDeck.setRotationSmooth(upgrade_target_rot)
  else
    broadcastToAll("WARNING: Unable to find " .. CHARACTER_NAME .. " rare upgrade deck")
  end

  -- Add the text object
  local rewardText = getObjectFromGUID(deck_info["UpgradeText"])
  if rewardText then
    local upgrade_text_pos = upgrade_target_pos
    upgrade_text_pos[2] = 1
    upgrade_text_pos[3] = upgrade_text_pos[3] - 2.33
    rewardText.setPosition(upgrade_text_pos)
    rewardText.setRotation({90, 0, 0})
    rewardText.TextTool.setValue("Upgrade\nDeck")
  end

  -- Pull a Neow card
  local neowDeck = Global.getVar("NEOW_DECK")
  if neowDeck then
    local target_pos = GetWorldPosFromBoardOffset({-2.8, 0.5, 4.83})
    local target_rot = self.getRotation()
    target_rot[3] = 0
    local neowCard = neowDeck.takeObject({position=target_pos, rotation=target_rot})
    Global.call('registerNeowCardForReturn', neowCard.guid)
  end

  -- Clone the upgrader tool
  local upgrader_tool = getObjectFromGUID(Global.getVar("UPGRADE_TOOL"))
  local target_pos = deck_info["UpgradeTool"]
  local target_rot = deck_info["Rotation"]
  target_rot[3] = 0
  upgrader_tool.clone({position=target_pos, rotation=target_rot})

  -- Give 3 gold
  for i=1,3 do
    local local_x_offset = 2.18
    local local_y_offset = i * 0.5
    local local_z_offset = -2.64
    local target_pos = GetWorldPosFromBoardOffset({local_x_offset, local_y_offset, local_z_offset})
    local token = Global.call('getUnusedGoldToken')
    if token then
      token.setPositionSmooth(target_pos)
    end
  end

  -- Solo rewards
  local isSoloMode = Global.getVar("SOLO_MODE")
  if isSoloMode then
    local soloRewards = Global.getTable("SOLO_REWARDS")
    for i, gold_guid in ipairs(soloRewards["Gold"]) do
      local local_x_offset = 3.43
      local local_y_offset = (i+3) * 0.5
      local local_z_offset = -2.64
      local target_pos = GetWorldPosFromBoardOffset({local_x_offset, local_y_offset, local_z_offset})
      local token = getObjectFromGUID(gold_guid)
      if token then
        token.setPositionSmooth(target_pos)
      end
    end

    local kindling = getObjectFromGUID(soloRewards["Kindling"])
    if kindling then
      local target_pos = GetWorldPosFromBoardOffset({2.805, 0.5, -4.98})
      kindling.setPositionSmooth(target_pos)
      kindling.setRotationSmooth(self.getRotation())
    else
      broadcastToAll("WARNING: Unable to find Kindling solo card")
    end
  end


  -- Class specific setup
  -- Place Daggers above the player board
  for idx, dagger_guid in ipairs(DAGGER_GUIDS) do
    local local_x_offset = -3.43 + ((idx-1) * 1)
    local local_z_offset = -2.64
    local target_pos = GetWorldPosFromBoardOffset({local_x_offset, 0.5, local_z_offset})
    characterBag.takeObject({guid=dagger_guid, position=target_pos, rotation=self.getRotation()})
  end

  -- Place Delay tokens above the player board
  local cur_x_offset = -0.33
  for token_type, token_list in pairs(DECAY_GUIDS) do
    cur_x_offset = cur_x_offset + DECAY_GUIDS[token_type]["Step"]
    for idx, decay_guid in ipairs(DECAY_GUIDS[token_type]["Tokens"]) do
      local local_y_offset = idx * 0.5
      local local_z_offset = -3.81
      local target_pos = GetWorldPosFromBoardOffset({cur_x_offset, local_y_offset, local_z_offset})
      characterBag.takeObject({guid=decay_guid, position=target_pos, rotation=self.getRotation()})
    end
  end
end


function putAwayIfFound(guid)
  if guid ~= nil then
    local characterBag = getObjectFromGUID(Global.getTable("CHARACTER_INFO")[CHARACTER_NAME]["Bag"])
    if characterBag then
      local obj = getObjectFromGUID(guid)
      if obj then
        characterBag.putObject(obj)
      end
    end
  end
end

function packAway()
  for _, cube_guid in ipairs(CUBE_GUIDS) do
    putAwayIfFound(cube_guid)
  end
  putAwayIfFound(STANDEE_GUID)

  for deck_type, _ in pairs(DECK_GUIDS) do
    putAwayIfFound(DECK_GUIDS[deck_type]["Base"])
    putAwayIfFound(DECK_GUIDS[deck_type]["Upgrades"])
  end

  -- Class specific objects
  for _, dagger_guids in ipairs(DAGGER_GUIDS) do
    putAwayIfFound(dagger_guids)
  end

  for decay_type, _ in pairs(DECAY_GUIDS) do
    for __, decay_guid in ipairs(DECAY_GUIDS[decay_type]["Tokens"]) do
      putAwayIfFound(decay_guid)
    end
  end


  putAwayIfFound(self.getGUID())
end