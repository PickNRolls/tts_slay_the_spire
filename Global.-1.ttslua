DEBUG_ONLY_LOSE_HP_NEOW = false
DEBUG_ONLY_GAIN_RELIC_NEOW = false
DEBUG_ONLY_GAIN_COLORLESS_NEOW = false
DEBUG_ONLY_UPGRADE_CARD_NEOW = false
DEBUG_ONLY_REMOVE_CARD_NEOW = false
DEBUG_ONLY_RARE_CARD_NEOW = false
DEBUG_ONLY_TRANSFORM_NEOW = false
DEBUG_ONLY_RANDOM_RARE_NEOW = false
DEBUG_ONLY_UPGRADE_RANDOM_CARD_NEOW = false
DEBUG_ONLY_RANDOM_CARD_NEOW = false
DEBUG_ONLY_RANDOM_COLORLESS_NEOW = false
DEBUG_ONLY_POTION_NEOW = false

DEBUG_RELIC_DRAW_ORDER = {
  "Horn Cleat",
  "Incense Burner",
  "Stone Calendar",
  "Captain's Wheel",
}
DEBUG_USE_RELIC_DRAW_ORDER = false
DEBUG_GAIN_RELIC_AMOUNT = nil

DEBUG_DICE_VALUE = nil

CHARACTERS = {"Ironclad", "Silent", "Defect", "Watcher"}

TURN_TYPES = {
  PLAYERS = "Players",
  ENEMIES = "Enemies"
}

TURN_PHASE_TYPES = {
  START_OF_TURN = "Start of turn",
  PLAY = "Play",
  END_OF_TURN = "End of turn"
};

CHARACTER_MAX_HP = {
  [CHARACTERS[1]] = 10,
  [CHARACTERS[2]] = 9,
  [CHARACTERS[3]] = 9,
  [CHARACTERS[4]] = 9,
}

BOARD_BLOCK_OFFSET = 0.72
BOARD_ENERGY_OFFSET = 0.72
BOARD_HP_OFFSET = 0.927
BOARD_LEFT_OFFSET = 0.92

GAME_DATA = {
  act = 1,
  isFirstEncounterDone = false,
  combat = {
    inProgress = false,
    encountersSetup = 0,
    summonQueue = {},
    turn = TURN_TYPES.PLAYERS,
    turnCount = 1,
    phase = nil,
    playingCard = nil,
    playingTargetRelic = nil,
    dieResult = nil,
    canTargetRelics = {},
    players = {
      Red = {
        energy = 3,
        block = 0,
        playedCardGuidsThisCombat = {},
        playedCardGuidsThisTurn = {},
        endsTurn = false,
      },
      Green = {
        energy = 3,
        block = 0,
        playedCardGuidsThisCombat = {},
        playedCardGuidsThisTurn = {},
        endsTurn = false,
      },
      Blue = {
        energy = 3,
        block = 0,
        playedCardGuidsThisCombat = {},
        playedCardGuidsThisTurn = {},
        endsTurn = false,
      },
      Pink = {
        energy = 3,
        block = 0,
        playedCardGuidsThisCombat = {},
        playedCardGuidsThisTurn = {},
        endsTurn = false,
      }
    },
    enemies = {},
    reducedCards = {}
  },
  players = {
    Red = {
      neowBonusStarted = false,
      neowBonusDone = false,
      hp = 0,
      optionalGainInProgress = nil,
      cardUpgradeInProgress = nil,
      cardRemoveInProgress = nil,
      relics = {},
      relicsMap = {},
    },
    Green = {
      neowBonusStarted = false,
      neowBonusDone = false,
      hp = 0,
      optionalGainInProgress = nil,
      cardUpgradeInProgress = nil,
      cardRemoveInProgress = nil,
      relics = {},
      relicsMap = {},
    },
    Blue = {
      neowBonusStarted = false,
      neowBonusDone = false,
      hp = 0,
      optionalGainInProgress = nil,
      cardUpgradeInProgress = nil,
      cardRemoveInProgress = nil,
      relics = {},
      relicsMap = {},
    },
    Pink = {
      neowBonusStarted = false,
      neowBonusDone = false,
      hp = 0,
      optionalGainInProgress = nil,
      cardUpgradeInProgress = nil,
      cardRemoveInProgress = nil,
      relics = {},
      relicsMap = {},
    }
  }
}

OBJECTS = {
  startMenu = "1c1c13",

  characterBoards = {
    [CHARACTERS[1]] = "63f2c4",
    [CHARACTERS[2]] = "9ee996",
    [CHARACTERS[3]] = "b293d2",
    [CHARACTERS[4]] = "60b3de"
  },
  characterBags = {
    [CHARACTERS[1]] = "a29133",
    [CHARACTERS[2]] = "6a89d8",
    [CHARACTERS[3]] = "0f270c",
    [CHARACTERS[4]] = "f37f4f"
  },
  characterFigures = {
    [CHARACTERS[1]] = "b9ce26",
    [CHARACTERS[2]] = "64b541",
    [CHARACTERS[3]] = "5a68a5",
    [CHARACTERS[4]] = "410585"
  },
  characterDecks = {
    [CHARACTERS[1]] = {
      starterDeck = nil,
      rewardsDeck = nil,
      rareDeck = nil,
    },
    [CHARACTERS[2]] = {
      starterDeck = nil,
      rewardsDeck = nil,
      rareDeck = nil,
    },
    [CHARACTERS[3]] = {
      starterDeck = nil,
      rewardsDeck = nil,
      rareDeck = nil,
    },
    [CHARACTERS[4]] = {
      starterDeck = nil,
      rewardsDeck = nil,
      rareDeck = nil,
    }
  },

  playerHands = {
    Red = "198286",
    Green = "761a86",
    Blue = "507348",
    Pink = "32fa24"
  },
  handToPlayer = {
    ["198286"] = "Red",
    ["761a86"] = "Green",
    ["507348"] = "Blue",
    ["32fa24"] = "Pink",
  },
  playerGoldBowls = {
    Red = nil,
    Green = nil,
    Blue = nil,
    Pink = nil,
  },
  playerGoldBowlScriptingZones = {
    Red = nil,
    Green = nil,
    Blue = nil,
    Pink = nil
  },
  playerNeowBlessingCard = {
    Red = nil,
    Green = nil,
    Blue = nil,
    Pink = nil
  },
  playerBoardScriptingZones = {
    Red = nil,
    Green = nil,
    Blue = nil,
    Pink = nil
  },
  playerDrawScriptingZones = {
    Red = nil,
    Green = nil,
    Blue = nil,
    Pink = nil
  },
  playerDiscardScriptingZones = {
    Red = nil,
    Green = nil,
    Blue = nil,
    Pink = nil
  },
  discardScriptingZoneToPlayer = {},
  playerDeckScriptingZones = {
    Red = nil,
    Green = nil,
    Blue = nil,
    Pink = nil
  },
  deckScriptingZoneToPlayer = {},
  playerUpgradeCardScriptingZones = {
    Red = nil,
    Green = nil,
    Blue = nil,
    Pink = nil
  },
  upgradeCardScriptingZoneToPlayer = {},
  playerRemoveCardScriptingZones = {
    Red = nil,
    Green = nil,
    Blue = nil,
    Pink = nil
  },
  removeCardScriptingZoneToPlayer = {},
  playerTransformCardScriptingZones = {
    Red = nil,
    Green = nil,
    Blue = nil,
    Pink = nil
  },
  transformCardScriptingZoneToPlayer = {},
  playerOutOfCombatPotionScriptingZones = {
    Red = nil,
    Green = nil,
    Blue = nil,
    Pink = nil
  },
  outOfCombatPotionScriptingZoneToPlayer = {},
  playerCombatPotionScriptingZones = {
    Red = nil,
    Green = nil,
    Blue = nil,
    Pink = nil
  },
  combatPotionScriptingZoneToPlayer = {},

  boot = "d4e0e6",
  goldBag1 = "3c7af8",
  goldBag5 = "4aeac9",
  weakBag = "a0b349",
  blockBag = "ffeff0",
  block5Bag = "44889c",
  relicsDeck = "009011",
  curseDeck = "2987a7",
  colorlessDeck = "8049ab",
  potionDeck = "860f93",
  dice = "4d8f9b",

  actMaps = {
    "0b5712",
    "9a9d69",
    "7ed624"
  },
  actDecksBag = {
    {
      base = "7def40",
      ascension = "e4892b"
    },
    {
      base = "bc0921",
      ascension = "a9f893"
    },
    {
      base = "4d2c55",
      ascension = "1efef1"
    },
    {
      base = "c9e668",
      ascension = "ab1455"
    }
  },
  firstEncounterBag = "580dd2",

  whiteMapTokensBag = "021340",
  blackMapTokensBag = "b4d7e7",

  neowBlessingDeck = "938861",

  combat = {
    zoneToEnemy = {},
    enemyToZone = {},
  }
}

EFFECT_TYPES = {
  GAIN_GOLD = "gain gold",
  GAIN_CURSE = "gain curse",
  GAIN_RANDOM_POTION = "gain random potion",
  GAIN_CARD = "gain card",
  GAIN_RANDOM_CARD = "gain random card",
  GAIN_RARE_CARD = "gain rare card",
  GAIN_RANDOM_RARE_CARD = "gain random rare card",
  GAIN_COLORLESS_CARD = "gain colorless card",
  GAIN_RANDOM_COLORLESS_CARD = "gain random colorless card",
  GAIN_RELIC = "gain relic",
  UPGRADE_CARD = "upgrade card",
  UPGRADE_RANDOM_CARD = "upgrade random card",
  TRANSFORM_CARD = "transform card",
  LOSE_HP = "lose hp",
  LOSE_GOLD = "lose gold",
  REMOVE_CARD = "remove card",
}

TARGET_TYPES = {
  ENEMY = "Enemy",
  PLAYER = "Player"
}

TAG_TYPES = {
  FIRST_ENCOUNTER = "First Encounter",
  ENCOUNTER = "Encounter",
  SUMMON = "Summon",
  ELITE = "Elite",
  BOSS = "Boss",
  RELIC = "Relic"
}

ACTION_TYPES = {
  HIT = "Hit",
  WEAK = "Weak",
  DAZED = "Dazed",
  BUFF = "Buff",
  VULNERABLE = "Vulnerable",
  AREA_OF_EFFECT = "Area of effect"
}

COMBAT_EFFECT_TYPES = {
  WEAK = "Weak"
}

COMBAT_EFFECT_TO_DECAL_URL = {
  [COMBAT_EFFECT_TYPES.WEAK] = "http://cloud-3.steamusercontent.com/ugc/1857175596587634426/109E0B1D8C193B75B18113CF0387D3E44D1FEF2B/"
}

REWARD_TYPES = {
  POTION = "Potion",
  CARD = "Card",
}

CARD_TYPES = {
  ATTACK = "Attack",
  SKILL = "Skill",
  POWER = "Power",
  CURSE = "Curse",
  STATUS_RED = "Status red",
  STATUS_GREEN = "Status green"
}

CARDS_DATA = {
  [CHARACTERS[1]] = {
    ["Strike"] = {
      type = CARD_TYPES.ATTACK,
      cost = 1
    },
    ["Defend"] = {
      type = CARD_TYPES.SKILL,
      cost = 1
    },
    ["Bash"] = {
      type = CARD_TYPES.ATTACK,
      cost = 2
    }
  },
  [CHARACTERS[2]] = {
    ["Strike"] = {
      type = CARD_TYPES.ATTACK,
      cost = 1
    },
    ["Defend"] = {
      type = CARD_TYPES.SKILL,
      cost = 1
    },
    ["Neutralize"] = {
      type = CARD_TYPES.ATTACK,
      cost = 0
    },
    ["Survivor"] = {
      type = CARD_TYPES.SKILL,
      cost = 1
    },
  },
  [CHARACTERS[3]] = {
    ["Strike"] = {
      type = CARD_TYPES.ATTACK,
      cost = 1
    },
    ["Defend"] = {
      type = CARD_TYPES.SKILL,
      cost = 1
    },
  },
  [CHARACTERS[4]] = {
    ["Strike"] = {
      type = CARD_TYPES.ATTACK,
      cost = 1
    },
    ["Defend"] = {
      type = CARD_TYPES.SKILL,
      cost = 1
    },
  }
}

ENEMIES_DATA = {
  acts = {
    ["First Encounter"] = {
      Encounter = {
        ["Small Slime"] = {
          name = "Small Slime",
          rewards = {
            REWARD_TYPES.POTION,
            REWARD_TYPES.CARD,
          },
          everyTurnActions = {
            {
              type = ACTION_TYPES.HIT,
              power = 2,
            }
          },
          summons = {
            {
              variants = {
                "Acid Slime 1",
                "Acid Slime 2",
                "Acid Slime 3",
                "Acid Slime 4"
              },
              amount = 1
            }
          },
          hp = 3
        },
        ["Cultist"] = {
          name = "Cultist",
          hp = 9,
          everyTurnActions = { {
            type = "Hit",
            power = 1
          }, {
            type = "Buff"
          } },
          rewards = { {
            type = "Gold",
            amount = 1
          }, {
            type = "Card"
          } }
        },
        ["Jaw Worm"] = {
          name = "Jaw Worm",
          hp = 8,
          dieActions = {
            ["1"] = { {
              type = "Block",
              power = 2
            }, {
              type = "Buff"
            } },
            ["2"] = { {
              type = "Block",
              power = 2
            }, {
              type = "Buff"
            } },
            ["3"] = { {
              type = "Hit",
              power = 2
            }, {
              type = "Block",
              power = 1
            } },
            ["4"] = { {
              type = "Hit",
              power = 2
            }, {
              type = "Block",
              power = 1
            } },
            ["5"] = { {
              type = "Hit",
              power = 3
            } },
            ["6"] = { {
              type = "Hit",
              power = 3
            } }
          },
          rewards = { {
            type = "Gold",
            amount = 1
          }, {
            type = "Potion"
          }, {
            type = "Card"
          } }
        },
        ["Red Louse"] = {
          name = "Red Louse",
          hp = 3,
          dieActions = {
            ["1"] = { {
              type = "Buff"
            } },
            ["2"] = { {
              type = "Buff"
            } },
            ["3"] = { {
              type = "Hit",
              power = 2
            } },
            ["4"] = { {
              type = "Hit",
              power = 2
            } },
            ["5"] = { {
              type = "Hit",
              power = 1
            } },
            ["6"] = { {
              type = "Hit",
              power = 1
            } }
          },
          abilities = { "Curl Up" },
          summons = { {
            variants = { "Green Louse 1", "Green Louse 2" },
            amount = 1
          } },
          rewards = { {
            type = "Gold",
            amount = 1
          }, {
            type = "Card"
          } }
        }
      }
    },
    ["1"] = {
      Summon = {
        ["Green Louse 1"] = {
    name = "Green Louse 1",
    hp = 3,
    dieActions = {
      ["1"] = { {
        type = "Hit",
        power = 2
      } },
      ["2"] = { {
        type = "Hit",
        power = 2
      } },
      ["3"] = { {
        type = "Hit",
        power = 1
      } },
      ["4"] = { {
        type = "Hit",
        power = 1
      } },
      ["5"] = { {
        type = "Weak"
      } },
      ["6"] = { {
        type = "Weak"
      } }
    },
    abilities = { "Curl Up" }
  },
  ["Green Louse 2"] = {
    name = "Green Louse 2",
    hp = 3,
    dieActions = {
      ["1"] = { {
        type = "Hit",
        power = 1
      } },
      ["2"] = { {
        type = "Hit",
        power = 1
      } },
      ["3"] = { {
        type = "Weak"
      } },
      ["4"] = { {
        type = "Weak"
      } },
      ["5"] = { {
        type = "Hit",
        power = 2
      } },
      ["6"] = { {
        type = "Hit",
        power = 2
      } }
    },
    abilities = { "Curl Up" }
  },
  ["Sneaky Gremlin"] = {
    name = "Sneaky Gremlin",
    hp = 2,
    everyTurnActions = { {
      type = "Hit",
      power = 2
    } }
  },
  ["Fat Gremlin"] = {
    name = "Fat Gremlin",
    hp = 2,
    everyTurnActions = { {
      type = "Hit",
      power = 1
    }, {
      type = "Weak"
    } }
  },
  ["Sentry B"] = {
    name = "Sentry B",
    hp = 8,
    dieActions = {
      ["1"] = { {
        type = "Hit",
        power = 3
      } },
      ["2"] = { {
        type = "Hit",
        power = 3
      } },
      ["3"] = { {
        type = "Hit",
        power = 3
      } },
      ["4"] = { {
        type = "Dazed"
      } },
      ["5"] = { {
        type = "Dazed"
      } },
      ["6"] = { {
        type = "Dazed"
      } }
    }
  },
  ["Spike Slime 3"] = {
    name = "Spike Slime 3",
    hp = 5,
    dieActions = {
      ["1"] = { {
        type = "Vulnerable"
      } },
      ["2"] = { {
        type = "Vulnerable"
      } },
      ["3"] = { {
        type = "Hit",
        power = 1
      }, {
        type = "Dazed"
      } },
      ["4"] = { {
        type = "Hit",
        power = 1
      }, {
        type = "Dazed"
      } },
      ["5"] = { {
        type = "Hit",
        power = 2
      } },
      ["6"] = { {
        type = "Hit",
        power = 2
      } }
    }
  },
  ["Spike Slime 1"] = {
    name = "Spike Slime 1",
    hp = 5,
    dieActions = {
      ["1"] = { {
        type = "Vulnerable"
      } },
      ["2"] = { {
        type = "Vulnerable"
      } },
      ["3"] = { {
        type = "Hit",
        power = 2
      } },
      ["4"] = { {
        type = "Hit",
        power = 2
      } },
      ["5"] = { {
        type = "Hit",
        power = 1
      }, {
        type = "Dazed"
      } },
      ["6"] = { {
        type = "Hit",
        power = 1
      }, {
        type = "Dazed"
      } }
    }
  },
  ["Spike Slime 2"] = {
    name = "Spike Slime 2",
    hp = 5,
    dieActions = {
      ["1"] = { {
        type = "Hit",
        power = 1
      }, {
        type = "Dazed"
      } },
      ["2"] = { {
        type = "Hit",
        power = 1
      }, {
        type = "Dazed"
      } },
      ["3"] = { {
        type = "Vulnerable"
      } },
      ["4"] = { {
        type = "Vulnerable"
      } },
      ["5"] = { {
        type = "Hit",
        power = 2
      } },
      ["6"] = { {
        type = "Hit",
        power = 2
      } }
    }
  },
  ["Spike Slime 4"] = {
    name = "Spike Slime 4",
    hp = 5,
    dieActions = {
      ["1"] = { {
        type = "Hit",
        power = 2
      } },
      ["2"] = { {
        type = "Hit",
        power = 2
      } },
      ["3"] = { {
        type = "Hit",
        power = 1
      }, {
        type = "Dazed"
      } },
      ["4"] = { {
        type = "Hit",
        power = 1
      }, {
        type = "Dazed"
      } },
      ["5"] = { {
        type = "Vulnerable"
      } },
      ["6"] = { {
        type = "Vulnerable"
      } }
    }
  },
  ["Mad Gremlin"] = {
    name = "Mad Gremlin",
    hp = 5,
    everyTurnActions = { {
      type = "Hit",
      power = 1
    } },
    abilities = { "Angry" }
  },
  ["Red Louse"] = {
    name = "Red Louse",
    hp = 3,
    dieActions = {
      ["1"] = { {
        type = "Hit",
        power = 2
      } },
      ["2"] = { {
        type = "Hit",
        power = 2
      } },
      ["3"] = { {
        type = "Hit",
        power = 1
      } },
      ["4"] = { {
        type = "Hit",
        power = 1
      } },
      ["5"] = { {
        type = "Buff"
      } },
      ["6"] = { {
        type = "Buff"
      } }
    },
    cubeActions = { {
      type = ""
    }, {
      type = ""
    } },
    abilities = { "Curl Up" }
  },
  ["Sentry A"] = {
    name = "Sentry A",
    hp = 8,
    dieActions = {
      ["1"] = { {
        type = "Dazed"
      } },
      ["2"] = { {
        type = "Dazed"
      } },
      ["3"] = { {
        type = "Dazed"
      } },
      ["4"] = { {
        type = "Hit",
        power = 3
      } },
      ["5"] = { {
        type = "Hit",
        power = 3
      } },
      ["6"] = { {
        type = "Hit",
        power = 3
      } }
    }
  },
  ["Acid Slime 1"] = {
    name = "Acid Slime 1",
    hp = 5,
    dieActions = {
      ["1"] = { {
        type = "Weak"
      } },
      ["2"] = { {
        type = "Weak"
      } },
      ["3"] = { {
        type = "Hit",
        power = 2
      } },
      ["4"] = { {
        type = "Hit",
        power = 2
      } },
      ["5"] = { {
        type = "Hit",
        power = 2
      }, {
        type = "Dazed"
      } },
      ["6"] = { {
        type = "Hit",
        power = 2
      }, {
        type = "Dazed"
      } }
    }
  },
  ["Acid Slime 2"] = {
    name = "Acid Slime 2",
    hp = 5,
    dieActions = {
      ["1"] = { {
        type = "Weak"
      } },
      ["2"] = { {
        type = "Weak"
      } },
      ["3"] = { {
        type = "Hit",
        power = 2
      }, {
        type = "Dazed"
      } },
      ["4"] = { {
        type = "Hit",
        power = 2
      }, {
        type = "Dazed"
      } },
      ["5"] = { {
        type = "Hit",
        power = 2
      } },
      ["6"] = { {
        type = "Hit",
        power = 2
      } }
    }
  },
  ["Acid Slime 4"] = {
    name = "Acid Slime 4",
    hp = 5,
    dieActions = {
      ["1"] = { {
        type = "Hit",
        power = 2
      } },
      ["2"] = { {
        type = "Hit",
        power = 2
      } },
      ["3"] = { {
        type = "Weak"
      } },
      ["4"] = { {
        type = "Weak"
      } },
      ["5"] = { {
        type = "Hit",
        power = 2
      }, {
        type = "Dazed"
      } },
      ["6"] = { {
        type = "Hit",
        power = 2
      }, {
        type = "Dazed"
      } }
    }
  },
  ["Acid Slime 3"] = {
    name = "Acid Slime 3",
    hp = 5,
    dieActions = {
      ["1"] = { {
        type = "Hit",
        power = 2
      }, {
        type = "Dazed"
      } },
      ["2"] = { {
        type = "Hit",
        power = 2
      }, {
        type = "Dazed"
      } },
      ["3"] = { {
        type = "Hit",
        power = 2
      } },
      ["4"] = { {
        type = "Hit",
        power = 2
      } },
      ["5"] = { {
        type = "Weak"
      } },
      ["6"] = { {
        type = "Weak"
      } }
    }
  },
  ["Large Slime 1"] = {
    name = "Large Slime 1",
    hp = 10,
    dieActions = {
      ["1"] = { {
        type = "Weak"
      }, {
        type = "Weak"
      } },
      ["2"] = { {
        type = "Weak"
      }, {
        type = "Weak"
      } },
      ["3"] = { {
        type = "Hit",
        power = 4
      } },
      ["4"] = { {
        type = "Hit",
        power = 4
      } },
      ["5"] = { {
        type = "Hit",
        power = 3
      }, {
        type = "Status green"
      }, {
        type = "Status green"
      } },
      ["6"] = { {
        type = "Hit",
        power = 3
      }, {
        type = "Status green"
      }, {
        type = "Status green"
      } }
    }
  },
  ["Large Slime 2"] = {
    name = "Large Slime 2",
    hp = 10,
    dieActions = {
      ["1"] = { {
        type = "Hit",
        power = 4
      } },
      ["2"] = { {
        type = "Hit",
        power = 4
      } },
      ["3"] = { {
        type = "Hit",
        power = 3
      }, {
        type = "Status green"
      }, {
        type = "Status green"
      } },
      ["4"] = { {
        type = "Hit",
        power = 3
      }, {
        type = "Status green"
      }, {
        type = "Status green"
      } },
      ["5"] = { {
        type = "Weak"
      }, {
        type = "Weak"
      } },
      ["6"] = { {
        type = "Weak"
      }, {
        type = "Weak"
      } }
    }
  },
  ["Large Slime 3"] = {
    name = "Large Slime 3",
    hp = 10,
    dieActions = {
      ["1"] = { {
        type = "Hit",
        power = 3
      }, {
        type = "Status green"
      }, {
        type = "Status green"
      } },
      ["2"] = { {
        type = "Hit",
        power = 3
      }, {
        type = "Status green"
      }, {
        type = "Status green"
      } },
      ["3"] = { {
        type = "Weak"
      }, {
        type = "Weak"
      } },
      ["4"] = { {
        type = "Weak"
      }, {
        type = "Weak"
      } },
      ["5"] = { {
        type = "Hit",
        power = 4
      } },
      ["6"] = { {
        type = "Hit",
        power = 4
      } }
    }
  },
  ["Fungi Beast"] = {
    name = "Fungi Beast",
    hp = 5,
    dieActions = {
      ["1"] = { {
        type = "Hit",
        power = 1
      }, {
        type = "Buff"
      } },
      ["2"] = { {
        type = "Hit",
        power = 1
      }, {
        type = "Buff"
      } },
      ["3"] = { {
        type = "Buff"
      } },
      ["4"] = { {
        type = "Buff"
      } },
      ["5"] = { {
        type = "Hit",
        power = 2
      } },
      ["6"] = { {
        type = "Hit",
        power = 2
      } }
    },
    abilities = { "Spore Cloud" }
  },
  ["Gremlin Wizard"] = {
    name = "Gremlin Wizard",
    hp = 4,
    cubeActions = { {
      isNotRepeated = true,
      actions = { }
    }, {
      actions = { {
        type = "Area of effect"
      }, {
        type = "Hit",
        power = 3
      } }
    } }
  },
        ["Acid Slime 1"] = {
          hp = 5,
          dieActions = {
            ["1"] = {
              {
                type = ACTION_TYPES.WEAK,
              }
            },
            ["2"] = {
              {
                type = ACTION_TYPES.WEAK,
              }
            },
            ["3"] = {
              {
                type = ACTION_TYPES.HIT,
                power = 2
              }
            },
            ["4"] = {
              {
                type = ACTION_TYPES.HIT,
                power = 2
              }
            },
            ["5"] = {
              {
                type = ACTION_TYPES.HIT,
                power = 2
              },
              {
                type = ACTION_TYPES.DAZED,
              }
            },
            ["6"] = {
              {
                type = ACTION_TYPES.HIT,
                power = 2
              },
              {
                type = ACTION_TYPES.DAZED,
              }
            },
          },
        },
        ["Acid Slime 2"] = {
          hp = 5,
          dieActions = {
            ["1"] = {
              {
                type = ACTION_TYPES.WEAK,
              }
            },
            ["2"] = {
              {
                type = ACTION_TYPES.WEAK,
              }
            },
            ["3"] = {
              {
                type = ACTION_TYPES.HIT,
                power = 2
              },
              {
                type = ACTION_TYPES.DAZED,
              }
            },
            ["4"] = {
              {
                type = ACTION_TYPES.HIT,
                power = 2
              },
              {
                type = ACTION_TYPES.DAZED,
              }
            },
            ["5"] = {
              {
                type = ACTION_TYPES.HIT,
                power = 2
              }
            },
            ["6"] = {
              {
                type = ACTION_TYPES.HIT,
                power = 2
              }
            },
          },
        },
        ["Acid Slime 3"] = {
          hp = 5,
          dieActions = {
            ["1"] = {
              {
                type = ACTION_TYPES.HIT,
                power = 2
              },
              {
                type = ACTION_TYPES.DAZED,
              }
            },
            ["2"] = {
              {
                type = ACTION_TYPES.HIT,
                power = 2
              },
              {
                type = ACTION_TYPES.DAZED,
              }
            },
            ["3"] = {
              {
                type = ACTION_TYPES.HIT,
                power = 2
              },
            },
            ["4"] = {
              {
                type = ACTION_TYPES.HIT,
                power = 2
              },
            },
            ["5"] = {
              {
                type = ACTION_TYPES.WEAK,
              }
            },
            ["6"] = {
              {
                type = ACTION_TYPES.WEAK,
              }
            },
          },
        },
        ["Acid Slime 4"] = {
          hp = 5,
          dieActions = {
            ["1"] = {
              {
                type = ACTION_TYPES.HIT,
                power = 2
              }
            },
            ["2"] = {
              {
                type = ACTION_TYPES.HIT,
                power = 2
              }
            },
            ["3"] = {
              {
                type = ACTION_TYPES.WEAK,
              }
            },
            ["4"] = {
              {
                type = ACTION_TYPES.WEAK,
              }
            },
            ["5"] = {
              {
                type = ACTION_TYPES.HIT,
                power = 2
              },
              {
                type = ACTION_TYPES.DAZED,
              }
            },
            ["6"] = {
              {
                type = ACTION_TYPES.HIT,
                power = 2
              },
              {
                type = ACTION_TYPES.DAZED,
              }
            },
          },
        },
      }
    },
    ["2"] = {},
    ["3"] = {}
  }
}

local NEOW_BLESSING_DATA = {
    ["998a64"] = {
      {
        effects = {
          {
            type = EFFECT_TYPES.GAIN_GOLD,
            payload = {
              amount = 4
            }
          }
        }
      },
      {
        effects = {
          {
            type = EFFECT_TYPES.REMOVE_CARD,
          }
        }
      },
      {
        effects = {
          {
            type = EFFECT_TYPES.UPGRADE_RANDOM_CARD,
            payload = {
              amount = 2
            }
          },
          {
            type = EFFECT_TYPES.GAIN_CURSE,
          }
        }
      }
    },
    ["6eeb68"] = {
      {
        effects = {
          {
            type = EFFECT_TYPES.UPGRADE_CARD,
          }
        }
      },
      {
        effects = {
          {
            type = EFFECT_TYPES.GAIN_RANDOM_POTION,
            payload = {
              amount = 3
            }
          }
        }
      },
      {
        effects = {
          {
            type = EFFECT_TYPES.TRANSFORM_CARD,
            payload = {
              amount = 2
            }
          },
          {
            type = EFFECT_TYPES.GAIN_CURSE
          }
        }
      }
    },
    ["c21e95"] = {
      {
        effects = {
          {
            type = EFFECT_TYPES.UPGRADE_CARD
          }
        }
      },
      {
        effects = {
          {
            type = EFFECT_TYPES.GAIN_RANDOM_RARE_CARD
          }
        }
      },
      {
        effects = {
          {
            type = EFFECT_TYPES.GAIN_GOLD,
            payload = {
              amount = 10
            }
          },
          {
            type = EFFECT_TYPES.GAIN_CURSE
          }
        }
      }
    },
    ["199138"] = {
      {
        effects = {
          {
            type = EFFECT_TYPES.UPGRADE_CARD
          }
        }
      },
      {
        effects = {
          {
            type = EFFECT_TYPES.GAIN_RANDOM_RARE_CARD
          }
        }
      },
      {
        effects = {
          {
            type = EFFECT_TYPES.GAIN_RELIC,
          },
          {
            type = EFFECT_TYPES.LOSE_HP,
            payload = {
              amount = 2
            }
          }
        }
      }
    },
    ["09c40f"] = {
      {
        effects = {
          {
            type = EFFECT_TYPES.UPGRADE_CARD,
          }
        }
      },
      {
        effects = {
          {
            type = EFFECT_TYPES.GAIN_COLORLESS_CARD,
          }
        }
      },
      {
        effects = {
          {
            type = EFFECT_TYPES.REMOVE_CARD,
            payload = {
              amount = 2
            }
          },
          {
            type = EFFECT_TYPES.LOSE_HP,
            payload = {
              amount = 2
            }
          }
        }
      }
    },
    ["9ce0e5"] = {
      {
        effects = {
          {
            type = EFFECT_TYPES.REMOVE_CARD
          }
        }
      },
      {
        effects = {
          {
            type = EFFECT_TYPES.GAIN_GOLD,
            payload = {
              amount = 4
            }
          }
        }
      },
      {
        effects = {
          {
            type = EFFECT_TYPES.UPGRADE_RANDOM_CARD,
            payload = {
              amount = 2
            }
          },
          {
            type = EFFECT_TYPES.LOSE_HP,
            payload = {
              amount = 2
            }
          }
        }
      }
    },
    ["cdd020"] = {
      {
        effects = {
          {
            type = EFFECT_TYPES.REMOVE_CARD
          }
        }
      },
      {
        effects = {
          {
            type = EFFECT_TYPES.GAIN_GOLD,
            payload = {
              amount = 4
            }
          }
        }
      },
      {
        effects = {
          {
            type = EFFECT_TYPES.GAIN_RANDOM_CARD,
            payload = {
              amount = 2
            }
          },
          {
            type = EFFECT_TYPES.LOSE_HP,
            payload = {
              amount = 2
            }
          }
        }
      },
      {
        lastButtonBigger = true
      }
    },
    ["c60c9d"] = {
      {
        effects = {
          {
            type = EFFECT_TYPES.UPGRADE_CARD,
          }
        }
      },
      {
        effects = {
          {
            type = EFFECT_TYPES.TRANSFORM_CARD
          }
        }
      },
      {
        effects = {
          {
            type = EFFECT_TYPES.GAIN_GOLD,
            payload = {
              amount = 8
            }
          },
          {
            type = EFFECT_TYPES.LOSE_HP,
            payload = {
              amount = 2
            }
          }
        }
      }
    },
    ["f66dd3"] = {
      {
        effects = {
          {
            type = EFFECT_TYPES.GAIN_COLORLESS_CARD,
          }
        }
      },
      {
        effects = {
          {
            type = EFFECT_TYPES.GAIN_RANDOM_POTION,
            payload = {
              amount = 3
            }
          }
        }
      },
      {
        effects = {
          {
            type = EFFECT_TYPES.GAIN_RELIC
          },
          {
            type = EFFECT_TYPES.LOSE_HP,
            payload = {
              amount = 2
            }
          }
        }
      }
    },
    ["ad34d0"] = {
      {
        effects = {
          {
            type = EFFECT_TYPES.TRANSFORM_CARD
          }
        }
      },
      {
        effects = {
          {
            type = EFFECT_TYPES.GAIN_RANDOM_POTION,
            payload = {
              amount = 3
            }
          }
        }
      },
      {
        effects = {
          {
            type = EFFECT_TYPES.GAIN_RARE_CARD
          },
          {
            type = EFFECT_TYPES.GAIN_CURSE
          }
        }
      }
    },
    ["89a376"] = {
      {
        effects = {
          {
            type = EFFECT_TYPES.GAIN_RANDOM_RARE_CARD
          }
        }
      },
      {
        effects = {
          {
            type = EFFECT_TYPES.GAIN_GOLD,
            payload = {
              amount = 4
            }
          }
        }
      },
      {
        effects = {
          {
            type = EFFECT_TYPES.REMOVE_CARD,
            payload = {
              amount = 2
            }
          },
          {
            type = EFFECT_TYPES.LOSE_GOLD,
            payload = {
              amount = 3
            }
          }
        }
      }
    },
    ["29021f"] = {
      {
        effects = {
          {
            type = EFFECT_TYPES.UPGRADE_CARD
          }
        }
      },
      {
        effects = {
          {
            type = EFFECT_TYPES.REMOVE_CARD
          }
        }
      },
      {
        effects = {
          {
            type = EFFECT_TYPES.GAIN_RANDOM_COLORLESS_CARD,
            payload = {
              amount = 2
            }
          },
          {
            type = EFFECT_TYPES.LOSE_GOLD,
            payload = {
              amount = 3
            }
          }
        }
      },
      {
        lastButtonBigger = true
      }
    },
    ["2b8654"] = {
      {
        effects = {
          {
            type = EFFECT_TYPES.GAIN_COLORLESS_CARD,
          }
        }
      },
      {
        effects = {
          {
            type = EFFECT_TYPES.GAIN_GOLD,
            payload = {
              amount = 4
            }
          }
        }
      },
      {
        effects = {
          {
            type = EFFECT_TYPES.GAIN_RARE_CARD,
          },
          {
            type = EFFECT_TYPES.LOSE_GOLD,
            payload = {
              amount = 3
            }
          }
        }
      }
    },
    ["b50bdb"] = {
      {
        effects = {
          {
            type = EFFECT_TYPES.GAIN_COLORLESS_CARD
          }
        }
      },
      {
        effects = {
          {
            type = EFFECT_TYPES.GAIN_RANDOM_POTION,
            payload = {
              amount = 3
            }
          }
        }
      },
      {
        effects = {
          {
            type = EFFECT_TYPES.GAIN_RELIC
          },
          {
            type = EFFECT_TYPES.GAIN_CURSE
          }
        }
      }
    },
    ["ed4ffd"] = {
      {
        effects = {
          {
            type = EFFECT_TYPES.TRANSFORM_CARD
          }
        }
      },
      {
        effects = {
          {
            type = EFFECT_TYPES.REMOVE_CARD
          }
        }
      },
      {
        effects = {
          {
            type = EFFECT_TYPES.UPGRADE_RANDOM_CARD,
            payload = {
              amount = 2
            }
          },
          {
            type = EFFECT_TYPES.LOSE_GOLD,
            payload = {
              amount = 3
            }
          }
        }
      }
    },
    ["e7c18a"] = {
      {
        effects = {
          {
            type = EFFECT_TYPES.GAIN_COLORLESS_CARD,
          }
        }
      },
      {
        effects = {
          {
            type = EFFECT_TYPES.UPGRADE_CARD,
          }
        }
      },
      {
        effects = {
          {
            type = EFFECT_TYPES.GAIN_RELIC,
          },
          {
            type = EFFECT_TYPES.LOSE_GOLD,
            payload = {
              amount = 3
            }
          }
        }
      }
    }
}

ABILITY_TRIGGER_TYPES = {
  DIE_RESULT = "Die result",
  START_OF_COMBAT = "Start of combat",
  START_OF_TURN = "Start of turn",
  ONCE_PER_TURN = "Once per turn",
  END_OF_TURN = "End of turn",
  END_OF_COMBAT = "End of combat",
  ONCE_PER_COMBAT = "Once per combat",
  ONCE_PER_ROOM = "Once per room",
  WHEN_REST = "When rest",
  AT_EVENT = "At event",
  AT_CAMP = "At camp",
  WHEN_DRAW_CURSE = "When draw curse",
  WHEN_ADD_SKILL = "When add skill",
  WHEN_ADD_ATTACK = "When add attack",
  N_TIMES_PER_COMBAT = "N times per combat"
}

function hornCleatHandler(arguments)
  local color = arguments.color
  local onDone = arguments.onDone

  local currentBlock = getBlockForPlayer(color)
  setBlockForPlayer(color, currentBlock + 1)
  onDone()
end

RELICS_DATA = {
  ["Incense Burner"] = {
    goldCost = 12,
  },
  ["Stone Calendar"] = {
    goldCost = 8,
    values = {
      ["5"] = {
        needsTarget = true,
        handler = function(arguments)
          local color = arguments.color
          local target = arguments.target
          local onDone = arguments.onDone

          damageEnemy({
            color = color,
            target = target,
            amount = 3
          })
          onDone()
        end
      }
    }
  },
  ["Captain's Wheel"] = {
    goldCost = 8,
  },
  ["Sundial"] = {
    goldCost = 7
  },
  ["Ice Cream"] = {
    goldCost = 10,
  },
  ["Necronomicon"] = {
    goldCost = 10,
  },
  ["Vajra"] = {
    goldCost = 8,
  },
  ["Pocketwatch"] = {
    goldCost = 9,
  },
  ["Orichalcum"] = {
    goldCost = 6,
  },
  ["Tungsten Rod"] = {
    goldCost = 8,
  },
  ["Oddly Smooth Stone"] = {
    goldCost = 7,
  },
  ["Strike Dummy"] = {
    goldCost = 9,
  },
  ["Pen Nib"] = {
    goldCost = 9,
  },
  ["Mutagen"] = {
    goldCost = 9,
  },
  ["Red Mask"] = {
    goldCost = 8,
  },
  ["Anchor"] = {
    goldCost = 6,
  },
  ["Bag of Preparation"] = {
    goldCost = 7,
  },
  ["Lantern"] = {
    goldCost = 6,
  },
  ["Blood Vial"] = {
    goldCost = 7,
  },
  ["Happy Flower"] = {
    goldCost = 6,
  },
  ["Runic Pyramid"] = {
    goldCost = 7,
  },
  ["Dead Branch"] = {
    goldCost = 11,
  },
  ["Calipers"] = {
    goldCost = 7,
  },
  ["Ornamental Fan"] = {
    goldCost = 8,
  },
  ["Letter Opener"] = {
    goldCost = 7,
  },
  ["Blue Candle"] = {
    goldCost = 7,
  },
  ["Ninja Scroll"] = {
    goldCost = 7,
  },
  ["Ink Bottle"] = {
    goldCost = 6,
  },
  ["Akabeko"] = {
    goldCost = 6,
  },
  ["Centennial Puzzle"] = {
    goldCost = 8,
  },
  ["Mummified Hand"] = {
    goldCost = 9,
  },
  ["The Courier"] = {
    goldCost = 6,
  },
  ["Mercury Hourglass"] = {
    goldCost = 7,
  },
  ["Du-Vu Doll"] = {
    goldCost = 7,
  },
  ["Omamori"] = {
    goldCost = 6,
  },
  ["Whetstone"] = {
    goldCost = 7,
  },
  ["War Paint"] = {
    goldCost = 8,
  },
  ["The Boot"] = {
    goldCost = 6,
  },
  ["Ssserpent Head"] = {
    goldCost = 6,
  },
  ["Old Coin"] = {

  },
  ["Peace Pipe"] = {
    goldCost = 8,
  },
  ["Toxic Egg"] = {
    goldCost = 9,
  },
  ["Molten Egg"] = {
    goldCost = 8,
  },
  ["Juzu Bracelet"] = {
    goldCost = 6,
  },
  ["Wing Boots"] = {
    goldCost = 9,
  },
  ["Horn Cleat"] = {
    goldCost = 7,
    values = {
      ["1"] = {
        handler = hornCleatHandler,
      },
      ["2"] = {
        handler = hornCleatHandler,
      }
    },
  },
  ["Regal Pillow"] = {
    goldCost = 6,
  },
  ["Dolly's Mirror"] = {
    goldCost = 8,
  },
  ["Golden Idol"] = {
    goldCost = 6,
  },
  ["Gambling Chip"] = {
    goldCost = 6,
  },
  ["Toolbox"] = {
    goldCost = 8,
  },
  ["Nilry's Codex"] = {
    goldCost = 8,
    handlers = {},
  },
  ["The Abacus"] = {
    goldCost = 7,
  },
  ["Duality"] = {
    goldCost = 7,
    values = {
      ["1"] = {
        handler = function()

        end
      },
      ["4"] = {
        handler = function()

        end,
        needsTarget = true
      }
    }
  },
  ["Gremlin Horn"] = {
    goldCost = 8,
  },
}

ABILITY_TRIGGER_TO_RELICS = {
  [ABILITY_TRIGGER_TYPES.WHEN_DRAW_CURSE] = {
    "Du-Vu Doll",
  },
  [ABILITY_TRIGGER_TYPES.DIE_RESULT] = {
    "Incense Burner",
    "Stone Calendar",
    "Captain's Wheel",
    "Sundial",
    "Necronomicon",
    "Vajra",
    "Pocketwatch",
    "Tungsten Rod",
    "Oddly Smooth Stone",
    "Pen Nib",
    "Red Mask",
    "Happy Flower",
    "Ink Bottle",
    "Mercury Hourglass",
    "The Boot",
    "Horn Cleat",
    "Dolly's Mirror",
    "Nilry's Codex",
    "Duality",
    "Gremlin Horn",
    "Snecko Eye",
  },
  [ABILITY_TRIGGER_TYPES.ONCE_PER_COMBAT] = {
    "Runic Pyramid",
    "Dead Branch",
    "Calipers",
    "Ornamental Fan",
    "Letter Opener",
    "Blue Candle",
    "Ninja Scroll",
    "Akabeko",
    "Centennial Puzzle",
    "Mummified Hand",
    "The Courier",
  },
  [ABILITY_TRIGGER_TYPES.START_OF_COMBAT] = {
    "Mutagen",
    "Anchor",
    "Bag of Preparation",
    "Lantern",
    "Blood Vial",
  },
  [ABILITY_TRIGGER_TYPES.START_OF_TURN] = {
    "Ice Cream",
    "Fusion Hammer",
    "Ectoplasm",
    "Ring of the Serpent",
    "Coffee Dripper",
    "Sozu",
  },
  [ABILITY_TRIGGER_TYPES.END_OF_TURN] = {
    "Orichalcum",
    "Thread and Needle",
  },
  [ABILITY_TRIGGER_TYPES.END_OF_COMBAT] = {
    "Golden Idol",
    "Black Blood",
    "White Beast Statue",
  },
  [ABILITY_TRIGGER_TYPES.ONCE_PER_TURN] = {
    "Strike Dummy",
  },
  [ABILITY_TRIGGER_TYPES.ONCE_PER_ROOM] = {
    "Gambling Chip",
    "Toolbox",
    "The Abacus",
  },
  [ABILITY_TRIGGER_TYPES.AT_EVENT] = {
    "Ssserpent Head",
    "Juzu Bracelet",
  },
  [ABILITY_TRIGGER_TYPES.WHEN_REST] = {
    "Peace Pipe",
    "Regal Pillow",
  },
  [ABILITY_TRIGGER_TYPES.WHEN_ADD_SKILL] = {
    "Toxic Egg"
  },
  [ABILITY_TRIGGER_TYPES.WHEN_ADD_ATTACK] = {
    "Molten Egg"
  },
  [ABILITY_TRIGGER_TYPES.N_TIMES_PER_COMBAT] = {
    "Nuclear Battery"
  }
}

function waitFrames(frames) --This function can only be used inside a coroutine because it is using coroutine.yield()
   while frames > 0 do --loop until frames = 0
      coroutine.yield(0) --this will wait 1 frame, reguardless of the number put inside coroutine.yield(#)
      frames = frames - 1 --decrement frames every loop
   end
end

function myLog(text)
  log(text)
  log("---------------------------")
end

function noopFunction()

end

function getDecksPosition(arguments)
  local color = arguments.color
  local handZone = getObjectFromGUID(OBJECTS.playerHands[color])
  local handZonePosition = handZone.getPosition()
  local character = GAME_DATA.players[color].character
  local characterBoard = getObjectFromGUID(OBJECTS.characterBoards[character])
  local boardBounds = characterBoard.getBoundsNormalized()

  return {
    x = handZonePosition.x - boardBounds.size.x / 2 - 1.6,
    y = handZonePosition.y,
    z = handZonePosition.z + 16
  }
end

function getRelicsGridPosition(arguments)
  local color = arguments.color
  local decksPosition = getDecksPosition({
    color = color
  })

  return {
    x = decksPosition.x,
    y = decksPosition.y,
    z = decksPosition.z + 19.8
  }
end

function getRelicsGridOffsetForNewRelic(arguments)
  local color = arguments.color
  local relicsCount = #GAME_DATA.players[color].relics
  local rowIndex = math.floor(relicsCount / 8)
  local columnIndex = relicsCount % 8

  return {
    x = columnIndex * 3,
    y = 0,
    z = -rowIndex * 3.3
  }
end

function getDrawDeckPosition(arguments)
  local decksPosition = getDecksPosition({
    color = arguments.color
  })

  return {
    x = decksPosition.x + 3,
    y = decksPosition.y,
    z = decksPosition.z + 8
  }
end

function getDiscardDeckPosition(arguments)
  local drawPosition = getDrawDeckPosition({
    color = arguments.color
  })

  return {
    x = drawPosition.x + 11,
    y = drawPosition.y,
    z = drawPosition.z
  }
end

function addHpMeterForEnemy(arguments)
  local guid = arguments.guid
  local card = getObjectFromGUID(guid)
  local name = card.getName()
  local cardPosition = card.getPosition()

  self.addDecal({
    name = guid,
    url = "http://cloud-3.steamusercontent.com/ugc/1945020522805785288/5D2DA9E8F63D1CF832B16B6E203DB06269625DDB/",
    position = {
      x = cardPosition.x - 0.4,
      y = cardPosition.y,
      z = cardPosition.z - 2.85
    },
    rotation = {
      x = 90,
      y = 0,
      z = 0
    },
    scale = {1, 1, 1}
  })

  local act = GAME_DATA.act
  local enemyStats = getEnemyStats({
    act = act,
    name = name,
    tag = card.getTags()[1]
  })
  card.createButton({
    click_function = "hp",
    label = tostring(enemyStats.hp),
    position = card.positionToLocal({
      x = cardPosition.x - 0.3,
      y = cardPosition.y,
      z = cardPosition.z - 2.85
    }),
    height = 0,
    width = 0,
    font_color = {
      r = 232/255,
      g = 101/255,
      b = 118/255
    },
    font_size = 130
  })
end

function removeHpMeterForEnemy(arguments)
  local guid = arguments.guid
  local decals = self.getDecals()
  for index, decal in ipairs(decals) do
    if decal.name == guid then
      table.remove(decals, index)
      break
    end
  end

  self.setDecals(decals)
end

function removeEffectsForEnemy(arguments)

end

function setEffectMetersForEnemy(arguments)
  local guid = arguments.guid
  local effects = arguments.effects
  local card = getObjectFromGUID(guid)
  local cardPosition = card.getPosition()
  local cardBounds = card.getBounds()

  local decals = {}
  local buttons = card.getButtons()
  for index, effect in ipairs(effects) do
    decals[index] = {
      name = effect.type,
      url = COMBAT_EFFECT_TO_DECAL_URL[effect.type],
      position = card.positionToLocal({
        x = cardPosition.x + 2.3,
        y = cardPosition.y,
        z = cardPosition.z + cardBounds.size.z / 2 - 0.5 - 1 * (index - 1)
      }),
      rotation = {
        x = 90,
        y = 0,
        z = 180
      },
      scale = {0.7, 0.7, 1}
    }
    for _, button in ipairs(buttons) do
      if button.click_function == effect.type then
        card.removeButton(button.index)
        break
      end
    end
    card.createButton({
      click_function = effect.type,
      label = tostring(effect.amount),
      position = {
        x = 1.8,
        y = 1,
        z = -cardBounds.size.z / 2 + 1.34 + 0.624 * (index - 1)
      },
      height = 0,
      width = 0,
      font_color = {
        r = 1,
        g = 1,
        b = 1
      },
      font_size = 130
    })
  end
  card.setDecals(decals)
end

function finishResolvingCard(arguments)
  function finishResolvingCardCoroutine()
    local color = arguments.color
    local cardGuid = arguments.cardGuid
    local card = getObjectFromGUID(cardGuid)
    local cardName = card.getName()

    myLog("Finish resolving card: "..cardName..".")

    GAME_DATA.combat.playingCard = nil
    table.insert(GAME_DATA.combat.players[color].playedCardGuidsThisCombat, cardGuid)
    table.insert(GAME_DATA.combat.players[color].playedCardGuidsThisTurn, cardGuid)

    local discardPosition = getDiscardDeckPosition({
      color = color,
    })
    card.setPositionSmooth(discardPosition, false, true)
    waitFrames(100)
    card.flip()
    return 1
  end

  startLuaCoroutine(self, "finishResolvingCardCoroutine")
end

function setEnergyForPlayerBoard(arguments)

end

function getEnergyForPlayer(color)
  return GAME_DATA.combat.players[color].energy
end

function setEnergyForPlayerBoard(arguments)
  local amount = arguments.amount
  local energyToken = getObjectFromGUID(arguments.energyToken)
  local character = arguments.character
  local characterBoard = getObjectFromGUID(OBJECTS.characterBoards[character])
  local boardPosition = characterBoard.getPosition()
  local boardBounds = characterBoard.getBounds()

  energyToken.setPositionSmooth({
    x = boardPosition.x - 6.23 + BOARD_ENERGY_OFFSET * amount,
    y = boardPosition.y + 1,
    z = boardPosition.z + boardBounds.size.z / 2 + -1.4,
  })
end

function setEnergyForPlayer(color, energy)
  local character = GAME_DATA.players[color].character
  local board = getObjectFromGUID(OBJECTS.characterBoards[character])
  board.call("setEnergy", {
    amount = energy
  })
  GAME_DATA.combat.players[color].energy = energy
end

function getBlockForPlayer(color)
  return GAME_DATA.combat.players[color].block
end

function setBlockForPlayerBoard(arguments)
  local amount = arguments.amount
  local blockToken = getObjectFromGUID(arguments.blockToken)
  local character = arguments.character
  local characterBoard = getObjectFromGUID(OBJECTS.characterBoards[character])
  local boardPosition = characterBoard.getPosition()
  local boardBounds = characterBoard.getBounds()

  blockToken.setPositionSmooth({
    x = boardPosition.x - 6.23 + BOARD_BLOCK_OFFSET * amount,
    y = boardPosition.y + 1,
    z = boardPosition.z + boardBounds.size.z / 2 + -3.6,
  })
end

function setBlockForPlayer(color, block)
  local logString = color.." current block: "..GAME_DATA.combat.players[color].block
  logString = logString..".\nSet block to: "..block.."."
  myLog(logString)
  local character = GAME_DATA.players[color].character
  local board = getObjectFromGUID(OBJECTS.characterBoards[character])
  board.call("setBlock", {
    amount = block
  })
  GAME_DATA.combat.players[color].block = block
end

function addBlockForEnemy(guid, block)
  local enemyData = GAME_DATA.combat.enemies[guid]
  local enemyName = enemyData.name
  local newBlock = enemyData.block + block
  local logString = enemyName.." current block: "..enemyData.block
  logString = logString..".\nAdd "..block.." block.\n"
  logString = logString.."New block: "..newBlock.."."
  myLog(logString)

  local card = getObjectFromGUID(guid)
  card.UI.setAttribute("Block image", "active", "true")
  card.UI.setAttributes("Block text", {
    active = "true",
    text = tostring(newBlock)
  })
  enemyData.block = newBlock
end

function setCharacterBoardHp(arguments)
  local character = arguments.character
  local value = arguments.value
  local hpToken = getObjectFromGUID(arguments.hpToken)
  local characterBoard = getObjectFromGUID(OBJECTS.characterBoards[character])
  local maxHp = CHARACTER_MAX_HP[character]
  local boardPosition = characterBoard.getPosition()
  local boardBounds = characterBoard.getBounds()
  local boardStart = boardPosition.x - boardBounds.size.x / 2

  hpToken.setPositionSmooth({
    x = boardStart + BOARD_LEFT_OFFSET + BOARD_HP_OFFSET * value - 1,
    y = boardPosition.y + 1,
    z = boardPosition.z + boardBounds.size.z / 2 + -5.8,
  })
end

function losePlayerHp(color, amount)
  local playerData = GAME_DATA.players[color]
  local character = playerData.character
  local newHp = playerData.hp - amount
  local logString = color.." current hp: "..playerData.hp
  logString = logString..".\nLose "..amount.." hp.\n"
  logString = logString.."New hp: "..newHp.."."
  myLog(logString)
  local characterBoard = getObjectFromGUID(OBJECTS.characterBoards[character])
  characterBoard.call("setHp", { value = newHp })
  playerData.hp = newHp
end

function resolveCardActionBlock(arguments)
  local color = arguments.color
  local target = arguments.target
  local targetType = target.type
  local targetColor = target.color
  local amount = arguments.amount

  if targetType ~= TARGET_TYPES.PLAYER then
    targetType = TARGET_TYPES.PLAYER
    targetColor = color
  end

  local currentBlock = getBlockForPlayer(targetColor)
  setBlockForPlayer(targetColor, currentBlock + amount)
end

function killEnemy(arguments)
  local guid = arguments.guid
  local enemy = GAME_DATA.combat.enemies[guid]
  local zone = getObjectFromGUID(OBJECTS.combat.enemyToZone[guid])
  myLog("Enemy is killed: "..enemy.name..".")
  local card = getObjectFromGUID(guid)
  removeEffectsForEnemy({
    guid = guid
  })
  removeHpMeterForEnemy({
    guid = guid
  })
  zone.destruct()
  card.flip()
end

function damageEnemy(arguments)
  local color = arguments.color
  local target = arguments.target
  local amount = arguments.amount
  local enemyGuid = target.guid

  local newHp = GAME_DATA.combat.enemies[enemyGuid].hp - amount
  local logString = "Damage enemy \""..GAME_DATA.combat.enemies[enemyGuid].name.."\".\n"
  logString = logString.."Current hp: "..GAME_DATA.combat.enemies[enemyGuid].hp..".\n"
  logString = logString.."New hp: "..newHp.."."
  myLog(logString)
  GAME_DATA.combat.enemies[enemyGuid].hp = newHp
  local card = getObjectFromGUID(enemyGuid)
  local buttons = card.getButtons()
  for _, button in ipairs(buttons) do
    if button.click_function == "hp" then
      card.editButton({
        index = button.index,
        label = tostring(newHp)
      })
    end
  end
  if newHp <= 0 then
    killEnemy({
      guid = enemyGuid
    })
  end
end

function resolveCardActionDamage(arguments)
  damageEnemy(arguments)
end

function resolveCardActionWeak(arguments)
  local color = arguments.color
  local target = arguments.target
  local enemyGuid = target.guid
  local enemyData = GAME_DATA.combat.enemies[enemyGuid]

  myLog("Weak enemy \""..enemyData.name.."\".")
  local hasWeakIndex = -1
  for index, effect in ipairs(enemyData.effects) do
    if effect.type == COMBAT_EFFECT_TYPES.WEAK then
      hasWeakIndex = index
    end
  end
  if hasWeakIndex ~= -1 then
    enemyData.effects[hasWeakIndex].amount = enemyData.effects[hasWeakIndex].amount + 1
  else
    table.insert(enemyData.effects, {
      type = COMBAT_EFFECT_TYPES.WEAK,
      amount = 1
    })
  end

  setEffectMetersForEnemy({
    guid = enemyGuid,
    effects = enemyData.effects
  })
end

function resolveCardActionHit(arguments)
  local color = arguments.color
  local target = arguments.target
  local power = arguments.power

  resolveCardActionDamage({
    color = color,
    target = target,
    amount = power,
  })
end

function resolveCardStrike(arguments)
  local color = arguments.color
  local cardGuid = arguments.cardGuid
  local target = arguments.target

  resolveCardActionHit({
    color = color,
    cardGuid = cardGuid,
    target = target,
    power = 1
  })

  finishResolvingCard(arguments)
end

function resolveCardDefend(arguments)
  local color = arguments.color
  local cardGuid = arguments.cardGuid
  local target = arguments.target

  resolveCardActionBlock({
    color = color,
    cardGuid = cardGuid,
    target = {
      type = TARGET_TYPES.PLAYER,
      color = color,
    },
    amount = 1
  })

  finishResolvingCard(arguments)
end

function resolveCardSilentStrike(arguments)
  resolveCardStrike(arguments)
end

function resolveCardSilentDefend(arguments)
  resolveCardDefend(arguments)
end

function resolveCardSilentNeutralize(arguments)
  local color = arguments.color
  local cardGuid = arguments.cardGuid
  local target = arguments.target

  resolveCardActionHit({
    color = color,
    cardGuid = cardGuid,
    target = target,
    power = 1
  })

  resolveCardActionWeak({
    color = color,
    cardGuid = cardGuid,
    target = target
  })

  finishResolvingCard(arguments)
end

function resolveCardSilentSurvivor(arguments)
  local color = arguments.color
  local cardGuid = arguments.cardGuid

  resolveCardActionBlock({
    color = color,
    cardGuid = cardGuid,
    target = {
      type = TARGET_TYPES.PLAYER,
      color = color,
    },
    amount = 2
  })

  finishResolvingCard(arguments)
end

function resolveCardIroncladStrike(arguments)
  resolveCardStrike(arguments)
end

function resolveCardIroncladDefend(arguments)
  resolveCardDefend(arguments)
end

function resolveCardIroncladBash(arguments)
  finishResolvingCard(arguments)
end

function resolveCardDefectStrike(arguments)
  resolveCardStrike(arguments)
end

function resolveCardDefectDefend(arguments)
  resolveCardDefend(arguments)
end

function resolveCardWatcherStrike(arguments)
  resolveCardStrike(arguments)
end

function resolveCardWatcherDefend(arguments)
  resolveCardDefend(arguments)
end

function getEnemyStats(arguments)
  local tag = arguments.tag
  local name = arguments.name
  local act = arguments.act
  if not GAME_DATA.isFirstEncounterDone and act == 1 and tag == "Encounter" then
    act = "First Encounter"
  end

  return ENEMIES_DATA.acts[tostring(act)][tag][name]
end

function getPlayingColors()
  local colors = {}
  for color, data in pairs(GAME_DATA.players) do
    if data.character ~= nil then
      table.insert(colors, color)
    end
  end
  return colors
end

function getPositionForGoldGain(arguments)
  local bowl = arguments.bowl
  local bowlBounds = bowl.getBounds()
  local playerBowlPosition = bowl.getPosition()
  local index = arguments.index or 0
  local position = {
    x = playerBowlPosition.x,
    y = playerBowlPosition.y + 3 + index * 0.3,
    z = playerBowlPosition.z,
  }
  return position
end

function getPositionForMap(arguments)
  local map = arguments.map
  local mapBounds = map.getBounds()
  local tableObject = Tables.getTableObject()
  local tableBounds = tableObject.getBounds()

  return {
    x = -tableBounds.size.x / 2 + mapBounds.size.x / 2 + 25,
    y = 2,
    z = tableBounds.center.z + 9,
  }
end

function upgradeCardThenMoveTo(arguments)
  local card = arguments.card
  local position = arguments.position
  function upgradeCardCoroutine()
    local rotation = card.getRotation()
    local isFlipped = rotation.z ~= 180
    local upgradedCard = card.setState(2)
    waitFrames(50)
    if isFlipped then
      upgradedCard.flip()
    end
    upgradedCard.setPositionSmooth(position)
    return 1
  end

  startLuaCoroutine(self, "upgradeCardCoroutine")
end

function removeButtonWithFunctionName(arguments)
  local object = arguments.object
  local name = arguments.name
  local buttons = object.getButtons()
  if buttons == nil then
    return
  end
  for _, button in ipairs(buttons) do
    if button.click_function == name then
      object.removeButton(button.index)
      break
    end
  end
end

function doForCardInDeck(arguments)
  local amount = arguments.amount
  local deck = arguments.deck
  local callback = arguments.callback
  local remainingCallback = arguments.remainingCallback

  local index = 0
  local cardsData = deck.getObjects()
  local deckPosition = deck.getPosition()
  while index ~= amount and index ~= #cardsData do
    if #cardsData - index == 1 then
      local card = getObjectFromGUID(cardsData[index + 1].guid)
      callback({
        card = card
      })
    else
      deck.takeObject({
        guid = cardsData[index + 1].guid,
        position = {
          x = deckPosition.x,
          y = deckPosition.y,
          z = deckPosition.z + 3 + (index * 3)
        },
        callback_function = function(card)
          callback({
            card = card
          })
        end
      })
    end
    index = index + 1
  end

  local remainingTotal = #cardsData - index
  while index ~= #cardsData and remainingCallback ~= nil do
    if #cardsData - index == 1 then
      local card = getObjectFromGUID(cardsData[index + 1].guid)
      remainingCallback({
        card = card,
        remainingTotal = remainingTotal
      })
      break
    else
      deck.takeObject({
        guid = cardsData[index + 1].guid,
        position = {
          x = deckPosition.x,
          y = deckPosition.y,
          z = deckPosition.z + 3 + (index * 3)
        },
        callback_function = function(card)
          remainingCallback({
            card = card,
            remainingTotal = remainingTotal
          })
        end
      })
    end
    index = index + 1
  end
end

function handleCardOperation(arguments)
  local color = arguments.color
  local colorClicks = arguments.colorClicks
  local character = GAME_DATA.players[color].character
  local operationKey = arguments.operationKey
  local operationData = GAME_DATA.players[color][operationKey]
  local buttonFunctionPrefix = arguments.buttonFunctionPrefix
  local operationZones = arguments.operationZones
  local operationPlayerToZone = arguments.operationPlayerToZone
  local validateCards = arguments.validateCards
  local callback = arguments.callback
  local remainingCallback = arguments.remainingCallback

  if color ~= colorClicks then
    return
  end

  local tableObject = Tables.getTableObject()
  local zone = getObjectFromGUID(operationZones[color])
  local objectData = zone.getObjects()[1]

  function doneOperation(waitCount)
    removeButtonWithFunctionName({
      object = tableObject,
      name = buttonFunctionPrefix..color
    })

    operationZones[color] = nil
    operationPlayerToZone[zone.guid] = nil
    zone.destruct()
    local board = getObjectFromGUID(OBJECTS.characterBoards[GAME_DATA.players[color].character])
    local boardPosition = board.getPosition()
    local drawPosition = getDrawDeckPosition({
      color = color
    })
    local areaPosition = tableObject.positionToLocal({
      x = boardPosition.x,
      y = boardPosition.y,
      z = drawPosition.z - 4
    })
    local tableObject = Tables.getTableObject()
    local snapPoints = tableObject.getSnapPoints()
    local indexToRemove = -1
    for index, snapPoint in ipairs(snapPoints) do
      if snapPoint.position.x == areaPosition.x and
        snapPoint.position.y == areaPosition.y and
        snapPoint.position.z == areaPosition.z then
          indexToRemove = index
          break
        end
    end
    if indexToRemove ~= -1 then
      table.remove(snapPoints, indexToRemove)
      tableObject.setSnapPoints(snapPoints)
    end

    local doneCallbacks = operationData.onDone
    GAME_DATA.players[color][operationKey] = nil
    for _, callback in ipairs(doneCallbacks) do
      callback(waitCount)
    end
  end

  if objectData == nil then
    doneOperation(10)
    return
  end
  local deckPosition = getDecksPosition({
    color = color
  })
  local object = getObjectFromGUID(objectData.guid)
  if object.name == "Deck" then
    local objectPosition = object.getPosition()
    local cardsData = object.getObjects()
    if validateCards ~= nil and not validateCards(cardsData) then
      return
    end

    local cardsHandled = 0
    doForCardInDeck({
      deck = object,
      amount = operationData.amount,
      callback = function(args)
        callback(args.card, function(waitCount)
          cardsHandled = cardsHandled + 1
          if cardsHandled == #cardsData then
            doneOperation(waitCount)
          end
        end)
      end,
      remainingCallback = function(args)
        remainingCallback(args.card, function(waitCount)
          cardsHandled = cardsHandled + 1
          if cardsHandled == #cardsData then
            doneOperation(waitCount)
          end
        end)
      end
    })
  else
    if validateCards ~= nil and not validateCards({
      {
        guid = object.guid,
        tags = object.getTags(),
        name = object.getName()
      }
    }) then
      return
    end

    callback(object, doneOperation)
  end
end

function handleUpgradeCardClick(arguments)
  local deckPosition = getDecksPosition({
    color = arguments.color
  })
  handleCardOperation({
    color = arguments.color,
    colorClicks = arguments.colorClicks,
    operationKey = "cardUpgradeInProgress",
    operationZones = OBJECTS.playerUpgradeCardScriptingZones,
    operationPlayerToZone = OBJECTS.upgradeCardScriptingZoneToPlayer,
    buttonFunctionPrefix = "handleUpgradeCardClick",
    callback = function(card, done)
      upgradeCardThenMoveTo({
        card = card,
        position = deckPosition
      })
      done(450)
    end,
    remainingCallback = function(card, done)
      local rotation = card.getRotation()
      local isFlipped = rotation.z ~= 180
      if isFlipped then
        card.flip()
      end
      card.setPositionSmooth(deckPosition, false, true)
      done(200)
    end
  })
end

function handleUpgradeCardClickRed(_, clickColor)
  handleUpgradeCardClick({
    color = "Red",
    colorClicks = clickColor
  })
end

function handleUpgradeCardClickGreen(_, clickColor)
  handleUpgradeCardClick({
    color = "Green",
    colorClicks = clickColor
  })
end

function handleUpgradeCardClickBlue(_, clickColor)
  handleUpgradeCardClick({
    color = "Blue",
    colorClicks = clickColor
  })
end

function handleUpgradeCardClickPink(_, clickColor)
  handleUpgradeCardClick({
    color = "Pink",
    colorClicks = clickColor
  })
end

function getPlayerAreaPosition(arguments)
  local color = arguments.color
  local board = getObjectFromGUID(OBJECTS.characterBoards[GAME_DATA.players[color].character])
  local boardPosition = board.getPosition()
  local drawPosition = getDrawDeckPosition({
    color = color
  })
  return {
    x = boardPosition.x,
    y = boardPosition.y,
    z = drawPosition.z - 4
  }
end

function prepareAreaForCards(arguments)
  local color = arguments.color
  local hideButton = arguments.hideButton
  local playerToZone = arguments.playerToZone
  local zoneToPlayer = arguments.zoneToPlayer
  local clickFunctionPrefix = arguments.clickFunctionPrefix
  local label = arguments.label
  local areaBounds = {
    x = 12,
    y = 0.3,
    z = 3.3
  }
  local areaPosition = getPlayerAreaPosition({
    color = color
  })

  local tableObject = Tables.getTableObject()
  local tableSnapPoints = tableObject.getSnapPoints()
  table.insert(tableSnapPoints, {
    position = tableObject.positionToLocal({
      x = areaPosition.x,
      y = areaPosition.y,
      z = areaPosition.z,
    })
  })
  tableObject.setSnapPoints(tableSnapPoints)
  spawnObject({
    type = "ScriptingTrigger",
    position = areaPosition,
    scale = { 2, 2, 2 },
    callback_function = function(zone)
      playerToZone[color] = zone.guid
      zoneToPlayer[zone.guid] = color
    end
  })
  if not hideButton then
    local clickFunction = clickFunctionPrefix..color
    tableObject.createButton({
      click_function = clickFunction,
      function_owner = self,
      label = label,
      position = tableObject.positionToLocal({
        x = -areaPosition.x,
        y = areaPosition.y,
        z = areaPosition.z - 2.5,
      }),
      rotation = { 0, 180, 0 },
      width = 1200,
      height = 100,
      font_size = 100,
      scale = { 1, 1, 1 }
    })
  end
end

function prepareAreaForCardUpgrade(arguments)
  local hideButton = arguments.hideButton or false
  local color = arguments.color
  local amount = arguments.amount or 1
  local onDone = arguments.onDone

  if GAME_DATA.players[color].cardUpgradeInProgress ~= nil then
    return
  end
  GAME_DATA.players[color].cardUpgradeInProgress = {
    amount = amount,
    onDone = {onDone}
  }

  local label = "Upgrade ("
  if amount == 1 then
    label = label..amount.." card max)"
  else
    label = label..amount.." cards max)"
  end
  prepareAreaForCards({
    hideButton = hideButton,
    color = color,
    label = label,
    playerToZone = OBJECTS.playerUpgradeCardScriptingZones,
    zoneToPlayer = OBJECTS.upgradeCardScriptingZoneToPlayer,
    clickFunctionPrefix = "handleUpgradeCardClick",
  })
end

function handleRemoveCardClick(arguments)
  local deckPosition = getDecksPosition({
    color = arguments.color
  })
  handleCardOperation({
    color = arguments.color,
    colorClicks = arguments.colorClicks,
    operationKey = "cardRemoveInProgress",
    operationZones = OBJECTS.playerRemoveCardScriptingZones,
    operationPlayerToZone = OBJECTS.removeCardScriptingZoneToPlayer,
    buttonFunctionPrefix = "handleRemoveCardClick",
    callback = function(card, done)
      card.destruct()
      done(100)
    end,
    remainingCallback = function(card, done)
      local rotation = card.getRotation()
      local isFlipped = rotation.z ~= 180
      if isFlipped then
        card.flip()
      end
      card.setPositionSmooth(deckPosition, false, true)
      done(200)
    end
  })
end

function handleRemoveCardClickRed(_, clickColor)
  handleRemoveCardClick({
    color = "Red",
    colorClicks = clickColor
  })
end

function handleRemoveCardClickGreen(_, clickColor)
  handleRemoveCardClick({
    color = "Green",
    colorClicks = clickColor
  })
end

function handleRemoveCardClickBlue(_, clickColor)
  handleRemoveCardClick({
    color = "Blue",
    colorClicks = clickColor
  })
end

function handleRemoveCardClickPink(_, clickColor)
  handleRemoveCardClick({
    color = "Pink",
    colorClicks = clickColor
  })
end

function prepareAreaForCardRemove(arguments)
  local color = arguments.color
  local amount = arguments.amount or 1
  local onDone = arguments.onDone

  if GAME_DATA.players[color].cardRemoveInProgress ~= nil then
    return
  end
  GAME_DATA.players[color].cardRemoveInProgress = {
    amount = amount,
    onDone = {onDone}
  }

  local label = "Remove ("
  if amount == 1 then
    label = label..amount.." card max)"
  else
    label = label..amount.." cards max)"
  end
  prepareAreaForCards({
    color = color,
    label = label,
    playerToZone = OBJECTS.playerRemoveCardScriptingZones,
    zoneToPlayer = OBJECTS.removeCardScriptingZoneToPlayer,
    clickFunctionPrefix = "handleRemoveCardClick",
  })
end

function handleTransformCardClick(arguments)
  local deckPosition = getDecksPosition({
    color = arguments.color
  })
  handleCardOperation({
    color = arguments.color,
    colorClicks = arguments.colorClicks,
    operationKey = "cardTransformInProgress",
    operationZones = OBJECTS.playerTransformCardScriptingZones,
    operationPlayerToZone = OBJECTS.transformCardScriptingZoneToPlayer,
    buttonFunctionPrefix = "handleTransformCardClick",
    validateCards = function(cardsData)
      local hasCurse = false
      for _, cardData in ipairs(cardsData) do
        local tags = cardData.tags
        for _, tag in ipairs(tags) do
          if tag == "Curse" then
            hasCurse = true
            break
          end
        end
      end
      if hasCurse then
        broadcastToColor("You can't transform curse, please remove it.", arguments.color)
      end
      return not hasCurse
    end,
    callback = function(card, done)
      local cardPosition = card.getPosition()
      card.destruct()
      takeRewardCard({
        color = arguments.color,
        position = cardPosition,
        flip = true,
        callback_function = function(card)
          card.flip()
          card.setPositionSmooth(deckPosition, false, true)
          done(200)
        end
      })
    end,
    remainingCallback = function(card, done)
      local rotation = card.getRotation()
      local isFlipped = rotation.z ~= 180
      if isFlipped then
        card.flip()
      end
      card.setPositionSmooth(deckPosition, false, true)
      done(200)
    end
  })
end

function handleTransformCardClickRed(_, clickColor)
  handleTransformCardClick({
    color = "Red",
    colorClicks = clickColor
  })
end

function handleTransformCardClickGreen(_, clickColor)
  handleTransformCardClick({
    color = "Green",
    colorClicks = clickColor
  })
end

function handleTransformCardClickBlue(_, clickColor)
  handleTransformCardClick({
    color = "Blue",
    colorClicks = clickColor
  })
end

function handleTransformCardClickPink(_, clickColor)
  handleTransformCardClick({
    color = "Pink",
    colorClicks = clickColor
  })
end

function prepareAreaForCardTransform(arguments)
  local color = arguments.color
  local amount = arguments.amount or 1
  local onDone = arguments.onDone

  if GAME_DATA.players[color].cardTransformInProgress ~= nil then
    return
  end
  GAME_DATA.players[color].cardTransformInProgress = {
    amount = amount,
    onDone = {onDone}
  }

  local label = "Transform ("
  if amount == 1 then
    label = label..amount.." card max)"
  else
    label = label..amount.." cards max)"
  end
  prepareAreaForCards({
    color = color,
    label = label,
    playerToZone = OBJECTS.playerTransformCardScriptingZones,
    zoneToPlayer = OBJECTS.transformCardScriptingZoneToPlayer,
    clickFunctionPrefix = "handleTransformCardClick",
  })
end

function endOptionalGain(arguments)
  local color = arguments.color
  local taken = arguments.taken

  local tableObject = Tables.getTableObject()
  local buttons = tableObject.getButtons()
  for _, button in ipairs(buttons) do
    if button.click_function == "handleSkipOptionalGainClick"..color then
      tableObject.removeButton(button.index)
      break
    end
  end

  local objectGuids = GAME_DATA.players[color].optionalGainInProgress.objects
  local deck = getObjectFromGUID(GAME_DATA.players[color].optionalGainInProgress.deck)
  for index, guid in ipairs(objectGuids) do
    if not taken[guid] then
      local object = getObjectFromGUID(guid)
      deck.putObject(object)
    end
  end
  local doneCallbacks = GAME_DATA.players[color].optionalGainInProgress.onDone
  GAME_DATA.players[color].optionalGainInProgress = nil
  for _, callback in ipairs(doneCallbacks) do
    callback()
  end
end

function handleSkipOptionalGainClick(arguments)
  local color = arguments.color
  local colorClicks = arguments.colorClicks

  if colorClicks ~= color then
    return
  end

  endOptionalGain({
    color = color,
    taken = {}
  })
end

function handleSkipOptionalGainClickRed(_, clickColor)
  handleSkipOptionalGainClick({
    color = "Red",
    colorClicks = clickColor
  })
end

function handleSkipOptionalGainClickGreen(_, clickColor)
  handleSkipOptionalGainClick({
    color = "Green",
    colorClicks = clickColor
  })
end

function handleSkipOptionalGainClickBlue(_, clickColor)
  handleSkipOptionalGainClick({
    color = "Blue",
    colorClicks = clickColor
  })
end

function handleSkipOptionalGainClickPink(_, clickColor)
  handleSkipOptionalGainClick({
    color = "Pink",
    colorClicks = clickColor
  })
end

function takeRewardCallbackRed(arguments)
  local card = arguments.card
  local callback = arguments.callback
  local rareDeck = arguments.rareDeck
  local position = arguments.position
  local flip = arguments.flip
  local rewardDeck = arguments.rewardDeck

  function takeRewardCallbackRedCoroutine()
    local name = card.getName()
    if name ~= "Golden Ticket" then
      callback(card)
      return 1
    end
    waitFrames(100)
    rewardDeck.putObject(card)
    rareDeck.takeObject({
      position = position,
      flip = flip,
      callback_function = function(rareCard)
        callback(rareCard, true)
      end
    })

    return 1
  end
  startLuaCoroutine(self, "takeRewardCallbackRedCoroutine")
end

function takeRewardCallbackGreen(arguments)
  local card = arguments.card
  local callback = arguments.callback
  local rareDeck = arguments.rareDeck
  local position = arguments.position
  local flip = arguments.flip
  local rewardDeck = arguments.rewardDeck

  function takeRewardCallbackGreenCoroutine()
    local name = card.getName()
    if name ~= "Golden Ticket" then
      callback(card)
      return 1
    end
    waitFrames(100)
    rewardDeck.putObject(card)
    rareDeck.takeObject({
      position = position,
      flip = flip,
      callback_function = function(rareCard)
        callback(rareCard, true)
      end
    })

    return 1
  end
  startLuaCoroutine(self, "takeRewardCallbackGreenCoroutine")
end

function takeRewardCallbackBlue(arguments)
  local card = arguments.card
  local callback = arguments.callback
  local rareDeck = arguments.rareDeck
  local position = arguments.position
  local flip = arguments.flip
  local rewardDeck = arguments.rewardDeck

  function takeRewardCallbackBlueCoroutine()
    local name = card.getName()
    if name ~= "Golden Ticket" then
      callback(card)
      return 1
    end
    waitFrames(100)
    rewardDeck.putObject(card)
    rareDeck.takeObject({
      position = position,
      flip = flip,
      callback_function = function(rareCard)
        callback(rareCard, true)
      end
    })

    return 1
  end
  startLuaCoroutine(self, "takeRewardCallbackBlueCoroutine")
end

function takeRewardCallbackPink(arguments)
  local card = arguments.card
  local callback = arguments.callback
  local rareDeck = arguments.rareDeck
  local position = arguments.position
  local flip = arguments.flip
  local rewardDeck = arguments.rewardDeck

  function takeRewardCallbackPinkCoroutine()
    local name = card.getName()
    if name ~= "Golden Ticket" then
      callback(card)
      return 1
    end
    waitFrames(100)
    rewardDeck.putObject(card)
    rareDeck.takeObject({
      position = position,
      flip = flip,
      callback_function = function(rareCard)
        callback(rareCard, true)
      end
    })

    return 1
  end
  startLuaCoroutine(self, "takeRewardCallbackPinkCoroutine")
end

function takeRewardCard(arguments)
  local color = arguments.color
  local character = GAME_DATA.players[color].character
  local rareDeck = getObjectFromGUID(OBJECTS.characterDecks[character].rareDeck)
  local rewardDeck = getObjectFromGUID(OBJECTS.characterDecks[character].rewardsDeck)

  local callback = arguments.callback_function

  rewardDeck.takeObject({
    position = arguments.position,
    flip = arguments.flip,
    callback_function = function(card)
      Global.call("takeRewardCallback"..color, {
        card = card,
        rewardDeck = rewardDeck,
        rareDeck = rareDeck,
        callback = callback,
        position = arguments.position,
        flip = arguments.flip,
      })
    end
  })
end

function prepareAreaForOptionalGain(arguments)
  local color = arguments.color
  local deck = getObjectFromGUID(arguments.deck)
  local character = GAME_DATA.players[color].character
  local tag = arguments.tag
  local amount = arguments.amount or 1
  local onDone = arguments.onDone

  if GAME_DATA.players[color].optionalGainInProgress ~= nil then
    return
  end
  GAME_DATA.players[color].optionalGainInProgress = {
    deck = arguments.deck,
    amount = amount,
    tag = tag,
    objects = {},
    onDone = {onDone}
  }

  local board = getObjectFromGUID(OBJECTS.characterBoards[GAME_DATA.players[color].character])
  local boardPosition = board.getPosition()
  local drawPosition = getDrawDeckPosition({
    color = color
  })
  local areaBounds = {
    x = 12,
    y = 0.3,
    z = 3.3
  }
  local areaPosition = {
    x = boardPosition.x,
    y = boardPosition.y,
    z = drawPosition.z - 4
  }

  local takeObject = deck.takeObject
  if deck.guid == OBJECTS.characterDecks[character].rewardsDeck then
    takeObject = takeRewardCard
  end
  local objects = GAME_DATA.players[color].optionalGainInProgress.objects
  if amount == 1 then
    takeObject({
      color = color,
      position = areaPosition,
      flip = true,
      callback_function = function(object)
        table.insert(objects, object.guid)
      end
    })
  elseif amount == 2 then
    takeObject({
      color = color,
      position = {
        x = areaPosition.x - 2,
        y = areaPosition.y,
        z = areaPosition.z
      },
      flip = true,
      callback_function = function(object)
        table.insert(objects, object.guid)
      end
    })
    takeObject({
      color = color,
      position = {
        x = areaPosition.x + 2,
        y = areaPosition.y,
        z = areaPosition.z
      },
      flip = true,
      callback_function = function(object)
        table.insert(objects, object.guid)
      end
    })
  elseif amount == 3 then
    takeObject({
      color = color,
      position = {
        x = areaPosition.x - 4,
        y = areaPosition.y,
        z = areaPosition.z
      },
      flip = true,
      callback_function = function(object)
        table.insert(objects, object.guid)
      end
    })
    takeObject({
      color = color,
      position = {
        x = areaPosition.x,
        y = areaPosition.y,
        z = areaPosition.z
      },
      flip = true,
      callback_function = function(object)
        table.insert(objects, object.guid)
      end
    })
    takeObject({
      color = color,
      position = {
        x = areaPosition.x + 4,
        y = areaPosition.y,
        z = areaPosition.z
      },
      flip = true,
      callback_function = function(object)
        table.insert(objects, object.guid)
      end
    })
  end

  local tableObject = Tables.getTableObject()
  local clickFunction = "handleSkipOptionalGainClick"..color
  tableObject.createButton({
    click_function = clickFunction,
    function_owner = self,
    label = "Skip",
    position = tableObject.positionToLocal({
      x = -areaPosition.x,
      y = areaPosition.y,
      z = areaPosition.z - 2.5,
    }),
    rotation = { 0, 180, 0 },
    width = 300,
    height = 100,
    font_size = 100,
    scale = { 1, 1, 1 }
  })
end

function repeatPrepareAreaForOptionalGain(count, arguments)
  local doneCount = 0
  local originalOnDone = arguments.onDone

  function onDone()
    doneCount = doneCount + 1
    if doneCount == count then
      if originalOnDone ~= nil then
        originalOnDone()
      end
      return
    end

    prepareAreaForOptionalGain(arguments)
  end

  arguments.onDone = onDone
  prepareAreaForOptionalGain(arguments)
end

function handleGainGoldEffect(arguments)
  local amount = arguments.amount
  local color = arguments.color
  local onDone = arguments.onDone

  local goldBag1 = getObjectFromGUID(OBJECTS.goldBag1)
  local goldBag5 = getObjectFromGUID(OBJECTS.goldBag5)
  local remainingGold1 = #goldBag1.getObjects()
  local remainingGold5 = #goldBag5.getObjects()
  local remainingGoldTotal = remainingGold1 + remainingGold5 * 5

  local playerBowl = getObjectFromGUID(OBJECTS.playerGoldBowls[color])

  local index = 0
  if amount >= 5 and remainingGold5 == 0 then
    if remainingGold1 ~= 0 then
      while remainingGold1 ~= 0 and amount ~= 0 do
        goldBag1.takeObject({
          position = getPositionForGoldGain({
            bowl = playerBowl,
            index = index
          })
        })
        amount = amount - 1
        remainingGold1 = remainingGold1 - 1
        index = index + 1
        waitFrames(2)
      end
      if onDone ~= nil then
        onDone()
      end
      return
    end
    print("Out of Gold. Can't gain any more.")
    if onDone ~= nil then
      onDone()
    end
    return
  end

  while amount >= 5 and remainingGold5 ~= 0 do
    goldBag5.takeObject({
      position = getPositionForGoldGain({
        bowl = playerBowl,
        index = index
      })
    })
    amount = amount - 5
    remainingGold5 = remainingGold5 - 1
    index = index + 1
  end

  if amount == 0 then
    if onDone ~= nil then
      onDone()
    end
    return
  end

  while remainingGold1 ~= 0 and amount ~= 0 do
    goldBag1.takeObject({
      position = getPositionForGoldGain({
        bowl = playerBowl,
        index = index
      })
    })
    amount = amount - 1
    remainingGold1 = remainingGold1 - 1
    index = index + 1
    waitFrames(2)
  end

  if amount ~= 0 then
    print("Out of Gold. Can't gain any more.")
  end
  if onDone ~= nil then
    onDone()
  end
end

function calculatePlayerGold(arguments)
  local color = arguments.color
  local bowlZone = getObjectFromGUID(OBJECTS.playerGoldBowlScriptingZones[color])
  local objects = bowlZone.getObjects()
  local sum = 0
  for index, object in ipairs(objects) do
    if object.name == "Custom Token" then
      if object.getName() == "Gold" then
        sum = sum + 1
      end
      if object.getName() == "Gold 5" then
        sum = sum + 5
      end
    end
  end
  return sum
end

function handleLoseGoldEffect(arguments)
  local color = arguments.color
  local amount = arguments.amount
  local onDone = arguments.onDone
  local bowlZone = getObjectFromGUID(OBJECTS.playerGoldBowlScriptingZones[color])
  local objects = bowlZone.getObjects()
  local playerGold = calculatePlayerGold({
    color = color
  })
  local gold5Bag = getObjectFromGUID(OBJECTS.goldBag5)
  local gold1Bag = getObjectFromGUID(OBJECTS.goldBag1)
  local gold5Coins = {}
  local gold5CoinsLost = 0
  local gold1Coins = {}
  local gold1CoinsLost = 0

  for index, object in ipairs(objects) do
    if object.name == "Custom_Token" then
      if object.getName() == "Gold" then
        table.insert(gold1Coins, object)
      end
      if object.getName() == "Gold 5" then
        table.insert(gold5Coins, object)
      end
    end
  end

  while amount >=5 and gold5CoinsLost ~= #gold5Coins do
    gold5Bag.putObject(gold5Coins[gold5CoinsLost + 1])
    amount = amount - 5
    gold5CoinsLost = gold5CoinsLost + 1
  end
  while amount > 0 and gold1CoinsLost ~= #gold1Coins do
    gold1Bag.putObject(gold1Coins[gold1CoinsLost + 1])
    amount = amount - 1
    gold1CoinsLost = gold1CoinsLost + 1
  end
  if onDone ~= nil then
    onDone()
  end
end

function handleGainCardEffect(arguments)
  local color = arguments.color
  local amount = arguments.amount or 1
  local character = GAME_DATA.players[color].character
  local onDone = arguments.onDone

  repeatPrepareAreaForOptionalGain(amount, {
    color = color,
    deck = OBJECTS.characterDecks[character].rewardsDeck,
    amount = 3,
    tag = nil,
    onDone = function()
      if onDone ~= nil then
        onDone(450)
      end
    end
  })
end

function handleGainRareCardEffect(arguments)
  local color = arguments.color
  local amount = arguments.amount or 1
  local character = GAME_DATA.players[color].character
  local onDone = arguments.onDone

  repeatPrepareAreaForOptionalGain(amount, {
    color = color,
    deck = OBJECTS.characterDecks[character].rareDeck,
    amount = 3,
    tag = nil,
    onDone = function()
      if onDone ~= nil then
        onDone(450)
      end
    end
  })
end

function handleLoseHpEffect(arguments)
  losePlayerHp(arguments.color, arguments.amount)
  if arguments.onDone ~= nil then
    arguments.onDone()
  end
end

function handleUpgradeCardEffect(arguments)
  local color = arguments.color
  local amount = arguments.amount
  local onDone = arguments.onDone

  prepareAreaForCardUpgrade({
    color = color,
    amount = amount,
    onDone = function(waitCount)
      if onDone ~= nil then
        onDone(waitCount or 500)
      end
    end
  })
end

function handleRemoveCardEffect(arguments)
  local color = arguments.color
  local amount = arguments.amount
  local onDone = arguments.onDone

  prepareAreaForCardRemove({
    color = color,
    amount = amount,
    onDone = function(waitCount)
      if onDone ~= nil then
        onDone(waitCount or 100)
      end
    end
  })
end

function getRelicsPosition(arguments)
  local color = arguments.color
  local character = GAME_DATA.players[color].character
  local characterBoard = getObjectFromGUID(OBJECTS.characterBoards[character])
  local boardBounds = characterBoard.getBounds()
  local boardPosition = characterBoard.getPosition()
  return {
    x = boardPosition.x - boardBounds.size.x / 2,
    y = boardPosition.y + boardBounds.size.y / 2,
    z = boardPosition.z + boardBounds.size.z / 2
  }
end

function handleGainRelicEffect(arguments)
  local color = arguments.color
  local amount = arguments.amount or 1
  local onDone = arguments.onDone

  if DEBUG_GAIN_RELIC_AMOUNT ~= nil then
    amount = DEBUG_GAIN_RELIC_AMOUNT
  end

  repeatPrepareAreaForOptionalGain(amount, {
    color = color,
    deck = OBJECTS.relicsDeck,
    amount = 1,
    tag = TAG_TYPES.RELIC,
    onDone = onDone
  })
end

function handleGainCurseEffect(arguments)
  local color = arguments.color
  local amount = arguments.amount or 1
  local onDone = arguments.onDone
  local curseDeck = getObjectFromGUID(OBJECTS.curseDeck)
  local deckPosition = getDecksPosition({
    color = color
  })

  curseDeck.shuffle()
  curseDeck.takeObject({
    position = deckPosition,
  })

  if onDone ~= nil then
    onDone(450)
  end
end

function handleGainColorlessCardEffect(arguments)
  local color = arguments.color
  local amount = arguments.amount or 1
  local onDone = arguments.onDone
  local drawDeckPosition = getDrawDeckPosition({
    color = color
  })

  repeatPrepareAreaForOptionalGain(amount, {
    color = color,
    deck = OBJECTS.colorlessDeck,
    amount = 3,
    tag = nil,
    onDone = function()
      if onDone ~= nil then
        onDone(450)
      end
    end
  })
end

function handleTransformCardEffect(arguments)
  local color = arguments.color
  local amount = arguments.amount
  local onDone = arguments.onDone

  prepareAreaForCardTransform({
    color = color,
    amount = amount,
    onDone = function(waitCount)
      if onDone ~= nil then
        onDone(waitCount or 100)
      end
    end
  })
end

function gainRandomCardFromDeck(arguments)
  local color = arguments.color
  local onDone = arguments.onDone
  local deck = arguments.deck
  local takeObject = deck.takeObject
  if deck.guid == OBJECTS.characterDecks[GAME_DATA.players[color].character].rewardsDeck then
    takeObject = takeRewardCard
  end
  function gainRandomCardFromDeckCoroutine()
    local amount = arguments.amount or 1
    local deckPosition = getDecksPosition({ color = color })
    local areaPosition = getPlayerAreaPosition({ color = color })
    local cardSizeX = deck.getBounds().size.x

    local middleIndex = math.floor(amount / 2)
    local isOdd = amount % 2 > 0
    local offsetStep = 3
    local index = 0
    local guids = {}
    local cardsDone = 0
    while index ~= amount do
      local offsetX = 0
      if isOdd then
        offsetX = (index - middleIndex) * offsetStep
      else
        local sign = -1
        local middle = math.floor(amount / 2) - 1
        if index >= middleIndex then
          sign = 1
          middle = middleIndex
        end
        local isMiddle = index == middleIndex or index == middleIndex - 1
        if isMiddle then
          offsetX = sign * (offsetStep / 2)
        else
          offsetX = (index - middle) * offsetStep + sign * (offsetStep / 2)
        end
      end
      takeObject({
        color = color,
        position = {
          x = areaPosition.x + offsetX,
          y = areaPosition.y,
          z = areaPosition.z
        },
        flip = true,
        callback_function = function(card, isGolden)
          cardsDone = cardsDone + 1
          table.insert(guids, card.guid)
          if cardsDone == amount then
            for _, guid in ipairs(guids) do
              gainCard({
                color = color,
                guid = guid
              })
            end

            if onDone ~= nil then
              onDone(400)
            end
          end
        end
      })
      index = index + 1
    end

    return 1
  end

  startLuaCoroutine(self, "gainRandomCardFromDeckCoroutine")
end

function handleGainRandomRareCardEffect(arguments)
  local color = arguments.color
  local character = GAME_DATA.players[color].character
  local rareDeck = getObjectFromGUID(OBJECTS.characterDecks[character].rareDeck)
  gainRandomCardFromDeck({
    color = color,
    deck = rareDeck,
    onDone = arguments.onDone,
    amount = arguments.amount
  })
end

function handleUpgradeRandomCardEffect(arguments)
  local color = arguments.color
  local amount = arguments.amount
  local onDone = arguments.onDone
  local areaPosition = getPlayerAreaPosition({
    color = color
  })
  local deck = getDeck({ color = color })
  deck.shuffle()

  prepareAreaForCardUpgrade({
    hideButton = true,
    color = color,
    amount = amount,
    onDone = function(waitCount)
      if onDone ~= nil then
        onDone(450)
      end
    end
  })

  local cards = deck.getObjects()
  local okGuids = {}
  for index, card in ipairs(cards) do
    local isCurse = false
    for _, tag in ipairs(card.tags) do
      if tag == "Curse" then
        isCurse = true
      end
    end
    if not isCurse and not string.find(card.name, "+") then
      table.insert(okGuids, card.guid)
    end
  end
  local index = 0
  while index ~= amount and index ~= #okGuids do
    deck.takeObject({
      position = {
        x = areaPosition.x,
        y = areaPosition.y,
        z = areaPosition.z
      },
      guid = okGuids[index + 1],
      flip = true
    })
    index = index + 1
  end

  waitFrames(450)

  Global.call("handleUpgradeCardClick", {
    color = color,
    colorClicks = color
  })
end

function handleGainRandomCardEffect(arguments)
  local color = arguments.color
  local character = GAME_DATA.players[color].character
  local rewardsDeck = getObjectFromGUID(OBJECTS.characterDecks[character].rewardsDeck)
  gainRandomCardFromDeck({
    color = color,
    deck = rewardsDeck,
    onDone = arguments.onDone,
    amount = arguments.amount
  })
end

function handleGainRandomColorlessCardEffect(arguments)
  local color = arguments.color
  local colorlessDeck = getObjectFromGUID(OBJECTS.colorlessDeck)
  gainRandomCardFromDeck({
    color = color,
    deck = colorlessDeck,
    onDone = arguments.onDone,
    amount = arguments.amount
  })
end

function getPotionOutOfCombatPosition(arguments)
  local color = arguments.color
  local deckPosition = getDecksPosition({
    color = color
  })
  return {
    x = deckPosition.x,
    y = deckPosition.y,
    z = deckPosition.z - 4
  }
end

function getPotionCombatPosition(arguments)
  local color = arguments.color
  local index = arguments.index
  local board = getObjectFromGUID(OBJECTS.characterBoards[GAME_DATA.players[color].character])
  local boardPosition = board.getPosition()
  local boardBounds = board.getBounds()
  return {
    x = boardPosition.x - boardBounds.size.x / 2 + 0.9 + 2 * index,
    y = boardPosition.y,
    z = boardPosition.z + boardBounds.size.z / 2 + 1.5
  }
end

function getPlayerPotions(arguments)
  local color = arguments.color
  local isCombat = GAME_DATA.combat.inProgress
  local zone = nil
  if isCombat then
    zone = getObjectFromGUID(OBJECTS.playerCombatPotionScriptingZones[color])
  else
    zone = getObjectFromGUID(OBJECTS.playerOutOfCombatPotionScriptingZones[color])
  end
  local objects = zone.getObjects()
  local potions = {}
  if objects[1] ~= nil and objects[1].name == "Deck" then
    objects = objects[1].getObjects()
  end
  for index, object in ipairs(objects) do
    local tags = nil
    if object.getTags ~= nil then
      tags = object.getTags()
    else
      tags = object.tags
    end
    if tags ~= nil then
      for _, tag in ipairs(tags) do
        if tag == "Potion" then
          local name = object.name
          if object.getName ~= nil then
            name = object.getName()
          end
          table.insert(potions, name)
        end
      end
    end
  end
  return potions
end

function movePlayerPotions(arguments)
  local color = arguments.color
  local toCombat = arguments.toCombat

  local zone = nil
  if toCombat then
    zone = getObjectFromGUID(OBJECTS.playerOutOfCombatPotionScriptingZones[color])
  else
    zone = getObjectFromGUID(OBJECTS.playerCombatPotionScriptingZones[color])
  end
  local objects = zone.getObjects()
  if objects[1] ~= nil and objects[1].name == "Deck" then
    local deck = getObjectFromGUID(objects[1].guid)
    local cards = deck.getObjects()
    local cardsCount = #cards
    local index = 0
    while index ~= cardsCount - 1 do
      deck.takeObject({
        flip = false,
        guid = cards[index + 1].guid,
        position = getPotionCombatPosition({
          color = color,
          index = index
        })
      })
      index = index + 1
    end
    local remainingCard = getObjectFromGUID(cards[cardsCount].guid)
    remainingCard.setPositionSmooth(
      getPotionCombatPosition({
        color = color,
        index = cardsCount - 1
      })
    )
  elseif objects[1] ~= nil then
    local card = getObjectFromGUID(objects[1].guid)
    card.setPositionSmooth(
      getPotionCombatPosition({
        color = color,
        index = 0
      })
    )
  end
end

function handleGainRandomPotionEffect(arguments)
  local color = arguments.color
  local amount = arguments.amount or 1
  local onDone = arguments.onDone
  local potionDeck = getObjectFromGUID(OBJECTS.potionDeck)
  local isCombat = GAME_DATA.combat.inProgress
  local currentPotions = getPlayerPotions({
    color = color
  })
  local currentPotionsCount = #currentPotions
  local realAmount = math.min(3 - currentPotionsCount, amount)

  if realAmount <= 0 then
    if onDone ~= nil then
      onDone()
    end
  end

  if isCombat then
    local combatPosition = getPotionCombatPosition({
      color = color
    })
    potionDeck.takeObject({
      position = combatPosition,
    })
  else
    local outOfCombatPosition = getPotionOutOfCombatPosition({
      color = color
    })
    local index = 0
    local done = 0
    while index < realAmount do
      potionDeck.takeObject({
        flip = true,
        position = {
          x = outOfCombatPosition.x,
          y = outOfCombatPosition.y + 1 * index,
          z = outOfCombatPosition.z
        },
        callback_function = function(card)
          done = done + 1
          if done == realAmount and onDone ~= nil then
            onDone()
          end
        end
      })
      index = index + 1
    end
  end
end

function handleEffect(arguments)
  function handleEffectCoroutine()
    local effect = arguments.effect
    local target = arguments.target
    local onDone = arguments.onDone

    if target.type == TARGET_TYPES.PLAYER then
      if target.payload == nil or target.payload.color == nil then
        return 1
      end

      local color = target.payload.color
      local amount = 1
      if effect.payload ~= nil and effect.payload.amount ~= nil then
        amount = effect.payload.amount
      end

      if effect.type == EFFECT_TYPES.GAIN_GOLD then
        handleGainGoldEffect({ amount = amount, color = color, onDone = onDone })
        return 1
      end

      if effect.type == EFFECT_TYPES.LOSE_GOLD then
        handleLoseGoldEffect({ amount = amount, color = color, onDone = onDone })
        return 1
      end

      if effect.type == EFFECT_TYPES.GAIN_CARD then
        handleGainCardEffect({ amount = amount, color = color, onDone = onDone })
        return 1
      end

      if effect.type == EFFECT_TYPES.GAIN_RARE_CARD then
        handleGainRareCardEffect({ amount = amount, color = color, onDone = onDone })
        return 1
      end

      if effect.type == EFFECT_TYPES.GAIN_RANDOM_RARE_CARD then
        handleGainRandomRareCardEffect({ amount = amount, color = color, onDone = onDone })
        return 1
      end

      if effect.type == EFFECT_TYPES.GAIN_RANDOM_COLORLESS_CARD then
        handleGainRandomColorlessCardEffect({ amount = amount, color = color, onDone = onDone })
        return 1
      end

      if effect.type == EFFECT_TYPES.GAIN_RANDOM_CARD then
        handleGainRandomCardEffect({ amount = amount, color = color, onDone = onDone })
        return 1
      end

      if effect.type == EFFECT_TYPES.LOSE_HP then
        handleLoseHpEffect({
          color = color,
          amount = amount,
          onDone = onDone
        })
        return 1
      end

      if effect.type == EFFECT_TYPES.UPGRADE_CARD then
        handleUpgradeCardEffect({
          color = color,
          amount = amount,
          onDone = onDone
        })
        return 1
      end

      if effect.type == EFFECT_TYPES.UPGRADE_RANDOM_CARD then
        handleUpgradeRandomCardEffect({
          color = color,
          amount = amount,
          onDone = onDone
        })
        return 1
      end

      if effect.type == EFFECT_TYPES.REMOVE_CARD then
        handleRemoveCardEffect({
          color = color,
          amount = amount,
          onDone = onDone
        })
        return 1
      end

      if effect.type == EFFECT_TYPES.TRANSFORM_CARD then
        handleTransformCardEffect({
          color = color,
          amount = amount,
          onDone = onDone
        })
        return 1
      end

      if effect.type == EFFECT_TYPES.GAIN_RELIC then
        handleGainRelicEffect({
          color = color,
          amount = amount,
          onDone = onDone
        })
        return 1
      end

      if effect.type == EFFECT_TYPES.GAIN_CURSE then
        handleGainCurseEffect({
          color = color,
          amount = amount,
          onDone = onDone
        })
      end

      if effect.type == EFFECT_TYPES.GAIN_COLORLESS_CARD then
        handleGainColorlessCardEffect({
          color = color,
          amount = amount,
          onDone = onDone
        })
        return 1
      end

      if effect.type == EFFECT_TYPES.GAIN_RANDOM_POTION then
        handleGainRandomPotionEffect({
          color = color,
          amount = amount,
          onDone = onDone
        })
        return 1
      end
    end

    return 1
  end

  startLuaCoroutine(self, "handleEffectCoroutine")
end

function onLoad()
  for index, color in ipairs({ "Red", "Green", "Blue", "Pink" }) do
    local handZone = getObjectFromGUID(OBJECTS.playerHands[color])
    handZone.setScale({
      x = 15.3268948,
      y = 11.8970528,
      z = 6.35014534
    })
    handZone.setPosition({
      x = -60 + 24 * index,
      y = 3.29337835,
      z = -43.42515,
    })
    handZone.setRotation({
      x = 0,
      y = 0,
      z = 0
    })
  end

  local boot = getObjectFromGUID(OBJECTS.boot)
  boot.use_snap_points = true
end

function getAssignedCharacterToPlayer(arguments)
  local color = arguments.color
  return GAME_DATA.players[color].character
end

function canAssignCharacterToPlayer(arguments)
  local character = arguments.character
  local color = arguments.color
  for color, data in pairs(GAME_DATA.players) do
    if data.character ~= nil and data.character == character then
      return false
    end
  end
  return true
end

function assignCharacterToPlayer(arguments)
  local character = arguments.character
  local color = arguments.color
  GAME_DATA.players[color].character = character
end

function canUnsignCharacterFromPlayer(arguments)
  local character = arguments.character
  local color = arguments.color

  return GAME_DATA.players[color].character ~= nil and
    GAME_DATA.players[color].character == character
end

function unsignCharacterFromPlayer(arguments)
  local color = arguments.color

  GAME_DATA.players[color].character = nil
end

function setupPlayerDecks(arguments)
  local color = arguments.color

  local handZone = getObjectFromGUID(OBJECTS.playerHands[color])
  local handZonePosition = handZone.getPosition()
  local character = GAME_DATA.players[color].character
  local characterBoard = getObjectFromGUID(OBJECTS.characterBoards[character])
  local characterBag = getObjectFromGUID(OBJECTS.characterBags[character])
  local boardBounds = characterBoard.getBoundsNormalized()

  local decksPosition = getDecksPosition({
    color = color
  })
  local starterDeck = characterBag.takeObject({
    position = decksPosition,
    rotation = {
      x = 0,
      y = 180,
      z = 180
    }
  })
  OBJECTS.characterDecks[character].starterDeck = starterDeck.guid

  spawnObject({
    type = "ScriptingTrigger",
    position = {
      x = decksPosition.x,
      y = decksPosition.y - 2.2,
      z = decksPosition.z
    },
    scale = starterDeck.getBounds().size,
    callback_function = function(zone)
      OBJECTS.playerDeckScriptingZones[color] = zone.guid
      OBJECTS.deckScriptingZoneToPlayer[zone.guid] = color
    end
  })

  local rewardsDeck = characterBag.takeObject({
    position = {
      x = decksPosition.x,
      y = decksPosition.y,
      z = decksPosition.z + 4
    },
    rotation = {
      x = 0,
      y = 180,
      z = 180
    }
  })
  rewardsDeck.interactable = true
  rewardsDeck.shuffle()
  OBJECTS.characterDecks[character].rewardsDeck = rewardsDeck.guid

  local rareDeck = characterBag.takeObject({
    position = {
      x = decksPosition.x,
      y = decksPosition.y,
      z = decksPosition.z + 8
    },
    rotation = {
      x = 0,
      y = 180,
      z = 180
    }
  })
  rareDeck.interactable = false
  rareDeck.shuffle()
  OBJECTS.characterDecks[character].rareDeck = rareDeck.guid
end

function getMapBossPosition(arguments)
  local mapObject = arguments.mapObject
  local startPosition = getMapStartPosition({
    mapObject = mapObject
  })
  return {
    x = startPosition.x + 0.25,
    y = startPosition.y,
    z = startPosition.z + 24.5
  }
end

function getMapCharacterPositions(arguments)
  local mapObject = arguments.mapObject
  local bounds = mapObject.getBounds()
  local position = mapObject.getPosition()
  local scale = mapObject.getScale()

  local positions = {}
  local positionsDone = 0
  while positionsDone ~= 4 do
    table.insert(positions, {
      x = position.x + bounds.size.x / 2 - 0.1 * scale.x,
      y = position.y,
      z = position.z - bounds.size.z / 2 + (0.2 + positionsDone * 0.435) * scale.z,
    })
    positionsDone = positionsDone + 1
  end
  return positions
end

function getMapCharacterSnapPoints(arguments)
  local mapObject = arguments.mapObject
  local characterPositions = getMapCharacterPositions({
    mapObject = mapObject
  })
  local snapPoints = {}
  for index, position in ipairs(characterPositions) do
    table.insert(snapPoints, {
      position = mapObject.positionToLocal(position)
    })
  end
  return snapPoints
end

function setupPlayerPlayZone(arguments)
  local color = arguments.color
  local playerBoard = getObjectFromGUID(OBJECTS.characterBoards[GAME_DATA.players[color].character])
  local playerBoardPosition = playerBoard.getPosition()
  local playerBoardBounds = playerBoard.getBounds()
  spawnObject({
    type = "ScriptingTrigger",
    position = {
      x = playerBoardPosition.x,
      y = playerBoardPosition.y,
      z = playerBoardPosition.z + playerBoardBounds.size.z / 2 + 6
    },
    scale = { 12, 0.7, 10 },
    callback_function = function(zone)
      local bounds = zone.getBounds()
      local position = zone.getPosition()

      playerBoard.UI.setAttribute("main", "active", "true")
    end
  })
end

function handleCombatCardClick()

end

function ishallowCopy(table)
  local copy = {}
  for index, element in ipairs(table) do
    copy[index] = element
  end
  return copy
end

function prepareEnemyAfterSpawn(arguments)
  local card = getObjectFromGUID(arguments.cardGuid)
  card.scale(1.4)
  card.interactable = false
  local cardBounds = card.getBounds()
  local cardPosition = card.getPosition()
  spawnObject({
    type = "ScriptingTrigger",
    position = cardPosition,
    scale = { cardBounds.size.x, cardBounds.size.y + 0.3, cardBounds.size.z },
    callback_function = function(zone)
      OBJECTS.combat.zoneToEnemy[zone.guid] = card.guid
      OBJECTS.combat.enemyToZone[card.guid] = zone.guid
    end
  })

  addHpMeterForEnemy({
    guid = card.guid
  })
  -- spawnObject({
  --   type = "3DText",
  --   position = {
  --     x = cardPosition.x + 0.2,
  --     y = cardPosition.y,
  --     z = cardPosition.z - 4
  --   },
  --   scale = {0.2, 0.2, 0.2},
  --   callback_function = function(textObject)
  --     textObject.setValue(2)
  --     textObject.setFontSize(15)
  --     textObject.setFontColor("#ff4949")
  --   end
  -- })
end

function afterEnemySpawns(arguments)
  local cardGuid = arguments.cardGuid
  local row = arguments.row
  local index = arguments.index
  prepareEnemyAfterSpawn({
    cardGuid = cardGuid
  })
  local act = GAME_DATA.act
  local card = getObjectFromGUID(cardGuid)
  local name = card.getName()
  local stats = getEnemyStats({
    act = act,
    name = name,
    tag = card.getTags()[1]
  })
  GAME_DATA.combat.enemies[cardGuid] = {
    guid = cardGuid,
    name = name,
    row = row,
    index = index,
    hp = stats.hp,
    block = 0,
    effects = {}
  }
end

function handleSummon(onDone)
  local act = GAME_DATA.act
  local summonQueue = GAME_DATA.combat.summonQueue
  local bagObject = getObjectFromGUID(OBJECTS.actDecksBag[act].base)
  local bagPosition = bagObject.getPosition()
  local summonDeck = bagObject.takeObject({
    index = 1,
    position = {
      x = bagPosition.x,
      y = bagPosition.y,
      z = bagPosition.z - 4,
    },
    callback_function = function(deck)
      local deckCards = deck.getObjects()
      local nameGuidMap = {}
      for index, card in ipairs(deckCards) do
        if nameGuidMap[card.name] == nil then
          nameGuidMap[card.name] = {}
        end
        table.insert(nameGuidMap[card.name], card.guid)
      end

      for index, data in ipairs(summonQueue) do
        local guid = data.cardGuid
        local ownerIndex = data.index
        local ownerRow = data.row
        local card = getObjectFromGUID(guid)
        local cardPosition = card.getPosition()
        local cardName = card.getName()
        local cardStats = getEnemyStats({
          act = act,
          tag = card.getTags()[1],
          name = cardName
        })
        local summons = cardStats.summons
        for index, summon in ipairs(summons) do
          local summoned = 0
          local variants = ishallowCopy(summon.variants)
          while summoned ~= summon.amount do
            local randomVariant = variants[math.random(#variants)]
            local guidTable = nameGuidMap[randomVariant]
            local randomN = math.random(#guidTable)
            local randomGuid = guidTable[math.random(#guidTable)]
            table.remove(guidTable, randomN)
            deck.takeObject({
              guid = randomGuid,
              position = {
                x = cardPosition.x + 5.8,
                y = cardPosition.y,
                z = cardPosition.z,
              },
              rotation = {
                x = 180,
                y = 0,
                z = 180
              },
              callback_function = function(card)
                afterEnemySpawns({
                  cardGuid = card.guid,
                  row = ownerRow,
                  index = ownerIndex + index - 1 + summoned
                })
              end
            })
            summoned = summoned + 1
          end
        end
      end

      GAME_DATA.combat.summonQueue = {}
      onDone()
    end
  })
end

function queueSummonFor(arguments)
  local cardGuid = arguments.cardGuid
  local row = arguments.row
  local index = arguments.index
  table.insert(GAME_DATA.combat.summonQueue, {
    cardGuid = cardGuid,
    row = row,
    index = index
  })
end

function setTurn(arguments)
  local turn = arguments.turn

  GAME_DATA.combat.turn = turn
end

function setTurnCount(arguments)
  local turnCount = arguments.turnCount

  GAME_DATA.combat.turnCount = turnCount
end

function isCombatDone(arguments)
  local combat = arguments.combat
  local players = arguments.players
end

function discardHand(arguments)
  function discardHandCoroutine()
    local color = arguments.color

    local playerDiscardZone = getObjectFromGUID(OBJECTS.playerDiscardScriptingZones[color])
    local discardPosition = playerDiscardZone.getPosition()
    local handObjects = getObjectFromGUID(OBJECTS.playerHands[color]).getObjects()
    for index, object in ipairs(handObjects) do
      object.use_hands = false
    end
    for index, object in ipairs(handObjects) do
      object.setPositionSmooth({
        x = discardPosition.x,
        y = discardPosition.y + 5 + 0.3 * index,
        z = discardPosition.z
      })
      local rotation = object.getRotation()
      if rotation.z ~= 180 then
        object.flip()
      end
    end
    waitFrames(100)
    for index, object in ipairs(handObjects) do
      object.use_hands = true
    end
    return 1
  end
  startLuaCoroutine(self, "discardHandCoroutine")
end

function drawCards(arguments)
  local color = arguments.color
  local amount = arguments.amount

  local playerDrawZone = getObjectFromGUID(OBJECTS.playerDrawScriptingZones[color])
  local objectsInDraw = playerDrawZone.getObjects()
  for _, object in ipairs(objectsInDraw) do
    if object.name == "Deck" then
      object.deal(5, color)
    end
    if object.name == "Card" then
      object.deal(1, color)
    end
  end
end

function canPlayerPlayCard(arguments)
  local color = arguments.color
  local card = arguments.card
  local cardName = card.getName()
  local character = GAME_DATA.players[color].character
  local cardData = CARDS_DATA[character][cardName]
  local energy = getEnergyForPlayer(color)

  if GAME_DATA.combat.playingCard ~= nil then
    return false
  end

  if cardData.cost > energy then
    return false
  end

  return true
end

function spendEnergy(arguments)
  local color = arguments.color
  local amount = arguments.amount

  local oldEnergy = getEnergyForPlayer(color)
  local newEnergy = oldEnergy - amount
  setEnergyForPlayer(color, newEnergy)

  local logString = color..":\nCurrent energy: "..oldEnergy.."."
  logString = logString.."\nSpend "..amount.." energy."
  logString = logString.."\nNew energy: "..newEnergy.."."
  myLog(logString)
end

function resolvePlayingCardEffects()
  local playingCard = GAME_DATA.combat.playingCard
  local color = playingCard.color
  local cardName = playingCard.cardName
  local cardGuid = playingCard.cardGuid
  local character = GAME_DATA.players[color].character
  local cardData = CARDS_DATA[character][cardName]
  local target = playingCard.target

  spendEnergy({
    color = color,
    amount = cardData.cost
  })
  local resolverName = "resolveCard"..character..string.gsub(cardName, "+", "Plus")
  Global.call(resolverName, {
    color = color,
    cardGuid = cardGuid,
    target = target,
  })
end

function onPlayingCardTargetChosen(arguments)
  local targetType = arguments.type
  local targetCardGuid = arguments.cardGuid

  GAME_DATA.combat.playingCard.target = {
    type = targetType,
    guid = targetCardGuid,
  }

  resolvePlayingCardEffects()
end

function onPlayingRelicTargetChosen(arguments)
  local targetType = arguments.type
  local targetCardGuid = arguments.cardGuid

  GAME_DATA.combat.playingTargetRelic.target = {
    type = targetType,
    guid = targetCardGuid,
  }
  local relicObject = getObjectFromGUID(GAME_DATA.combat.playingTargetRelic.guid)
  local relicName = relicObject.getName()
  local value = GAME_DATA.combat.dieResult
  local color = GAME_DATA.combat.playingTargetRelic.color

  RELICS_DATA[relicName].values[tostring(value)].handler({
    color = color,
    target = GAME_DATA.combat.playingTargetRelic.target,
    onDone = function()
      GAME_DATA.combat.playingTargetRelic = nil
      GAME_DATA.combat.canTargetRelics[relicObject.guid] = nil
      moveRelicBackIntoGrid({
        color = color,
        guid = relicObject.guid,
        onDone = function()
          relicObject.flip()
        end
      })
    end
  })
end

function startPlayCard(arguments)
  local color = arguments.color
  local card = arguments.card
  local cardName = card.getName()

  GAME_DATA.combat.playingCard = {
    color = color,
    cardName = cardName,
    cardGuid = card.guid,
  }
end

function onPlayerDropsCard(arguments)
  function onPlayerDropsCardCoroutine()
    local color = arguments.color
    local card = arguments.card

    if canPlayerPlayCard({
      color = color,
      card = card
    }) then
      startPlayCard({
        color = color,
        card = card
      })

      waitFrames(120)

      if GAME_DATA.combat.playingCard ~= nil and GAME_DATA.combat.playingCard.target == nil then
        card.deal(1, color)
        GAME_DATA.combat.playingCard = nil
      end
    else
      card.deal(1, color)
    end

    return 1
  end

  startLuaCoroutine(self, "onPlayerDropsCardCoroutine")
end

function getRelicsGridPositionForExistingRelic(arguments)
  local guid = arguments.guid
  local color = arguments.color
  local basePosition = getRelicsGridPosition({
    color = color
  })

  local index = -1
  for j, relic in ipairs(GAME_DATA.players[color].relics) do
    if relic.guid == guid then
      index = j
      break
    end
  end
  if index == -1 then
    return basePosition
  end

  index = index - 1
  local rowIndex = math.floor(index / 8)
  local columnIndex = index % 8
  return {
    x = basePosition.x + columnIndex * 3,
    y = basePosition.y,
    z = basePosition.z - rowIndex * 3.3
  }
end

function moveRelicBackIntoGrid(arguments)
  function moveRelicBackIntoGridCoroutine()
    local color = arguments.color
    local guid = arguments.guid
    local onDone = arguments.onDone
    local preDelay = arguments.preDelay

    if preDelay ~= nil then
      waitFrames(preDelay)
    end
    local position = getRelicsGridPositionForExistingRelic({
      color = color,
      guid = guid
    })
    local object = getObjectFromGUID(guid)
    object.setPositionSmooth(position)
    if onDone == nil then
      return 1
    end

    while object.isSmoothMoving() do
      waitFrames(50)
    end
    onDone()
    return 1
  end
  startLuaCoroutine(self, "moveRelicBackIntoGridCoroutine")
end

function onPlayerDropsTargetRelic(arguments)
  function onPlayerDropsTargetRelicCoroutine()
    local color = arguments.color
    local relic = arguments.relic

    GAME_DATA.combat.playingTargetRelic = {
      color = color,
      guid = relic.guid,
    }

    waitFrames(120)

    if GAME_DATA.combat.playingTargetRelic ~= nil and GAME_DATA.combat.playingTargetRelic.target == nil then
      moveRelicBackIntoGrid({
        color = color,
        guid = relic.guid
      })
    end

    return 1
  end

  startLuaCoroutine(self, "onPlayerDropsTargetRelicCoroutine")
end

function setCombatPhase(arguments)
  local phase = arguments.phase
  GAME_DATA.combat.phase = phase
end

function startCombatPlayPhase()
  setCombatPhase({
    phase = TURN_PHASE_TYPES.PLAY
  })
  local colors = getPlayingColors()
  for _, color in ipairs(colors) do
    local bowlPosition = getObjectFromGUID(OBJECTS.playerGoldBowls[color]).getPosition()
    createPlayerEndOfTurnButton({
      color = color,
      position = {
        x = bowlPosition.x,
        y = bowlPosition.y,
        z = bowlPosition.z + 7.8
      }
    })
  end
end

function handleEndOfTurnAbilities(callback)
  callback()
end

function startCombatEndOfTurnPhase()
  handleEndOfTurnAbilities(function()
    local colors = getPlayingColors()
    for _, color in ipairs(colors) do
      discardHand({
        color = color
      })
    end
  end)
end

function moveDiceToInitialPosition()
  local dice = getObjectFromGUID(OBJECTS.dice)
  dice.setPositionSmooth({
    x = 15,
    y = 3,
    z = 5
  })
end

function rollDice(callback)
  function rollDiceCoroutine()
    local dice = getObjectFromGUID(OBJECTS.dice)
    while dice.isSmoothMoving() do
      waitFrames(50)
    end
    if DEBUG_DICE_VALUE ~= nil then
      dice.setValue(DEBUG_DICE_VALUE)
    else
      dice.roll()
    end
    while not dice.resting do
      waitFrames(50)
    end
    local value = dice.getValue()
    GAME_DATA.combat.dieResult = value
    callback()
    return 1
  end
  startLuaCoroutine(self, "rollDiceCoroutine")
end

function onObjectRandomize(object)
  myLog(object.name)
  if object.name ~= "Dice" then
    return
  end

end

function handleStartOfCombatAbilities(callback)
  callback()
end

function handleStartOfTurnAbilities(callback)
  callback()
end

function tryToPlayRelic(arguments)
  local color = arguments.color
  local guid = arguments.guid
  local value = arguments.value
  local onDone = arguments.onDone
  local relicObject = getObjectFromGUID(guid)
  local name = relicObject.getName()
  relicObject.flip()
  local needsTarget = RELICS_DATA[name].values[value].needsTarget
  if not needsTarget then
    RELICS_DATA[name].values[value].handler({
      color = color,
      onDone = onDone
    })
  else
    GAME_DATA.combat.canTargetRelics[guid] = {
      color = color,
    }
    onDone()
  end
end

function handleDieResultAbilities(callback)
  local playingColors = getPlayingColors()
  local dieValue = tostring(GAME_DATA.combat.dieResult)
  local dieRelics = ABILITY_TRIGGER_TO_RELICS[ABILITY_TRIGGER_TYPES.DIE_RESULT]

  local relicsToDone = 0
  local done = 0
  for _, relicName in ipairs(dieRelics) do
    for _, color in ipairs(playingColors) do
      if GAME_DATA.players[color].relicsMap[relicName] then
        local guid = nil
        for _, relicData in ipairs(GAME_DATA.players[color].relics) do
          if relicData.name == relicName then
            guid = relicData.guid
            break
          end
        end
        if guid == nil or RELICS_DATA[relicName].values[dieValue] == nil then
          break
        end
        relicsToDone = relicsToDone + 1
        tryToPlayRelic({
          color = color,
          guid = guid,
          value = dieValue,
          onDone = function()
            done = done + 1
            if relicsToDone == done then
              callback()
            end
          end
        })
      end
    end
  end

  if relicsToDone == 0 then
    callback()
  end
end

function startCombatStartTurnPhase(onDone)
  setCombatPhase({
    phase = TURN_PHASE_TYPES.START_OF_TURN
  })
  local colors = getPlayingColors()
  local _players = Player.getPlayers()
  local players = {}
  for index, color in ipairs(colors) do
    for _, player in ipairs(_players) do
      if player.color == color then
        players[color] = player
      end
    end
  end

  for index, color in ipairs(colors) do
    local playerObject = players[color]
    setEnergyForPlayer(color, 3)
    setBlockForPlayer(color, 0)
    drawCards({
      color = color,
      amount = 5
    })
  end

  rollDice(function()
    local value = GAME_DATA.combat.dieResult
    broadcastToAll("Dice is rolled, value is "..value)
    if value == 1 then
      print(
        "+-------+\n"..
        "|            |\n"..
        "|     +     |\n"..
        "|            |\n"..
        "+-------+"
      )
    end
    if value == 2 then
      print(
        "+-------+\n"..
        "|        +  |\n"..
        "|            |\n"..
        "|  +        |\n"..
        "+-------+"
      )
    end
    if value == 3 then
      print(
        "+-------+\n"..
        "|        +  |\n"..
        "|     +     |\n"..
        "|  +        |\n"..
        "+-------+"
      )
    end
    if value == 4 then
      print(
        "+--------+\n"..
        "|  +     +  |\n"..
        "|             |\n"..
        "|  +     +  |\n"..
        "+--------+"
      )
    end
    if value == 5 then
      print(
        "+--------+\n"..
        "|  +     +  |\n"..
        "|     +      |\n"..
        "|  +     +  |\n"..
        "+--------+"
      )
    end
    if value == 6 then
      print(
        "+--------+\n"..
        "|  +     +  |\n"..
        "|  +     +  |\n"..
        "|  +     +  |\n"..
        "+--------+"
      )
    end

    function dieAbilitiesCallback()
      handleDieResultAbilities(onDone)
    end

    function startOfTurnCallback()
      handleStartOfTurnAbilities(dieAbilitiesCallback)
    end

    if GAME_DATA.combat.turnCount == 1 then
      handleStartOfCombatAbilities(startOfTurnCallback)
    else
      startOfTurnCallback()
    end
  end)
end

function startCombatPlayersTurn()
  setTurn({
    turn = TURN_TYPES.PLAYERS
  })
  startCombatStartTurnPhase(function()
    startCombatPlayPhase()
  end)
end

function startCombatLoop()
  startCombatPlayersTurn()
end

function startCombat()
  setTurnCount({
    turnCount = 1
  })
  moveDiceToInitialPosition()
  local colors = getPlayingColors()
  for _, color in ipairs(colors) do
    local relics = GAME_DATA.players[color].relics
    for _, relic in ipairs(relics) do
      local guid = relic.guid
      local relicObject = getObjectFromGUID(guid)
      local rotation = relicObject.getRotation()
      local isFaceUp = rotation.z ~= 180
      if isFaceUp then
        relicObject.flip()
      end
    end
  end
  startCombatLoop()
end

function getDeck(arguments)
  local color = arguments.color
  local deckZone = getObjectFromGUID(OBJECTS.playerDeckScriptingZones[color])
  local deckGuid = deckZone.getObjects()[1].guid
  return getObjectFromGUID(deckGuid)
end

function startEncounter(arguments)
  function startEncounterCoroutine()
    local bag = arguments.bag
    local map = arguments.map
    local act = arguments.act
    local mapPosition = map.getPosition()
    local mapBounds = map.getBounds()

    GAME_DATA.combat.inProgress = true
    local playingColors = getPlayingColors()
    for index, color in ipairs(playingColors) do
      local deck = getDeck({ color = color })
      local drawDeckPosition = getDrawDeckPosition({
        color = color
      })
      deck.setPositionSmooth(drawDeckPosition)
      deck.shuffle()
    end

    bag.takeObject({
      index = 0,
      rotation = {
        x = 0,
        y = 180,
        z = 180
      },
      position = {
        x = mapPosition.x + mapBounds.size.x / 2 + 2,
        y = mapPosition.y + mapBounds.size.y,
        z = mapPosition.z + mapBounds.size.z / 2 - 1.4
      },
      callback_function = function(deck)
        deck.shuffle()
        local characterPositions = getMapCharacterPositions({
          mapObject = map
        })
        local playingColors = getPlayingColors()
        for index, color in ipairs(playingColors) do
          deck.takeObject({
            flip = true,
            position = {
              x = characterPositions[index].x + 4,
              y = characterPositions[index].y,
              z = characterPositions[index].z + 0.7
            },
            callback_function = function(card)
              local cardName = card.getName()
              local cardTag = card.getTags()[1]
              local cardStats = getEnemyStats({
                act = act,
                tag = cardTag,
                name = cardName
              })
              GAME_DATA.combat.encountersSetup = GAME_DATA.combat.encountersSetup + 1

              if cardStats.summons ~= nil and #cardStats.summons > 0 then
                queueSummonFor({
                  act = act,
                  cardGuid = card.guid,
                  row = index,
                  index = 1
                })
              end

              afterEnemySpawns({
                cardGuid = card.guid,
                row = index,
                index = 1,
              })

              if GAME_DATA.combat.encountersSetup == #getPlayingColors() then
                handleSummon(startCombat)
              end
            end
          })
        end
        bag.putObject(deck)
      end
    })

    waitFrames(100)
    for _, color in ipairs(playingColors) do
      movePlayerPotions({
        color = color,
        toCombat = true
      })
    end

    return 1
  end
  startLuaCoroutine(self, "startEncounterCoroutine")
end

function startFirstEncounter(arguments)
  local waitCount = arguments.waitCount or 100
  function startFirstEncounterCoroutine()
    waitFrames(waitCount)
    local map = getObjectFromGUID(OBJECTS.actMaps[1])
    startEncounter({
      bag = getObjectFromGUID(OBJECTS.firstEncounterBag),
      map = map,
      act = "First Encounter"
    })
    return 1
  end
  startLuaCoroutine(self, "startFirstEncounterCoroutine")
end

function setupPlayerBoardZone(arguments)
  local color = arguments.color
  local playerBoard = getObjectFromGUID(OBJECTS.characterBoards[GAME_DATA.players[color].character])
  local playerBoardPosition = playerBoard.getPosition()
  local playerBoardBounds = playerBoard.getBounds()
  spawnObject({
    type = "ScriptingTrigger",
    position = {
      x = playerBoardPosition.x,
      y = playerBoardPosition.y + 0.1,
      z = playerBoardPosition.z,
    },
    scale = playerBoardBounds.size,
    callback_function = function(zone)
      OBJECTS.playerBoardScriptingZones[color] = zone.guid
    end
  })
end

function setupPlayerPotionZone(arguments)
  local color = arguments.color
  local dropOutOfCombatPosition = getPotionOutOfCombatPosition({
    color = color
  })
  local outOfCombatPosition = {
    x = dropOutOfCombatPosition.x,
    y = dropOutOfCombatPosition.y - 2.3,
    z = dropOutOfCombatPosition.z
  }
  local tableObject = Tables.getTableObject()
  local snapPoints = tableObject.getSnapPoints()
  table.insert(snapPoints, {
    position = tableObject.positionToLocal(outOfCombatPosition)
  })
  for _, index in ipairs({0, 1, 2}) do
    table.insert(snapPoints, {
      position = tableObject.positionToLocal(getPotionCombatPosition({
        color = color,
        index = index
      }))
    })
  end
  tableObject.setSnapPoints(snapPoints)

  spawnObject({
    type = "ScriptingTrigger",
    position = getPotionCombatPosition({
      color = color,
      index = 1
    }),
    scale = {
      x = 6,
      y = 0.3,
      z = 2.7
    },
    callback_function = function(zone)
      OBJECTS.playerCombatPotionScriptingZones[color] = zone.guid
      OBJECTS.combatPotionScriptingZoneToPlayer[zone.guid] = color
    end
  })

  local potionDeck = getObjectFromGUID(OBJECTS.potionDeck)
  spawnObject({
    type = "ScriptingTrigger",
    position = outOfCombatPosition,
    scale = potionDeck.getBounds().size,
    callback_function = function(zone)
      OBJECTS.playerOutOfCombatPotionScriptingZones[color] = zone.guid
      OBJECTS.outOfCombatPotionScriptingZoneToPlayer[zone.guid] = color
    end
  })
end

function handleEndOfTurnClick(arguments)
  local color = arguments.color
  local colorClicks = arguments.colorClicks

  if color ~= colorClicks then
    return
  end

  GAME_DATA.combat.players[color].endsTurn = true
  removePlayerEndOfTurnButton({
    color = color
  })

  local colors = getPlayingColors()
  local colorsCount = #colors
  local colorsEndTheirTurn = 0
  for _, playingColor in ipairs(colors) do
    if GAME_DATA.combat.players[playingColor].endsTurn then
      colorsEndTheirTurn = colorsEndTheirTurn + 1
    end
  end

  if colorsEndTheirTurn == colorsCount then
    startCombatEndOfTurnPhase()
  end
end

function handleEndOfTurnClickRed(_, colorClicks)
  handleEndOfTurnClick({
    color = "Red",
    colorClicks = colorClicks
  })
end

function handleEndOfTurnClickGreen(_, colorClicks)
  handleEndOfTurnClick({
    color = "Green",
    colorClicks = colorClicks
  })
end

function handleEndOfTurnClickBlue(_, colorClicks)
  handleEndOfTurnClick({
    color = "Blue",
    colorClicks = colorClicks
  })
end

function handleEndOfTurnClickPink(_, colorClicks)
  handleEndOfTurnClick({
    color = "Pink",
    colorClicks = colorClicks
  })
end

function removePlayerEndOfTurnButton(arguments)
  local color = arguments.color
  local tableObject = Tables.getTableObject()
  local buttons = tableObject.getButtons()
  for _, button in ipairs(buttons) do
    if button.click_function == "handleEndOfTurnClick"..color then
      tableObject.removeButton(button.index)
      break
    end
  end
end

function createPlayerEndOfTurnButton(arguments)
  local color = arguments.color
  local position = arguments.position
  local tableObject = Tables.getTableObject()
  tableObject.createButton({
    click_function = "handleEndOfTurnClick"..color,
    label = "End turn",
    position = tableObject.positionToLocal({
      x = -position.x,
      y = position.y,
      z = position.z
    }),
    height = 300,
    width = 800,
    font_color = {
      r = 0,
      g = 0,
      b = 0,
    },
    font_size = 160,
    rotation = { 0, 180, 0 },
    scale = { 1, 1, 1 }
  })
end

function handleNeowEffects(effects, color)
  function handleNeowEffectsCoroutine()
    if GAME_DATA.players[color].neowBonusStarted or GAME_DATA.players[color].neowBonusDone then
      return 1
    end
    GAME_DATA.players[color].neowBonusStarted = true
    local effectsDone = 0
    local maxWaitCount = 100
    for index, effect in ipairs(effects) do
      handleEffect({
        effect = effect,
        target = {
          type = TARGET_TYPES.PLAYER,
          payload = {
            color = color
          }
        },
        onDone = function(waitCount)
          effectsDone = effectsDone + 1
          if waitCount ~= nil then
            maxWaitCount = math.max(waitCount, maxWaitCount)
          end
          if effectsDone ~= #effects then
            return
          end
          GAME_DATA.players[color].neowBonusDone = true

          local character = GAME_DATA.players[color].character
          local playerStarterDeck = getObjectFromGUID(OBJECTS.characterDecks[character].starterDeck)
          local deckBounds = playerStarterDeck.getBounds()
          local deckPosition = getDecksPosition({
            color = color
          })
          local drawDeckPosition = getDrawDeckPosition({
            color = color
          })
          local discardDeckPosition = getDiscardDeckPosition({
            color = color
          })
          local tableObject = Tables.getTableObject()
          local tableSnapPoints = tableObject.getSnapPoints()
          table.insert(tableSnapPoints, {
            position = tableObject.positionToLocal({
              x = drawDeckPosition.x,
              y = drawDeckPosition.y - 2.5,
              z = drawDeckPosition.z
            })
          })
          table.insert(tableSnapPoints, {
            position = tableObject.positionToLocal({
              x = discardDeckPosition.x,
              y = discardDeckPosition.y - 2.5,
              z = discardDeckPosition.z
            })
          })
          table.insert(tableSnapPoints, {
            position = tableObject.positionToLocal({
              x = deckPosition.x,
              y = deckPosition.y - 2.2,
              z = deckPosition.z
            })
          })
          tableObject.setSnapPoints(tableSnapPoints)
          spawnObject({
            type = "ScriptingTrigger",
            position = {
              x = drawDeckPosition.x,
              y = drawDeckPosition.y - 2,
              z = drawDeckPosition.z
            },
            scale = {
              x = deckBounds.size.x,
              y = 1,
              z = deckBounds.size.z,
            },
            callback_function = function(zone)
              OBJECTS.playerDrawScriptingZones[color] = zone.guid
            end
          })
          spawnObject({
            type = "ScriptingTrigger",
            position = {
              x = discardDeckPosition.x,
              y = discardDeckPosition.y - 2,
              z = discardDeckPosition.z
            },
            scale = {
              x = deckBounds.size.x,
              y = 1,
              z = deckBounds.size.z,
            },
            callback_function = function(zone)
              OBJECTS.playerDiscardScriptingZones[color] = zone.guid
              OBJECTS.discardScriptingZoneToPlayer[zone.guid] = color
            end
          })

          local playingColors = getPlayingColors()
          local colorsDoneNeowBonus = {}
          for index, color in ipairs(playingColors) do
            if GAME_DATA.players[color].neowBonusDone then
              table.insert(colorsDoneNeowBonus, color)
            end
          end
          if #playingColors == #colorsDoneNeowBonus then
            startFirstEncounter({
              waitCount = maxWaitCount
            })
          end
        end
      })
    end
    local card = getObjectFromGUID(OBJECTS.playerNeowBlessingCard[color])
    card.destruct()
    -- setupPlayerPlayZone({
    --   color = color
    -- })
    setupPlayerBoardZone({
      color = color
    })
    return 1
  end
  startLuaCoroutine(self, "handleNeowEffectsCoroutine")
end

function canPlayerClickNeowCard(neowCardGuid, color)
  return OBJECTS.playerNeowBlessingCard[color] == neowCardGuid
end

function handleNeowFirstClick(neowCard, color)
  if not canPlayerClickNeowCard(neowCard.guid, color) then
    return
  end
  local effects = NEOW_BLESSING_DATA[neowCard.guid][1].effects
  local effectsJSON = JSON.encode_pretty(effects)
  handleNeowEffects(effects, color)
end

function handleNeowSecondClick(neowCard, color)
  if not canPlayerClickNeowCard(neowCard.guid, color) then
    return
  end
  local effects = NEOW_BLESSING_DATA[neowCard.guid][2].effects
  local effectsJSON = JSON.encode_pretty(effects)
  handleNeowEffects(effects, color)
end

function handleNeowThirdClick(neowCard, color)
  if not canPlayerClickNeowCard(neowCard.guid, color) then
    return
  end
  local effects = NEOW_BLESSING_DATA[neowCard.guid][3].effects
  local effectsJSON = JSON.encode_pretty(effects)
  handleNeowEffects(effects, color)
end

function filterNeowDeck(arguments)
  local effectType = arguments.effectType
  local neowBlessingDeck = getObjectFromGUID(OBJECTS.neowBlessingDeck)

  local cards = neowBlessingDeck.getObjects()
  for index, card in ipairs(cards) do
    local buttons = NEOW_BLESSING_DATA[card.guid]
    local isFiltered = false
    local buttonIndex = 1
    while buttonIndex ~= 4 do
      local button = buttons[buttonIndex]
      for _, effect in ipairs(button.effects) do
        if effect.type == effectType then
          isFiltered = true
        end
      end
      buttonIndex = buttonIndex + 1
    end
    if not isFiltered then
      neowBlessingDeck.takeObject({
        guid = card.guid,
        callback_function = function(cardObject)
          cardObject.destruct()
        end
      })
    end
  end
end

function orderRelicDeckForDebug()
  local order = DEBUG_RELIC_DRAW_ORDER
  local deck = getObjectFromGUID(OBJECTS.relicsDeck)
  local objects = deck.getObjects()
  local guids = {}
  for _, relicName in ipairs(order) do
    for index, object in ipairs(objects) do
      if object.name == relicName then
        table.insert(guids, object.guid)
      end
    end
  end

  local deckPosition = deck.getPosition()
  local index = 0
  while index < #guids do
    local backIndex = #guids - index
    deck.takeObject({
      guid = guids[backIndex],
      position = {
        x = deckPosition.x,
        y = deckPosition.y + 2 + index,
        z = deckPosition.z,
      }
    })
    index = index + 1
  end
end

function setupPlayers(arguments)
  local players = arguments.players
  local act = arguments.act
  function setupPlayersCoroutine()
    Hands.enable = true
    for index, color in ipairs(players) do
      local character = GAME_DATA.players[color].character
      local characterBoard = getObjectFromGUID(OBJECTS.characterBoards[character])
      characterBoard.call("setupForPlayer", {
        color = color
      })
      GAME_DATA.players[color].hp = CHARACTER_MAX_HP[character]

    end

    waitFrames(500)

    local actMap = getObjectFromGUID(OBJECTS.actMaps[act])
    local characterPositions = getMapCharacterPositions({
      mapObject = actMap
    })
    for index, color in ipairs(players) do
      local playerFigure = getObjectFromGUID(OBJECTS.characterFigures[GAME_DATA.players[color].character])
      local position = characterPositions[index]
      playerFigure.scale(1.4)
      playerFigure.setPositionSmooth({
        x = position.x,
        y = position.y + 2,
        z = position.z
      })
    end

    local neowBlessingDeck = getObjectFromGUID(OBJECTS.neowBlessingDeck)
    neowBlessingDeck.shuffle()

    if DEBUG_ONLY_LOSE_HP_NEOW then
      filterNeowDeck({
        effectType = EFFECT_TYPES.LOSE_HP,
      })
    end

    if DEBUG_ONLY_UPGRADE_CARD_NEOW then
      filterNeowDeck({
        effectType = EFFECT_TYPES.UPGRADE_CARD,
      })
    end

    if DEBUG_ONLY_GAIN_RELIC_NEOW then
      filterNeowDeck({
        effectType = EFFECT_TYPES.GAIN_RELIC
      })
    end

    if DEBUG_ONLY_GAIN_COLORLESS_NEOW then
      filterNeowDeck({
        effectType = EFFECT_TYPES.GAIN_COLORLESS_CARD
      })
    end

    if DEBUG_ONLY_UPGRADE_CARD_NEOW then
      filterNeowDeck({
        effectType = EFFECT_TYPES.UPGRADE_CARD
      })
    end

    if DEBUG_ONLY_REMOVE_CARD_NEOW then
      filterNeowDeck({
        effectType = EFFECT_TYPES.REMOVE_CARD
      })
    end

    if DEBUG_ONLY_RARE_CARD_NEOW then
      filterNeowDeck({
        effectType = EFFECT_TYPES.GAIN_RARE_CARD
      })
    end

    if DEBUG_ONLY_TRANSFORM_NEOW then
      filterNeowDeck({
        effectType = EFFECT_TYPES.TRANSFORM_CARD
      })
    end

    if DEBUG_ONLY_RANDOM_RARE_NEOW then
      filterNeowDeck({
        effectType = EFFECT_TYPES.GAIN_RANDOM_RARE_CARD
      })
    end

    if DEBUG_ONLY_UPGRADE_RANDOM_CARD_NEOW then
      filterNeowDeck({
        effectType = EFFECT_TYPES.UPGRADE_RANDOM_CARD
      })
    end

    if DEBUG_ONLY_RANDOM_CARD_NEOW then
      filterNeowDeck({
        effectType = EFFECT_TYPES.GAIN_RANDOM_CARD
      })
    end

    if DEBUG_ONLY_RANDOM_COLORLESS_NEOW then
      filterNeowDeck({
        effectType = EFFECT_TYPES.GAIN_RANDOM_COLORLESS_CARD
      })
    end

    if DEBUG_ONLY_POTION_NEOW then
      filterNeowDeck({
        effectType = EFFECT_TYPES.GAIN_RANDOM_POTION
      })
    end

    if DEBUG_USE_RELIC_DRAW_ORDER then
      orderRelicDeckForDebug()
    end

    for index, color in ipairs(players) do
      setupPlayerDecks({
        color = color
      })
      setupPlayerPotionZone({
        color = color
      })
      local characterBoard = getObjectFromGUID(OBJECTS.characterBoards[GAME_DATA.players[color].character])
      local boardPosition = characterBoard.getPosition()
      local boardBounds = characterBoard.getBounds()

      local bowl = spawnObject({
        type = "Bowl",
        scale = {
          0.7, 0.7, 0.7
        },
        position = {
          x = boardPosition.x + boardBounds.size.x / 2 + 1.6,
          y = boardPosition.y,
          z = boardPosition.z + 2
        },
        callback_function = function(object)
          object.locked = true
          local bounds = object.getBounds()
          local position = object.getPosition()
          local zone = spawnObject({
            type = "ScriptingTrigger",
            scale = {
              bounds.size.x, bounds.size.y + 5, bounds.size.z
            },
            position = position
          })
          OBJECTS.playerGoldBowlScriptingZones[color] = zone.guid
        end
      })
      OBJECTS.playerGoldBowls[color] = bowl.guid

      local neowCard = neowBlessingDeck.takeObject({
        position = {
          x = boardPosition.x,
          y = boardPosition.y,
          z = boardPosition.z + 10
        },
        flip = true
      })
      local neowCardScale = neowCard.getScale().x
      if (neowCardScale < 2) then
        neowCard.scale(3)
      end
      neowCard.locked = true
      waitFrames(250)
      local buttonPositions = {
        {
          0.02, 0.6, 0.868
        },
        {
          0.02, 0.6, 1.08
        },
        {
          0.02, 0.6, 1.314
        }
      }
      local buttonScales = {
        { 1, 1, 0.7 },
        { 1, 1, 0.7 },
        { 1, 1, 0.7 }
      }
      if NEOW_BLESSING_DATA[neowCard.guid][4] ~= nil and
        NEOW_BLESSING_DATA[neowCard.guid][4].lastButtonBigger then
          buttonPositions[1][3] = 0.786
          buttonPositions[2][3] = 1
          buttonPositions[3][3] = 1.28
          buttonScales[3][3] = 1.3
      end
      neowCard.createButton({
        click_function = "handleNeowFirstClick",
        function_owner = self,
        width = 900,
        height = 7,
        position = buttonPositions[1],
        color = { 0, 0, 0, 0 },
        scale = buttonScales[1]
      })
      neowCard.createButton({
        click_function = "handleNeowSecondClick",
        function_owner = self,
        width = 900,
        height = 7,
        position = buttonPositions[2],
        color = { 0, 0, 0, 0 },
        scale = buttonScales[2]
      })
      neowCard.createButton({
        click_function = "handleNeowThirdClick",
        function_owner = self,
        width = 900,
        height = 7,
        position = buttonPositions[3],
        color = { 0, 0, 0, 0 },
        scale = buttonScales[3]
      })
      OBJECTS.playerNeowBlessingCard[color] = neowCard.guid

      handleEffect({
        effect = {
          type = EFFECT_TYPES.GAIN_GOLD,
          payload = {
            amount = 3
          }
        },
        target = {
          type = TARGET_TYPES.PLAYER,
          payload = {
            color = color
          }
        }
      })
    end

    return 1
  end

  startLuaCoroutine(self, "setupPlayersCoroutine")
end

function setupMapCharacterSnapPoints(arguments)
  local mapObject = arguments.mapObject
  local characterSnapPoints = getMapCharacterSnapPoints({
    mapObject = mapObject
  })
  local snapPoints = mapObject.getSnapPoints()
  for index = 1, #characterSnapPoints do
    snapPoints[#snapPoints + 1] = characterSnapPoints[index]
  end
  mapObject.setSnapPoints(snapPoints)
end

function getMapStartPosition(arguments)
  local mapObject = arguments.mapObject
  local position = mapObject.getPosition()
  local bounds = mapObject.getBounds()

  return {
    x = position.x - 1.3,
    y = position.y + bounds.size.y,
    z = position.z - bounds.size.z / 2 + 1.75
  }
end

function setupAct(arguments)
  function setupActCoroutine()
    local act = arguments.act
    local actMap = getObjectFromGUID(OBJECTS.actMaps[act])
    local tableObject = Tables.getTableObject()
    local tableBounds = tableObject.getBounds()

    actMap.scale(1.7)
    local actMapBounds = actMap.getBounds()
    actMap.setPositionSmooth(getPositionForMap({
      map = actMap
    }))
    actMap.interactable = false

    waitFrames(550)
    actMap.locked = true
    actMap.call("setup")
    local bootObject = getObjectFromGUID(OBJECTS.boot)
    bootObject.setPositionSmooth(getMapStartPosition({
      mapObject = actMap
    }))

    local actDecksBag = getObjectFromGUID(OBJECTS.actDecksBag[act].base)
    local bossMapPosition = getMapBossPosition({
      mapObject = actMap
    })
    local bossDeck = actDecksBag.takeObject({
      index = 4,
      position = bossMapPosition
    })
    bossDeck.shuffle()
    local bossObject = bossDeck.takeObject({
      position = {
        x = bossMapPosition.x,
        y = bossMapPosition.y,
        z = bossMapPosition.z,
      }
    })
    actDecksBag.putObject(bossDeck)
    bossObject.scale(1.6)

    local mapRotation = actMap.getRotation()
    local whiteTokensBag = getObjectFromGUID(OBJECTS.whiteMapTokensBag)
    whiteTokensBag.shuffle()
    local startRelativePositions = actMap.getTable("START_RELATIVE_POSITIONS");
    local whiteTokenWorldPositions = actMap.call("startRelativePositionsToWorld", {
      positions = startRelativePositions.whiteTokens
    })
    local whiteTokensBag = getObjectFromGUID(OBJECTS.whiteMapTokensBag)
    whiteTokensBag.shuffle()
    local blackTokenWorldPositions = actMap.call("startRelativePositionsToWorld", {
      positions = startRelativePositions.blackTokens
    })
    local blackTokensBag = getObjectFromGUID(OBJECTS.blackMapTokensBag)
    blackTokensBag.shuffle()

    for index, position in ipairs(whiteTokenWorldPositions) do
      whiteTokensBag.takeObject({
        position = position,
        rotation = mapRotation
      })
    end
    for index, position in ipairs(blackTokenWorldPositions) do
      blackTokensBag.takeObject({
        position = position,
        rotation = mapRotation
      })
    end

    return 1
  end

  startLuaCoroutine(self, "setupActCoroutine")
end

function gainRelic(arguments)
  local color = arguments.color
  local guid = arguments.guid

  local relicsGridPosition = getRelicsGridPosition({
    color = color
  })
  local offset = getRelicsGridOffsetForNewRelic({
    color = color
  })
  local relicObject = getObjectFromGUID(guid)
  relicObject.setPositionSmooth({
    x = relicsGridPosition.x + offset.x,
    y = relicsGridPosition.y + offset.y,
    z = relicsGridPosition.z + offset.z
  })
  local relicName = relicObject.getName()
  table.insert(GAME_DATA.players[color].relics, {
    guid = relicObject.guid,
    name = relicName
  })
  GAME_DATA.players[color].relicsMap[relicName] = true
end

function gainCard(arguments)
  local color = arguments.color
  local guid = arguments.guid

  local deckPosition = getDecksPosition({
    color = color
  })
  local card = getObjectFromGUID(guid)
  local rotation = card.getRotation()
  local isFlipped = rotation.z ~= 180
  if isFlipped then
    card.flip()
  end
  card.setPositionSmooth(deckPosition)
end

function onOptionalGainRelic(arguments)
  local color = arguments.color
  local guid = arguments.guid

  gainRelic({
    guid = guid,
    color = color
  })
  endOptionalGain({
    color = color,
    taken = {
      [guid] = true
    }
  })
end

function onOptionalGainCard(arguments)
  local color = arguments.color
  local guid = arguments.guid

  gainCard({
    guid = guid,
    color = color
  })
  endOptionalGain({
    color = color,
    taken = {
      [guid] = true
    }
  })
end

function onOptionalGainPickUp(arguments)
  local color = arguments.color
  local guid = arguments.guid
  local gainData = GAME_DATA.players[color].optionalGainInProgress

  if gainData.tag == TAG_TYPES.RELIC then
    onOptionalGainRelic({
      color = color,
      guid = guid
    })
    return
  end

  if gainData.tag == nil then
    onOptionalGainCard({
      color = color,
      guid = guid
    })
    return
  end
end

function onObjectPickUp(color, object)
  local optionalGain = GAME_DATA.players[color].optionalGainInProgress
  if optionalGain ~= nil then
    local tag = object.getTags()[1]
    local isValidGuid = false
    for _, objectGuid in ipairs(optionalGain.objects) do
      if object.guid == objectGuid then
        isValidGuid = true
        break
      end
    end

    if tag == optionalGain.tag then
      object.drop()
      if isValidGuid then
        onOptionalGainPickUp({
          color = color,
          guid = object.guid
        })
      end
    end
  end

  local isCombat = GAME_DATA.combat.inProgress
  if isCombat then
    local isNotPlayPhase = GAME_DATA.combat.phase ~= TURN_PHASE_TYPES.PLAY
    if isNotPlayPhase then
      broadcastToColor("You can play items only in play phase", color)
      object.drop()
    end

    local playerEndsTurn = GAME_DATA.combat.players[color].endsTurn
    if playerEndsTurn then
      broadcastToColor("You end your turn, you can't play items anymore", color)
      object.drop()
    end
  end
end

function onObjectLeaveZone(zone, object)
  local isCombat = GAME_DATA.combat.inProgress
  if isCombat then
    local color = OBJECTS.handToPlayer[zone.guid]
    local isReducedCard = GAME_DATA.combat.reducedCards[object.guid]
    if color ~= nil and GAME_DATA.combat.players[color].endsTurn then
      return
    end

    if color ~= nil and not isReducedCard then
      local reducedCard = getObjectFromGUID(object.guid)
      if reducedCard == nil then
        return
      end
      reducedCard.scale(0.5)
      GAME_DATA.combat.reducedCards[object.guid] = true
    end
  end
end

function onObjectDrop(color, object)
  local isCombat = GAME_DATA.combat.inProgress
  local tag = object.getTags()[1]

  if isCombat and object.name == "Card" and tag == nil then
    local guid = object.guid
    local handZone = getObjectFromGUID(OBJECTS.playerHands[color])
    local handZoneObjects = handZone.getObjects()
    local isInHand = false
    for _, handObject in ipairs(handZoneObjects) do
      if object.guid == handObject.guid then
        isInHand = true
        break
      end
    end
    if not isInHand then
      onPlayerDropsCard({
        color = color,
        card = object
      })
    end
  end

  if isCombat and tag == TAG_TYPES.RELIC then
    local guid = object.guid
    if GAME_DATA.combat.canTargetRelics[guid] == nil or
      GAME_DATA.combat.canTargetRelics[guid].color ~= color then
        local ownerColor = nil
        local name = object.getName()
        local colors = getPlayingColors()
        for _, color in ipairs(colors) do
          if GAME_DATA.players[color].relicsMap[name] then
            ownerColor = color
            break
          end
        end
        moveRelicBackIntoGrid({
          color = ownerColor,
          guid = guid,
        })
        return
    end
    onPlayerDropsTargetRelic({
      color = color,
      relic = object
    })
  end
end

function onObjectEnterZone(zone, object)
  local isCombat = GAME_DATA.combat.inProgress
  if isCombat and object.name == "Card" then
    if zone.name == "ScriptingTrigger" then
      local enemyGuid = OBJECTS.combat.zoneToEnemy[zone.guid]
      local playingCard = GAME_DATA.combat.playingCard
      local playingTargetRelic = GAME_DATA.combat.playingTargetRelic
      local isPlayingCard = playingCard ~= nil and playingCard.cardGuid == object.guid
      local isPlayingRelic = playingTargetRelic ~= nil and playingTargetRelic.guid == object.guid
      if enemyGuid ~= nil then
        if isPlayingCard then
          onPlayingCardTargetChosen({
            type = TARGET_TYPES.ENEMY,
            cardGuid = enemyGuid
          })
        end

        if isPlayingRelic then
          onPlayingRelicTargetChosen({
            type = TARGET_TYPES.ENEMY,
            cardGuid = enemyGuid
          })
        end
      end
    end

    local playerHandGuid = OBJECTS.handToPlayer[zone.guid]
    local isPlayerDiscard = OBJECTS.discardScriptingZoneToPlayer[zone.guid] ~= nil
    local isReducedCard = GAME_DATA.combat.reducedCards[object.guid]
    if (playerHandGuid ~= nil or isPlayerDiscard) and isReducedCard then
      local reducedCard = getObjectFromGUID(object.guid)
      reducedCard.scale(2)
      GAME_DATA.combat.reducedCards[object.guid] = false
    end
  end
end

function startGame()
  local allPlayers = {}
  for color, data in pairs(GAME_DATA.players) do
    if data.character ~= nil then
      table.insert(allPlayers, color)
    end
  end
  local startMenu = getObjectFromGUID(OBJECTS.startMenu)
  startMenu.destruct()

  local relicsDeck = getObjectFromGUID(OBJECTS.relicsDeck)
  relicsDeck.shuffle()
  local colorlessDeck = getObjectFromGUID(OBJECTS.colorlessDeck)
  colorlessDeck.shuffle()
  local potionDeck = getObjectFromGUID(OBJECTS.potionDeck)
  potionDeck.shuffle()
  setupAct({
    act = GAME_DATA.act
  })
  setupPlayers({
    players = allPlayers,
    act = GAME_DATA.act
  })
end
