CHARACTERS = {"Ironclad", "Silent", "Defect", "Watcher"}

GAME_DATA = {
  act = 1
}

PLAYERS_DATA = {
  Red = {},
  Green = {},
  Blue = {},
  Pink = {},
}

OBJECTS = {
  startMenu = "1c1c13",

  characterBoards = {
    [CHARACTERS[1]] = "63f2c4",
    [CHARACTERS[2]] = "9ee996",
    [CHARACTERS[3]] = "b293d2",
    [CHARACTERS[4]] = "60b3de"
  },
  characterBags = {
    [CHARACTERS[1]] = "a29133",
    [CHARACTERS[2]] = "6a89d8",
    [CHARACTERS[3]] = "0f270c",
    [CHARACTERS[4]] = "f37f4f"
  },
  characterFigures = {
    [CHARACTERS[1]] = "b9ce26",
    [CHARACTERS[2]] = "64b541",
    [CHARACTERS[3]] = "5a68a5",
    [CHARACTERS[4]] = "410585"
  },

  playerHands = {
    Red = "198286",
    Green = "761a86",
    Blue = "507348",
    Pink = "32fa24"
  },

  boot = "d4e0e6",

  actMaps = {
    "0b5712",
    "9a9d69",
    "7ed624"
  }
}

function waitFrames(frames) --This function can only be used inside a coroutine because it is using coroutine.yield()
   while frames > 0 do --loop until frames = 0
      coroutine.yield(0) --this will wait 1 frame, reguardless of the number put inside coroutine.yield(#)
      frames = frames - 1 --decrement frames every loop
   end
end

function onLoad()
  for index, color in ipairs({ "Red", "Green", "Blue", "Pink" }) do
    local handZone = getObjectFromGUID(OBJECTS.playerHands[color])
    handZone.setScale({
      x = 15.3268948,
      y = 11.8970528,
      z = 6.35014534
    })
    handZone.setPosition({
      x = -60 + 24 * index,
      y = 3.29337835,
      z = -34.42515,
    })
    handZone.setRotation({
      x = 0,
      y = 180,
      z = 0
    })
  end

  local boot = getObjectFromGUID(OBJECTS.boot)
  boot.use_snap_points = true
end

function getAssignedCharacterToPlayer(arguments)
  local color = arguments.color
  return PLAYERS_DATA[color].character
end

function canAssignCharacterToPlayer(arguments)
  local character = arguments.character
  local color = arguments.color
  for color, data in pairs(PLAYERS_DATA) do
    if data.character != nil and data.character == character then
      return false
    end
  end
  return true
end

function assignCharacterToPlayer(arguments)
  local character = arguments.character
  local color = arguments.color
  PLAYERS_DATA[color].character = character
end

function canUnsignCharacterFromPlayer(arguments)
  local character = arguments.character
  local color = arguments.color

  return PLAYERS_DATA[color].character != nil and
    PLAYERS_DATA[color].character == character
end

function unsignCharacterFromPlayer(arguments)
  local color = arguments.color

  PLAYERS_DATA[color].character = nil
end

function setupPlayerDecks(arguments)
  local color = arguments.color

  local handZone = getObjectFromGUID(OBJECTS.playerHands[color])
  local handZonePosition = handZone.getPosition()
  local character = PLAYERS_DATA[color].character
  local characterBoard = getObjectFromGUID(OBJECTS.characterBoards[character])
  local characterBag = getObjectFromGUID(OBJECTS.characterBags[character])
  local boardBounds = characterBoard.getBoundsNormalized()

  local decksPosition = {
    x = handZonePosition.x - boardBounds.size.x / 2 - 1.2,
    y = handZonePosition.y,
    z = handZonePosition.z + 16
  }
  local starterDeck = characterBag.takeObject({
    position = decksPosition,
    rotation = {
      x = 0,
      y = 180,
      z = 180
    }
  })
  starterDeck.interactable = false
  starterDeck.shuffle()

  local rewardsDeck = characterBag.takeObject({
    position = {
      x = decksPosition.x,
      y = decksPosition.y,
      z = decksPosition.z + 4
    },
    rotation = {
      x = 0,
      y = 180,
      z = 180
    }
  })
  rewardsDeck.interactable = false
  rewardsDeck.shuffle()

  local rareDeck = characterBag.takeObject({
    position = {
      x = decksPosition.x,
      y = decksPosition.y,
      z = decksPosition.z + 8
    },
    rotation = {
      x = 0,
      y = 180,
      z = 180
    }
  })
  rareDeck.interactable = false
  rareDeck.shuffle()
end

function getMapCharacterPositions(arguments)
  local mapObject = arguments.mapObject
  local bounds = mapObject.getBounds()
  local position = mapObject.getPosition()
  local scale = mapObject.getScale()

  local positions = {}
  local positionsDone = 0
  while positionsDone != 4 do
    table.insert(positions, {
      x = position.x + bounds.size.x / 2 - 0.1 * scale.x,
      y = position.y,
      z = position.z - bounds.size.z / 2 + (0.2 + positionsDone * 0.435) * scale.z,
    })
    positionsDone = positionsDone + 1
  end
  return positions
end

function getMapCharacterSnapPoints(arguments)
  local mapObject = arguments.mapObject
  local characterPositions = getMapCharacterPositions({
    mapObject = mapObject
  })
  local snapPoints = {}
  for index, position in ipairs(characterPositions) do
    table.insert(snapPoints, {
      position = mapObject.positionToLocal(position)
    })
  end
  return snapPoints
end

function setupPlayers(arguments)
  local players = arguments.players
  local act = arguments.act
  function setupPlayersCoroutine()
    log(players)
    Hands.enable = true
    for index, color in ipairs(players) do
      local character = PLAYERS_DATA[color].character
      local characterBoard = getObjectFromGUID(OBJECTS.characterBoards[character])
      characterBoard.call("setupForPlayer", {
        color = color
      })
    end

    waitFrames(500)

    local actMap = getObjectFromGUID(OBJECTS.actMaps[act])
    local characterPositions = getMapCharacterPositions({
      mapObject = actMap
    })
    for index, color in ipairs(players) do
      local playerFigure = getObjectFromGUID(OBJECTS.characterFigures[PLAYERS_DATA[color].character])
      local position = characterPositions[index]
      playerFigure.scale(1.4)
      playerFigure.setPositionSmooth({
        x = position.x,
        y = position.y + 1.5,
        z = position.z
      })
    end

    for index, color in ipairs(players) do
      setupPlayerDecks({
        color = color
      })
    end

    return 1
  end

  startLuaCoroutine(self, "setupPlayersCoroutine")
end

function setupMapCharacterSnapPoints(arguments)
  local mapObject = arguments.mapObject
  local characterSnapPoints = getMapCharacterSnapPoints({
    mapObject = mapObject
  })
  local snapPoints = mapObject.getSnapPoints()
  for index = 1, #characterSnapPoints do
    snapPoints[#snapPoints + 1] = characterSnapPoints[index]
  end
  mapObject.setSnapPoints(snapPoints)
end

function getMapStartPosition(arguments)
  local mapObject = arguments.mapObject
  local position = mapObject.getPosition()
  local bounds = mapObject.getBounds()

  return {
    x = position.x - 1.3,
    y = position.y + bounds.size.y,
    z = position.z - bounds.size.z / 2 + 1.75
  }
end

function setupAct(arguments)
  function setupActCoroutine()
    local act = arguments.act
    local actMap = getObjectFromGUID(OBJECTS.actMaps[act])
    local tableObject = Tables.getTableObject()
    local tableBounds = tableObject.getBounds()

    actMap.scale(1.7)
    local actMapBounds = actMap.getBounds()
    actMap.setPositionSmooth({
      x = -tableBounds.size.x / 2 + actMapBounds.size.x / 2 + 18,
      y = 2,
      z = tableBounds.center.z + 9,
    })
    actMap.interactable = false

    waitFrames(550)
    actMap.locked = true
    actMap.call("setup")
    local bootObject = getObjectFromGUID(OBJECTS.boot)
    bootObject.setPositionSmooth(getMapStartPosition({
      mapObject = actMap
    }))

    return 1
  end

  startLuaCoroutine(self, "setupActCoroutine")
end

function startGame()
  log("Starting game...")
  log(JSON.encode_pretty(PLAYERS_DATA))
  local allPlayers = {}
  for color, data in pairs(PLAYERS_DATA) do
    if data.character != nil then
      table.insert(allPlayers, color)
    end
  end
  log("All players:")
  log(JSON.encode_pretty(allPlayers))
  local startMenu = getObjectFromGUID(OBJECTS.startMenu)
  startMenu.destruct()
  setupAct({
    act = GAME_DATA.act
  })
  setupPlayers({
    players = allPlayers,
    act = GAME_DATA.act
  })
end
