CHARACTERS = {"Ironclad", "Silent", "Defect", "Watcher"}

GAME_DATA = {
  act = 1
}

PLAYERS_DATA = {
  Red = {},
  Green = {},
  Blue = {},
  Pink = {},
}

OBJECTS = {
  startMenu = "1c1c13",

  characterBoards = {
    [CHARACTERS[1]] = "63f2c4",
    [CHARACTERS[2]] = "9ee996",
    [CHARACTERS[3]] = "b293d2",
    [CHARACTERS[4]] = "60b3de"
  },
  characterBags = {
    [CHARACTERS[1]] = "a29133",
    [CHARACTERS[2]] = "6a89d8",
    [CHARACTERS[3]] = "0f270c",
    [CHARACTERS[4]] = "f37f4f"
  },
  characterFigures = {
    [CHARACTERS[1]] = "b9ce26",
    [CHARACTERS[2]] = "64b541",
    [CHARACTERS[3]] = "5a68a5",
    [CHARACTERS[4]] = "410585"
  },

  playerHands = {
    Red = "198286",
    Green = "761a86",
    Blue = "507348",
    Pink = "32fa24"
  },

  boot = "d4e0e6",

  actMaps = {
    "0b5712",
    "9a9d69",
    "7ed624"
  },
  actDecksBag = {
    {
      base = "7def40",
      ascension = "e4892b"
    },
    {
      base = "bc0921",
      ascension = "a9f893"
    },
    {
      base = "4d2c55",
      ascension = "1efef1"
    },
    {
      base = "c9e668",
      ascension = "ab1455"
    }
  },

  whiteMapTokensBag = "021340",
  blackMapTokensBag = "b4d7e7",

  neowBlessingDeck = "938861"
}

function waitFrames(frames) --This function can only be used inside a coroutine because it is using coroutine.yield()
   while frames > 0 do --loop until frames = 0
      coroutine.yield(0) --this will wait 1 frame, reguardless of the number put inside coroutine.yield(#)
      frames = frames - 1 --decrement frames every loop
   end
end

function onLoad()
  for index, color in ipairs({ "Red", "Green", "Blue", "Pink" }) do
    local handZone = getObjectFromGUID(OBJECTS.playerHands[color])
    handZone.setScale({
      x = 15.3268948,
      y = 11.8970528,
      z = 6.35014534
    })
    handZone.setPosition({
      x = -60 + 24 * index,
      y = 3.29337835,
      z = -34.42515,
    })
    handZone.setRotation({
      x = 0,
      y = 180,
      z = 0
    })
  end

  local boot = getObjectFromGUID(OBJECTS.boot)
  boot.use_snap_points = true
end

function getAssignedCharacterToPlayer(arguments)
  local color = arguments.color
  return PLAYERS_DATA[color].character
end

function canAssignCharacterToPlayer(arguments)
  local character = arguments.character
  local color = arguments.color
  for color, data in pairs(PLAYERS_DATA) do
    if data.character != nil and data.character == character then
      return false
    end
  end
  return true
end

function assignCharacterToPlayer(arguments)
  local character = arguments.character
  local color = arguments.color
  PLAYERS_DATA[color].character = character
end

function canUnsignCharacterFromPlayer(arguments)
  local character = arguments.character
  local color = arguments.color

  return PLAYERS_DATA[color].character != nil and
    PLAYERS_DATA[color].character == character
end

function unsignCharacterFromPlayer(arguments)
  local color = arguments.color

  PLAYERS_DATA[color].character = nil
end

function setupPlayerDecks(arguments)
  local color = arguments.color

  local handZone = getObjectFromGUID(OBJECTS.playerHands[color])
  local handZonePosition = handZone.getPosition()
  local character = PLAYERS_DATA[color].character
  local characterBoard = getObjectFromGUID(OBJECTS.characterBoards[character])
  local characterBag = getObjectFromGUID(OBJECTS.characterBags[character])
  local boardBounds = characterBoard.getBoundsNormalized()

  local decksPosition = {
    x = handZonePosition.x - boardBounds.size.x / 2 - 1.2,
    y = handZonePosition.y,
    z = handZonePosition.z + 16
  }
  local starterDeck = characterBag.takeObject({
    position = decksPosition,
    rotation = {
      x = 0,
      y = 180,
      z = 180
    }
  })
  starterDeck.interactable = false
  starterDeck.shuffle()

  local rewardsDeck = characterBag.takeObject({
    position = {
      x = decksPosition.x,
      y = decksPosition.y,
      z = decksPosition.z + 4
    },
    rotation = {
      x = 0,
      y = 180,
      z = 180
    }
  })
  rewardsDeck.interactable = false
  rewardsDeck.shuffle()

  local rareDeck = characterBag.takeObject({
    position = {
      x = decksPosition.x,
      y = decksPosition.y,
      z = decksPosition.z + 8
    },
    rotation = {
      x = 0,
      y = 180,
      z = 180
    }
  })
  rareDeck.interactable = false
  rareDeck.shuffle()
end

function getMapBossPosition(arguments)
  local mapObject = arguments.mapObject
  local startPosition = getMapStartPosition({
    mapObject = mapObject
  })
  return {
    x = startPosition.x + 0.25,
    y = startPosition.y,
    z = startPosition.z + 24
  }
end

function getMapCharacterPositions(arguments)
  local mapObject = arguments.mapObject
  local bounds = mapObject.getBounds()
  local position = mapObject.getPosition()
  local scale = mapObject.getScale()

  local positions = {}
  local positionsDone = 0
  while positionsDone != 4 do
    table.insert(positions, {
      x = position.x + bounds.size.x / 2 - 0.1 * scale.x,
      y = position.y,
      z = position.z - bounds.size.z / 2 + (0.2 + positionsDone * 0.435) * scale.z,
    })
    positionsDone = positionsDone + 1
  end
  return positions
end

function getMapCharacterSnapPoints(arguments)
  local mapObject = arguments.mapObject
  local characterPositions = getMapCharacterPositions({
    mapObject = mapObject
  })
  local snapPoints = {}
  for index, position in ipairs(characterPositions) do
    table.insert(snapPoints, {
      position = mapObject.positionToLocal(position)
    })
  end
  return snapPoints
end

function setupPlayerPlayZone(arguments)
  local color = arguments.color
  local playerBoard = getObjectFromGUID(OBJECTS.characterBoards[PLAYERS_DATA[color].character])
  local playerBoardPosition = playerBoard.getPosition()
  local playerBoardBounds = playerBoard.getBounds()
  spawnObject({
    type = "ScriptingTrigger",
    position = {
      x = playerBoardPosition.x,
      y = playerBoardPosition.y,
      z = playerBoardPosition.z + playerBoardBounds.size.z / 2 + 6
    },
    scale = { 12, 0.7, 10 },
    callback_function = function(zone)
      local bounds = zone.getBounds()
      local position = zone.getPosition()

      playerBoard.UI.setAttribute("main", "active", "true")
    end
  })
end

function setupPlayers(arguments)
  local players = arguments.players
  local act = arguments.act
  function setupPlayersCoroutine()
    Hands.enable = true
    for index, color in ipairs(players) do
      local character = PLAYERS_DATA[color].character
      local characterBoard = getObjectFromGUID(OBJECTS.characterBoards[character])
      characterBoard.call("setupForPlayer", {
        color = color
      })
    end

    waitFrames(500)

    local actMap = getObjectFromGUID(OBJECTS.actMaps[act])
    local characterPositions = getMapCharacterPositions({
      mapObject = actMap
    })
    for index, color in ipairs(players) do
      local playerFigure = getObjectFromGUID(OBJECTS.characterFigures[PLAYERS_DATA[color].character])
      local position = characterPositions[index]
      playerFigure.scale(1.4)
      playerFigure.setPositionSmooth({
        x = position.x,
        y = position.y + 2,
        z = position.z
      })
    end

    local neowBlessingDeck = getObjectFromGUID(OBJECTS.neowBlessingDeck)
    neowBlessingDeck.shuffle()
    for index, color in ipairs(players) do
      setupPlayerDecks({
        color = color
      })
      local characterBoard = getObjectFromGUID(OBJECTS.characterBoards[PLAYERS_DATA[color].character])
      local boardPosition = characterBoard.getPosition()
      local neowCard = neowBlessingDeck.takeObject({
        position = {
          x = boardPosition.x,
          y = boardPosition.y,
          z = boardPosition.z + 10
        },
        flip = true
      })
      local neowCardScale = neowCard.getScale().x
      if (neowCardScale < 2) then
        neowCard.scale(3)
      end
      neowCard.locked = true
    end

    return 1
  end

  startLuaCoroutine(self, "setupPlayersCoroutine")
end

function setupMapCharacterSnapPoints(arguments)
  local mapObject = arguments.mapObject
  local characterSnapPoints = getMapCharacterSnapPoints({
    mapObject = mapObject
  })
  local snapPoints = mapObject.getSnapPoints()
  for index = 1, #characterSnapPoints do
    snapPoints[#snapPoints + 1] = characterSnapPoints[index]
  end
  mapObject.setSnapPoints(snapPoints)
end

function getMapStartPosition(arguments)
  local mapObject = arguments.mapObject
  local position = mapObject.getPosition()
  local bounds = mapObject.getBounds()

  return {
    x = position.x - 1.3,
    y = position.y + bounds.size.y,
    z = position.z - bounds.size.z / 2 + 1.75
  }
end

function setupAct(arguments)
  function setupActCoroutine()
    local act = arguments.act
    local actMap = getObjectFromGUID(OBJECTS.actMaps[act])
    local tableObject = Tables.getTableObject()
    local tableBounds = tableObject.getBounds()

    actMap.scale(1.7)
    local actMapBounds = actMap.getBounds()
    actMap.setPositionSmooth({
      x = -tableBounds.size.x / 2 + actMapBounds.size.x / 2 + 18,
      y = 2,
      z = tableBounds.center.z + 9,
    })
    actMap.interactable = false

    waitFrames(550)
    actMap.locked = true
    actMap.call("setup")
    local bootObject = getObjectFromGUID(OBJECTS.boot)
    bootObject.setPositionSmooth(getMapStartPosition({
      mapObject = actMap
    }))

    local actDecksBag = getObjectFromGUID(OBJECTS.actDecksBag[act].base)
    local bossMapPosition = getMapBossPosition({
      mapObject = actMap
    })
    local bossDeck = actDecksBag.takeObject({
      position = bossMapPosition
    })
    bossDeck.shuffle()
    local bossObject = bossDeck.takeObject({
      position = {
        x = bossMapPosition.x,
        y = bossMapPosition.y,
        z = bossMapPosition.z + 0.5
      }
    })
    actDecksBag.putObject(bossDeck)
    bossObject.scale(1.6)

    local mapRotation = actMap.getRotation()
    local whiteTokensBag = getObjectFromGUID(OBJECTS.whiteMapTokensBag)
    whiteTokensBag.shuffle()
    local startRelativePositions = actMap.getTable("START_RELATIVE_POSITIONS");
    local whiteTokenWorldPositions = actMap.call("startRelativePositionsToWorld", {
      positions = startRelativePositions.whiteTokens
    })
    local whiteTokensBag = getObjectFromGUID(OBJECTS.whiteMapTokensBag)
    whiteTokensBag.shuffle()
    local blackTokenWorldPositions = actMap.call("startRelativePositionsToWorld", {
      positions = startRelativePositions.blackTokens
    })
    local blackTokensBag = getObjectFromGUID(OBJECTS.blackMapTokensBag)
    blackTokensBag.shuffle()

    for index, position in ipairs(whiteTokenWorldPositions) do
      whiteTokensBag.takeObject({
        position = position,
        rotation = mapRotation
      })
    end
    for index, position in ipairs(blackTokenWorldPositions) do
      blackTokensBag.takeObject({
        position = position,
        rotation = mapRotation
      })
    end

    return 1
  end

  startLuaCoroutine(self, "setupActCoroutine")
end

function startGame()
  log("Starting game...")
  local allPlayers = {}
  for color, data in pairs(PLAYERS_DATA) do
    if data.character != nil then
      table.insert(allPlayers, color)
    end
  end
  local startMenu = getObjectFromGUID(OBJECTS.startMenu)
  startMenu.destruct()
  setupAct({
    act = GAME_DATA.act
  })
  setupPlayers({
    players = allPlayers,
    act = GAME_DATA.act
  })
end