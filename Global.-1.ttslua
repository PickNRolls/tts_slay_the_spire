function onLoad(saved_game_data)
  PUBLIC = false

  if saved_game_data ~= "" and saved_game_data ~= nil then
    local loaded_data = JSON.decode(saved_game_data)
    CARD_UPGRADE_INFO = loaded_data[1]
    MAP_TOKEN_GUIDS = loaded_data[2]
    ACTIVE_BOSS_CARDS = loaded_data[3]
    ACTIVE_ACT = loaded_data[4]
    ASCENSION_LEVEL = loaded_data[5]
    SUMMON_ASSOCIATION = loaded_data[6]
    ENEMY_HP_ASSOCIATION = loaded_data[7]
    PLAYER_TO_CHARACTER = loaded_data[8]
    CHARACTER_TO_PLAYER = loaded_data[9]
    SOLO_MODE = loaded_data[10]
    SPAWNED_BOSSES = loaded_data[11]
    IN_MERCHANT_MODE = loaded_data[12]
    ENEMY_TYPE_ASSOCIATION = loaded_data[13]
    ENEMY_INTENT_ASSOCIATION = loaded_data[14]
    ENEMY_REWARD_ASSOCIATION = loaded_data[15]
    DEPLOYED_NEOW_CARDS = loaded_data[16]

  end

  if PLAYER_TO_CHARACTER == nil then
    PLAYER_TO_CHARACTER = {}
  end
  if CHARACTER_TO_PLAYER == nil then
    CHARACTER_TO_PLAYER = {}
  end

  if DEPLOYED_NEOW_CARDS == nil then
    DEPLOYED_NEOW_CARDS = {}
  end

  -- GLOBAL VALUES
  PLAYER_BOARD_STEP = {
    ["Energy"] = -0.41,
    ["Block"] = -0.41,
    ["HP"] = -0.509
  }
  PLAYER_BOARD_TRACK_HORIZ_OFFSET = 3.47
  PLAYER_BOARD_TRACK_VERT_OFFSET = {
    ["Energy"] = -1.23,
    ["Block"] = 0,
    ["HP"] = 1.20
  }

  PLAYER_REWARD_DECKS = {
    ["Pink"] = {
      ["Reward"] = {26.55, 1.75, -18.19},
      ["RewardText"] = "fcd19e",
      ["RewardTextPos"] = {26.55, 1.26, -20.19},
      ["Rare"] = {29.38, 1.75, -18.19},
      ["RareText"] = "6dbc72",
      ["RareTextPos"] = {29.38, 1.1, -20.19},
      ["Upgrade"] = {-37.25, 2, 34.55},
      ["UpgradeText"] = "1faae0",
      ["UpgradeTool"] = {27.02, 1.75, -12.45},
      ["Rotation"] = {0, 180, 180},
    },
    ["Red"] = {
      ["Reward"] = {-23.74, 1.75, -18.19},
      ["RewardText"] = "247ce8",
      ["RewardTextPos"] = {-23.74, 1.1, -20.19},
      ["Rare"] = {-26.58, 1.75, -18.19},
      ["RareText"] = "7f5978",
      ["RareTextPos"] = {-26.58, 1.1, -20.19},
      ["Upgrade"] = {-34.25, 2, 34.55},
      ["UpgradeText"] = "624e30",
      ["UpgradeTool"] = {-24.25, 1.75, -12.45},
      ["Rotation"] = {0, 180, 180},
    },
    ["Green"] = {
      ["Reward"] = {-32.90, 1.75, 20.53},
      ["RewardText"] = "e67cb9",
      ["RewardTextPos"] = {-34.90, 1.1, 20.53},
      ["Rare"] = {-32.90, 1.75, 23.37},
      ["RareText"] = "b21610",
      ["RareTextPos"] = {-34.90, 1.1, 23.37},
      ["Upgrade"] = {-31.25, 2, 34.55},
      ["UpgradeText"] = "5302b7",
      ["UpgradeTool"] = {-27.16, 1.75, 21.11},
      ["Rotation"] = {0, 270, 180},
    },
    ["Blue"] = {
      ["Reward"] = {33.33, 1.75, 19.68},
      ["RewardText"] = "93ed4a",
      ["RewardTextPos"] = {35.33, 1.1, 19.68},
      ["Rare"] = {33.33, 1.75, 22.52},
      ["RareText"] = "5b181d",
      ["RareTextPos"] = {35.33, 1.1, 22.52},
      ["Upgrade"] = {-28.25, 2, 34.55},
      ["UpgradeText"] = "674013",
      ["UpgradeTool"] = {27.59, 1.75, 20.27},
      ["Rotation"] = {0, 90, 180},
    },
  }

  USED_GOLD_TRACKER = {}

  -- DEBUG GLOBALS
  DEBUG_LOG_UPGRADE_ASSOCIATIONS = false
  DEBUG_LOG_SUMMON_ASSOCIATIONS = false
  DEBUG_LOG_HP_ASSOCIATIONS = false
  DEBUG_LOG_INTENT_ASSOCIATIONS = false
  DEBUG_LOG_REWARDS_ASSOCIATIONS = false
  DEBUG_USE_ALL_BOSSES = false

  associateComponents()

  -- If we have an ACTIVE_ACT, we potentially need to reassociate the enemy decks, as they may have been recombined and shuffled
  if ACTIVE_ACT ~= nil then
    for type, enemy_deck_info in pairs(ACT_COMPONENTS[ACTIVE_ACT]["EnemyDecks"]) do
      local deck = getObjectFromGUID(enemy_deck_info["Deck"])
      if not deck then
        FindAndAssociateEnemyDeckAsync(type, false)
      end
    end
  end

  -- Unsure why, but sometimes the character images don't show up immediately. Put the menu object into a bag and then take it back out on first load
  local front_end_menu = getObjectFromGUID("28091b")
  if front_end_menu then
    local target_pos = front_end_menu.getPosition()
    local target_rot = front_end_menu.getRotation()
    local bag = getObjectFromGUID("b4d7e7")
    bag.putObject(front_end_menu)
    Wait.frames(function()
      local obj = bag.takeObject({guid=front_end_menu.guid, position=target_pos, rotation=target_rot, smooth=false})

      Wait.frames(function()
        obj.setLock(true)
      end, 1)
    end, 1)
  end

  -- Do the same for the encounter buttons
  for type, button in pairs(BATTLE_BUTTONS) do
    local target_pos = button.getPosition()
    local target_rot = button.getRotation()
    local bag = getObjectFromGUID("b4d7e7")
    bag.putObject(button)
    Wait.frames(function()
      local obj = bag.takeObject({guid=button.guid, position=target_pos, rotation=target_rot, smooth=false})

      Wait.frames(function()
        -- Have to re-associate the variable since it is technically a new object that has been spawned
        BATTLE_BUTTONS[type] = obj
        obj.setLock(true)
      end, 1)
    end, 1)
  end

  -- Do the same for the merchant button
  if MERCHANT["Button"] then
    local target_pos = MERCHANT["Button"].getPosition()
    local target_rot = MERCHANT["Button"].getRotation()
    local bag = getObjectFromGUID("b4d7e7")
    bag.putObject(MERCHANT["Button"])
    Wait.frames(function()
      local obj = bag.takeObject({guid=MERCHANT["Button"].guid, position=target_pos, rotation=target_rot, smooth=false})

      Wait.frames(function()
        -- Have to re-associate the variable since it is technically a new object that has been spawned
        MERCHANT["Button"] = obj
        obj.setLock(true)
      end, 1)
    end, 1)
  end

  -- Have to wait as these buttons are being shipped into the bag and returned
  Wait.frames(function()
    -- If we have an active map, re-add the "Next Act" button
    if ACTIVE_ACT == 1 then
      local mapBoard = getObjectFromGUID(ACT_COMPONENTS[ACTIVE_ACT]["Map"])
      if mapBoard then
        local firstEncounterDeck = getObjectFromGUID(ACT_COMPONENTS[ACTIVE_ACT]["FirstEncounterDeck"])
        -- Check if we've already deployed enemies, or if the 1st encounter deck is still active
        --getEnemyDiscardLocation
        if firstEncounterDeck and (firstEncounterDeck.getRotation()[3] > 170 and firstEncounterDeck.getRotation()[3] < 190) and #getEnemies() == 0 and #getHPCubes() == 0 then
          showFirstEncounterButton()
        else
          createMapButtons()
        end
      else
        broadcastToAll("WARNING: Unable to find deployed map after loading game. Next Act button will not appear")
      end
    elseif ACTIVE_ACT == 2 or ACTIVE_ACT == 3 then
      createMapButtons()

      -- For some reason, the map tokens like to be under the map on reload. Move them up
      for token_type, token_list in pairs(MAP_TOKEN_GUIDS) do
        for _, map_token_guid in ipairs(token_list) do
          local map_token = getObjectFromGUID(map_token_guid)
          if map_token then
            local target_pos = map_token.getPosition()
            target_pos[2] = target_pos[2] + 1
            map_token.setPositionSmooth(target_pos)
          end
        end
      end
    end
  end, 20)

  -- Logic to happen only on first load (not in game)
  if front_end_menu then
    -- Set the camera to focus on the character select menu
    local lookAtParams = {
      position = {0.00, 0.97, -13.00},
      pitch    = 75,
      distance = 30,
      yaw      = 0,
    }


    for _, player in ipairs(Player.getPlayers()) do
      player.lookAt(lookAtParams)
    end

    -- Display the intro to join the Discord
    local discord_textbox = getObjectFromGUID("f6ba42")
    local discord_link_obj = getObjectFromGUID("8d7365")
    if discord_textbox and discord_link_obj then
      local targetPos = front_end_menu.getPosition()
      targetPos[1] = targetPos[1] + 17
      discord_textbox.setPosition(targetPos)
      discord_textbox.TextTool.setValue("Join our Discord to find players\nor ask rules questions:")

      targetPos[3] = targetPos[3] - 2.5
      discord_link_obj.setPosition(targetPos)
      discord_link_obj.createInput({
        input_function = "discordLinkReset",
        function_owner = self,
        value          = "https://discord.gg/NfcGgegcgQ",
        position       = { 0, 0, 0 },
        rotation       = { 0, 0, 0},
        color          = {0.2, 0.2, 0.2},
        font_color     = {1, 1, 1},
        scale          = {1, 1, 1},
        width          = 4300,
        height         = 335,
        font_size      = 300,
        alignment      = 3,
      })
    end
  else
    if discord_textbox then
      discord_textbox.destruct()
    end
    if discord_link_obj then
      discord_link_obj.destruct()
    end
  end

  cacheSaveData()
end

function onPlayerConnect(player)
  -- If we're on the main menu, point them at the character select
  local front_end_menu = getObjectFromGUID("28091b")
  if front_end_menu then
    local lookAtParams = {
      position = {0.00, 0.97, -13.00},
      pitch    = 75,
      distance = 30,
      yaw      = 0,
    }
    player.lookAt(lookAtParams)
  end
end

function discordLinkReset(obj, color, input, stillEditing)
  local inputIdx = 0
  for idx, input in ipairs(obj.getInputs()) do
    if input.input_function == "discordLinkReset" then
      inputIdx = idx-1
    end
  end
  Wait.frames(function()
    obj.editInput({index=inputIdx, value="https://discord.gg/NfcGgegcgQ"})
  end, 1)
end

function onSave()
  return SAVED_GAME_DATA
end

function cacheSaveData()
  local data_to_save = {
    CARD_UPGRADE_INFO,
    MAP_TOKEN_GUIDS,
    ACTIVE_BOSS_CARDS,
    ACTIVE_ACT,
    ASCENSION_LEVEL,
    SUMMON_ASSOCIATION,
    ENEMY_HP_ASSOCIATION,
    PLAYER_TO_CHARACTER,
    CHARACTER_TO_PLAYER,
    SOLO_MODE,
    SPAWNED_BOSSES,
    IN_MERCHANT_MODE,
    ENEMY_TYPE_ASSOCIATION,
    ENEMY_INTENT_ASSOCIATION,
    ENEMY_REWARD_ASSOCIATION,
    DEPLOYED_NEOW_CARDS,
  }

  SAVED_GAME_DATA = JSON.encode(data_to_save)
end

function StartGame(args)
  broadcastToAll("Welcome to Slay the Spire: The Board Game!")

  local startingAct = 1

  ASCENSION_LEVEL = args[1]
  local playerCharacterInfo = args[2]
  SOLO_MODE = string.lower(tostring(args[3])) == "true"

  if #playerCharacterInfo > 1 then
    SOLO_MODE = false
  end

  -- Reformulate the playerCharacterInfo to be stored in a way that is usable based on specific functions
  local characterOrderSelected = {}

  local playerAreaByColor = {
    ["Pink"] = {
      ["Position"] = {12.45, 1.25, -13.18},
      ["Rotation"] = {0, 180, 0},
    },
    ["Red"] = {
      ["Position"] = {-9.68, 0.96, -13.18},
      ["Rotation"] = {0, 180, 0},
    },
    ["Green"] = {
      ["Position"] = {-27.76, 0.96, 8.34},
      ["Rotation"] = {0, 270, 0},
    },
    ["Blue"] = {
      ["Position"] = {28.26, 0.96, 5.70},
      ["Rotation"] = {0, 90, 0},
    },
  }

  -- Handle Ascension changes
  -- If ascension level is >= 1, then shuffle in the appropriate ascension event decks
  local ascension_event_decks = {
    "4ad297",   -- Act 1
    "5168e1",   -- Act 2
    "cdad92",   -- Act 3
  }
  for act_iter=1, 3 do
    local ascension_event_deck = getObjectFromGUID(ascension_event_decks[act_iter])
    if ASCENSION_LEVEL >= 3 then
      local act_event_deck_guid = ACT_COMPONENTS[act_iter]["QuestionDeck"]
      if act_event_deck_guid then
        local act_event_deck = getObjectFromGUID(act_event_deck_guid)
        if ascension_event_deck and act_event_deck then
          act_event_deck.putObject(ascension_event_deck)
        else
          broadcastToAll("WARNING: Unable to find Ascension Event deck for act " .. tostring(act_iter))
        end
      else
        broadcastToAll("WARNING: Component for Event deck for act " .. tostring(act_iter) .. " not found.")
      end
    else
      ascension_event_deck.destruct()
    end
  end

  -- If ascension level is >= 3, then replace the ascension elites
  local ascension_elite_decks = {
    "19e419",   -- Act 1
    "134723",   -- Act 2
    "a76d4d",   -- Act 3
  }
  for act_iter=1, 3 do
    local ascension_elite_deck = getObjectFromGUID(ascension_elite_decks[act_iter])
    if ASCENSION_LEVEL >= 1 then
      local original_elite_deck_guid = ACT_COMPONENTS[act_iter]["EnemyDecks"]["Elites"]["Deck"]
      if original_elite_deck_guid then
        local original_elite_deck = getObjectFromGUID(original_elite_deck_guid)
        if original_elite_deck then
          original_elite_deck.destruct()
        else
          broadcastToAll("WARNING: Unable to find and replace Ascension Elite deck for act " .. tostring(act_iter))
        end
      else
        broadcastToAll("WARNING: Unable to find Elite deck for act " .. tostring(act_iter))
      end
      ACT_COMPONENTS[act_iter]["EnemyDecks"]["Elites"]["Deck"] = ascension_elite_decks[act_iter]
    else
      ascension_elite_deck.destruct()
    end
  end

  -- If ascension level is >= 9, then replace the ascension bosses
  local ascension_boss_decks = {
    "3ee034",   -- Act 1
    "e58442",   -- Act 2
    "20ba8f",   -- Act 3
    "3076ab",   -- Act 4
  }
  for act_iter, act_info in ipairs(ACT_COMPONENTS) do
    local ascension_boss_deck = getObjectFromGUID(ascension_boss_decks[act_iter])
    if ASCENSION_LEVEL >= 9 and not PUBLIC then
      local original_boss_guid = ACT_COMPONENTS[act_iter]["BossDeck"]
      if original_boss_guid then
        local original_boss_deck = getObjectFromGUID(original_boss_guid)
        if original_boss_deck then
          original_boss_deck.destruct()
        else
          broadcastToAll("WARNING: Unable to find and replace Ascension Boss deck for act " .. tostring(act_iter))
        end
      else
        broadcastToAll("WARNING: Unable to find boss deck for act " .. tostring(act_iter))
      end
      ACT_COMPONENTS[act_iter]["BossDeck"] = ascension_boss_decks[act_iter]
    else
      if ascension_boss_deck then
        ascension_boss_deck.destruct()
      end
    end
  end

  -- Act 3 also has a summon boss deck, which 4 also references but doesn't need a copy of
  local ascension_act_3_summon_deck_guid = "7573b3"
  local ascension_act_3_summon_deck = getObjectFromGUID(ascension_act_3_summon_deck_guid)
  if ASCENSION_LEVEL >= 9 and not PUBLIC then
    local original_boss_summon_guid = ACT_COMPONENTS[3]["BossSummon"]
    if original_boss_summon_guid then
      local original_boss_summon_deck = getObjectFromGUID(original_boss_summon_guid)
      if original_boss_summon_deck then
        original_boss_summon_deck.destruct()
      else
        broadcastToAll("WARNING: Unable to find and replace Ascension Boss Summon deck for act 3")
      end
    else
      broadcastToAll("WARNING: Unable to find boss summon deck for act 3")
    end
    ACT_COMPONENTS[3]["BossSummon"] = ascension_act_3_summon_deck_guid
    ACT_COMPONENTS[4]["BossSummon"] = ascension_act_3_summon_deck_guid
  else
    if ascension_act_3_summon_deck then
      ascension_act_3_summon_deck.destruct()
    end
  end

  -- Clone the gremlins from the Act 1 summon deck to the Act 2 summon deck
  -- Clone the cultists from Act 2 summon deck to the Act 3 summon deck (used by Boss)
  local actOneSummonDeck = getObjectFromGUID(ACT_COMPONENTS[1]["EnemyDecks"]["Summons"]["Deck"])
  local actTwoSummonDeck = getObjectFromGUID(ACT_COMPONENTS[2]["EnemyDecks"]["Summons"]["Deck"])
  local actThreeSummonDeck = getObjectFromGUID(ACT_COMPONENTS[3]["EnemyDecks"]["Summons"]["Deck"])
  if actOneSummonDeck and actTwoSummonDeck and actThreeSummonDeck then
    local act1clonedDeck = actOneSummonDeck.clone()
    local act2clonedDeck = actTwoSummonDeck.clone()

    Wait.frames(function()
      local gremlinsStartingIdx = 1
      local gremlinsEndingIdx = 8
      for idx, card in ipairs(act1clonedDeck.getObjects()) do
        if idx >= gremlinsStartingIdx and idx <= gremlinsEndingIdx then
          local takenCard = act1clonedDeck.takeObject({guid=card.guid})
          Wait.frames(function()
            -- Hacky way to get this put onto the bottom of the deck. Move it under the table, then put it in the deck
            local underPos = takenCard.getPosition()
            underPos[2] = 0
            takenCard.setPosition(underPos)
            actTwoSummonDeck.putObject(takenCard)

            debugLog(DEBUG_LOG_SUMMON_ASSOCIATIONS, "[Summon] Adding cloned Gremlin with GUID " .. tostring(card.guid))
            debugLog(DEBUG_LOG_HP_ASSOCIATIONS, "[HP] Adding cloned Gremlin with GUID " .. tostring(card.guid))
          end, 1)
        end
      end

      act1clonedDeck.destruct()

      local cultistStartingIdx = 4
      local cultistEndingIdx = 7
      for idx, card in ipairs(act2clonedDeck.getObjects()) do
        if idx >= cultistStartingIdx and idx <= cultistEndingIdx then
          local takenCard = act2clonedDeck.takeObject({guid=card.guid})
          Wait.frames(function()
            -- Hacky way to get this put onto the bottom of the deck. Move it under the table, then put it in the deck
            local underPos = takenCard.getPosition()
            underPos[2] = 0
            takenCard.setPosition(underPos)
            actThreeSummonDeck.putObject(takenCard)

            debugLog(DEBUG_LOG_SUMMON_ASSOCIATIONS, "[Summon] Adding cloned Cultist with GUID " .. tostring(card.guid))
            debugLog(DEBUG_LOG_HP_ASSOCIATIONS, "[HP] Adding cloned Cultist with GUID " .. tostring(card.guid))
          end, 1)
        end
      end

      act2clonedDeck.destruct()
    end, 1)
  else
    broadcastToAll("WARNING: Could not copy Gremlins form Act 1 summon deck to Act 2 summon deck. Gremlin Leader may not summon properly...")
  end

  for selection_order_idx, characterInfo in ipairs(playerCharacterInfo) do
    table.insert(characterOrderSelected, characterInfo["Character"])

    PLAYER_TO_CHARACTER[characterInfo["Player"]] = characterInfo["Character"]
    CHARACTER_TO_PLAYER[characterInfo["Character"]] = characterInfo["Player"]

    -- Call the setup function for the selected faction
    local character_bag = getObjectFromGUID(CHARACTER_INFO[characterInfo["Character"]]["Bag"])
    local player_board = getObjectFromGUID(CHARACTER_INFO[characterInfo["Character"]]["Board"])
    if character_bag and player_board then
      player_board.setPositionSmooth(playerAreaByColor[characterInfo["Player"]]["Position"])
      player_board.setRotationSmooth(playerAreaByColor[characterInfo["Player"]]["Rotation"])
      delayedComponentLock({player_board.getGUID(), 4})

      Wait.frames(function()
        -- Give time for the board to deploy to position

        Wait.time(function()
          player_board.call("deployPlaymat")
        end, 2)

        Wait.time(function()
          player_board.call("setupBoard")

          -- Give time for the player board to setup and then move the character model to the next available slot
          Wait.time(function()
            local character_model = getObjectFromGUID(player_board.getVar("STANDEE_GUID"))
            if character_model then
              local map_obj = getActiveMapObj()
              if map_obj then
                local map_base_pos = map_obj.getPosition()
                local map_character_slot_offsets = {
                  {-2.99, 7.02},
                  {-2.99, 3.14},
                  {-2.99, -0.63},
                  {-2.99, -4.53},
                }
                character_model.setPositionSmooth({map_base_pos[1] - map_character_slot_offsets[selection_order_idx][1], map_base_pos[2] + 1, map_base_pos[3] - map_character_slot_offsets[selection_order_idx][2]})
              else
                broadcastToAll("WARNING: Unable to find map object to place characters")
              end
            end
          end, 1)
        end, 4)
      end, 1)
    else
      broadcastToAll("WARNING: Unable to find character bag and/or player board for " .. tostring(characterInfo["Character"]))
    end
  end

  -- Wait a few frames to allow for cloning of cards in decks from one to another
  Wait.frames(function()
    associateUpgrades()
    associateEnemyTypes()
    associateSummons()
    associateEnemyHP()
    associateEnemyIntent()
    associateEnemyRewards()

    if NEOW_DECK then
      NEOW_DECK.shuffle()
    else
      broadcastToAll("WARNING: Neow deck could not be found.")
    end

    deployMap(startingAct)

    -- Put away the stuff for characters not selected
    for _, character in ipairs({"Ironclad", "Watcher", "Defect", "Silent"}) do
      if CHARACTER_TO_PLAYER[character] == nil then
        local board_guid = CHARACTER_INFO[character]["Board"]
        local board = getObjectFromGUID(board_guid)
        if board then
          board.call('packAway')
        else
          broadcastToAll("WARNING: Unable to find player board for " .. tostring(character))
        end
      end
    end

    -- Now that player boards have been setup, move away the original upgrade tool that they clone
    local target_pos = {33.59, 2, 35}
    local upgrade_tool = getObjectFromGUID(UPGRADE_TOOL)
    if upgrade_tool then
      upgrade_tool.setPositionSmooth(target_pos)
    else
      broadcastToAll("WARNING: Unable to move original upgrade tool. It may get in your way...")
    end

    -- Shuffle the colorless deck
    if not PUBLIC then
      local colorless_deck = getObjectFromGUID(COLORLESS_DECK["Base"])
      if colorless_deck then
        colorless_deck.shuffle()
      else
        broadcastToAll("WARNING: Colorless base deck not found. It will not be shuffled")
      end

      -- Move the colorless upgrades to the Upgrade area
      local target_pos = {-40.25, 2, 34.55}
      local colorless_upgrade_deck = getObjectFromGUID(COLORLESS_DECK["Upgrades"])
      if colorless_upgrade_deck then
        colorless_upgrade_deck.setPositionSmooth(target_pos)
        local colorless_upgrade_text = getObjectFromGUID(COLORLESS_DECK["UpgradeText"])
        local text_target_pos = {target_pos[1], 1, target_pos[3] - 2}
        colorless_upgrade_text.setPosition(text_target_pos)
        colorless_upgrade_text.TextTool.setValue("Colorless\nUpgrade\nDeck")
      else
        broadcastToAll("WARNING: Unable to find colorless upgrade deck")
      end
    end

    -- Shuffle the items and curses
    local curses_deck = getObjectFromGUID(CURSES_DECK)
    if curses_deck then
      curses_deck.shuffle()
    else
      broadcastToAll("WARNING: Curses deck not found. It will not be shuffled")
    end
    local potions_deck = getObjectFromGUID(POTIONS_DECK)
    if potions_deck then
      potions_deck.shuffle()
    else
      broadcastToAll("WARNING: Potions deck not found. It will not be shuffled")
    end
    local relic_deck = getObjectFromGUID(RELIC_DECK)
    if relic_deck then
      relic_deck.shuffle()
    else
      broadcastToAll("WARNING: Relic deck not found. It will not be shuffled")
    end
    local boss_relic_deck = getObjectFromGUID(BOSS_RELIC_DECK)
    if boss_relic_deck then
      boss_relic_deck.shuffle()
    else
      broadcastToAll("WARNING: Boss Relic deck not found. It will not be shuffled")
    end

    -- Remove solo components if not used
    if not SOLO_MODE then
      for _, gold_guid in ipairs(SOLO_REWARDS["Gold"]) do
        local gold = getObjectFromGUID(gold_guid)
        if gold then
          gold.destruct()
        end
      end
      local kindling = getObjectFromGUID(SOLO_REWARDS["Kindling"])
      if kindling then
        kindling.destruct()
      end
    end
    local solo_text = getObjectFromGUID("ca2113")
    if solo_text then
      solo_text.destruct()
    end

    -- Move the combat die to the first encounter location
    local combat_die_target_pos = {7.75, 1.5, -2.29}
    COMBAT_DIE.setPositionSmooth(combat_die_target_pos)
    COMBAT_DIE.setRotationSmooth({270, 0, 0})

    cacheSaveData()
  end, 10)

  -- Move the discord link
  local discord_textbox = getObjectFromGUID("f6ba42")
  local discord_link_obj = getObjectFromGUID("8d7365")
  if discord_textbox and discord_link_obj then
    local targetPos = {11.11, 1.14, 30}
    discord_textbox.setPosition(targetPos)
    discord_textbox.TextTool.setValue("Join our Discord:")

    targetPos[3] = targetPos[3] - 1.6
    discord_link_obj.setPosition(targetPos)
  end
end

function nextAct()
  if NEXT_ACT_BUTTON_CLICK_COOLDOWN_END == nil or os.clock() > NEXT_ACT_BUTTON_CLICK_COOLDOWN_END then
    NEXT_ACT_BUTTON_CLICK_COOLDOWN_END = os.clock() + 2
  else
    -- Clicking the button too fast...
    return
  end

  local prior_act = ACTIVE_ACT
  local next_act = ACTIVE_ACT + 1

  -- 4th act does not deploy the map, just the final boss
  if next_act ~= 4 then
    deployMap(next_act)
  else
    ACTIVE_ACT = 4

    -- ACT 4 uses the ACT 3 map
    local mapBoard = getObjectFromGUID(ACT_COMPONENTS[prior_act]["Map"])
    if mapBoard then
      mapBoard.clearButtons()
    end

    cleanupEncounters()

    -- Return all active boss cards to the bag
    local act_bag = getObjectFromGUID(ACT_COMPONENTS[ACTIVE_ACT]["Bag"])
    if act_bag then
      if ACTIVE_BOSS_CARDS ~= nil then
        for _, boss_card_guid in ipairs(ACTIVE_BOSS_CARDS) do
          local boss_card = getObjectFromGUID(boss_card_guid)
          if boss_card then
            act_bag.putObject(boss_card)
          end
        end
      end

      -- Return the boss summon deck to the bag
      local bossSummonDeck = getObjectFromGUID(ACT_COMPONENTS[ACTIVE_ACT]["BossSummon"])
      if bossSummonDeck then
        act_bag.putObject(bossSummonDeck)
      end
    end

    -- Deploy the 4th boss face down
    local targetPos = getBossPositioning()
    local targetRot = {0, 180, 180}
    local fourthActBoss = FindAndDeployObject(ACT_COMPONENTS[ACTIVE_ACT]["BossDeck"], targetPos, targetRot)

    if fourthActBoss then
      ACTIVE_BOSS_CARDS = {fourthActBoss.guid}
    else
      broadcastToAll("WARNING: 4th Act Boss could not be found...")
      ACTIVE_BOSS_CARDS = {}
    end
    SPAWNED_BOSSES = {}

    -- Move the black pawn to the campfire spot
    local pawn_offset = {-1.03, 2, -1.39}
    local pawn_target_pos = {targetPos[1] + pawn_offset[1], targetPos[2] + pawn_offset[2], targetPos[3] + pawn_offset[3]}
    MAP_PAWN.setPositionSmooth(pawn_target_pos)

    -- Only show the boss encounter button
    hideBattleButtons()
    showMerchantButton()
    showOnlyBossButton()
  end

  cacheSaveData()
end

function recallMap()
  hideBattleButtons()
  hideMerchantButton()

  -- Pull in all the map tokens to their respective bags
  if MAP_TOKEN_GUIDS ~= nil then
    for token_type, token_type_guid_list in pairs(MAP_TOKEN_GUIDS) do
      for _, token_guid in ipairs(token_type_guid_list) do
        local token = getObjectFromGUID(token_guid)
        if token then
          local return_bag = getObjectFromGUID(MAP_TOKEN_BAGS[token_type])
          if return_bag then
            return_bag.putObject(token)
          else
            broadcastToAll("WARNING: Unable to find " .. tostring(token_type) .. " bag to return map token to.")
          end
        end
      end
    end
  end

  -- Pull out the boss deck, put the boss back into the boss deck
  if ACTIVE_BOSS_CARDS ~= nil then
    for _, boss_card_guid in ipairs(ACTIVE_BOSS_CARDS) do
      local boss_card = getObjectFromGUID(boss_card_guid)
      if boss_card then
        -- Pull the boss deck out of the act bag
        local act_bag = getObjectFromGUID(ACT_COMPONENTS[ACTIVE_ACT]["Bag"])
        if act_bag then
          local boss_deck_target_pos = boss_card.getPosition()
          boss_deck_target_pos[2] = boss_deck_target_pos[2] + 1
          local boss_deck = FindAndDeployObject(ACT_COMPONENTS[ACTIVE_ACT]["BossDeck"], boss_deck_target_pos, boss_card.getRotation())
          if boss_deck then
            Wait.frames(function()
              boss_deck.putObject(boss_card)
              Wait.frames(function()
                act_bag.putObject(boss_deck)
              end, 1)
            end, 1)
          else
            -- No boss deck actually found. Just put the boss card(s) back into the bag
            act_bag.putObject(boss_card)
          end
        end
      end
    end

    ACTIVE_BOSS_CARDS = nil
    SPAWNED_BOSSES = nil
  end


  -- Put all components back
  Wait.frames(function()
    for act, act_info in ipairs(ACT_COMPONENTS) do
      local act_bag_obj = getObjectFromGUID(act_info["Bag"])
      if act_bag_obj then
        for component_type, act_guid in pairs(act_info) do
          if component_type ~= "Bag" then
            if component_type == "EnemyDecks" then
              for enemy_deck_type, enemy_deck_info in pairs(act_guid) do
                local obj = getObjectFromGUID(enemy_deck_info["Deck"])
                if obj then
                  act_bag_obj.putObject(obj)
                end
              end
            else
              if type(act_guid) == "table" then
                -- If the table is a list
                for _, sub_guid in ipairs(act_guid) do
                  local obj = getObjectFromGUID(sub_guid)

                  if component_type == "Map" then
                    obj.clearButtons()
                  end

                  if obj then
                    act_bag_obj.putObject(obj)
                  end
                end
              else
                local obj = getObjectFromGUID(act_guid)
                if obj then
                  act_bag_obj.putObject(obj)
                end
              end
            end
          end
        end
      else
        broadcastToAll("WARNING: Unable to find bag for Act " .. tostring(act))
      end
    end
  end, 30)

  cleanupEncounters()

  -- Once encounters have been cleaned up, send the discarded enemies to the bag
  returnDiscardedEnemiesAsync(1.5)
end

function returnDiscardedEnemiesAsync(timeDelay)
  -- Early out if we have nothing to do
  if not ACTIVE_ACT then
    return
  end


  local act_bag = getObjectFromGUID(ACT_COMPONENTS[ACTIVE_ACT]["Bag"])

  function returnDiscardedEnemiesAsyncInternal()
    local discardPos = getEnemyDiscardLocation()
    local targetRot = {0, 180, 0}
    local target_scale = {2.46, 4, 3.38}

    local zone = createScriptingZone(discardPos, targetRot, target_scale)
    for _, obj in ipairs(zone.getObjects()) do
      if obj.name == "Deck" or obj.name == "DeckCustom" or obj.name == "Card" or obj.name == "CardCustom" then
        act_bag.putObject(obj)
      end
    end

    --zone.destruct()
    return 1
  end

  Wait.time(function()
    startLuaCoroutine(Global, "returnDiscardedEnemiesAsyncInternal")
  end, timeDelay)
end

function createMapButtons()
  if not IN_MERCHANT_MODE then
    showBattleButtons()
  end
  showMerchantButton()

  local mapBoard = getObjectFromGUID(ACT_COMPONENTS[ACTIVE_ACT]["Map"])
  if mapBoard then
    mapBoard.clearButtons()

    mapBoard.createButton({
      click_function = "nextAct",
      function_owner = self,
      label          = "Next Act",
      position       = {0.75, 0.1, -0.94},
      rotation       = {0, 0, 0},
      scale          = {1/mapBoard.getScale()[1], 1/mapBoard.getScale()[2], 1/mapBoard.getScale()[3]},
      width          = 2000,
      height         = 500,
      tooltip        = "",
      font_color     = {1, 1, 1},
      font_size      = 400,
      color          = "Grey"
    })
  else
    broadcastToAll("WARNING: Unable to find deployed map. Enemy Control and Next Act button will not appear")
  end
end

function deployMap(act)
  recallMap()

  ACTIVE_ACT = act

  -- Give it a second to recall everything
  Wait.time(function()
    local mapTargetPos = {-1.08, 1, 8.57}
    local mapTokenOffsets = {
      ["0b5712"] = {
        ["Black"] = {
          {-2.42, 3.53},
          {-0.1, 3.5},
          {-2.03, 0.81},
          {1.08, 1.13},
          {-0.37, -0.12},
          {1.15, -2.09},
          {-2.65, -3.65},
          {-0.22, -3.53},
        },
        ["White"] = {
          {-2.43, 2.0},
          {0.54, 2.34},
          {-0.51, 1.21},
          {-2.38, -2.33},
          {-0.58, -2.31},
          {1.12, -3.44},
          {-1.06, -4.56},
        }
      },
      ["9a9d69"] = {
        ["Black"] = {
          {-2.71, 3.42},
          {-2.86, 0.55},
          {-1.87, -0.26},
          {-0.85, 0.11},
          {0.19, -1.82},
          {1.32, -1.44},
          {-2.8, -3.24},
          {-1.31, -3.74},
        },
        ["White"] = {
          {-1.64, 1.9},
          {0.31, 0.21},
          {1.31, 0.66},
          {-2.81, -1.46},
          {-1.35, -1.75},
          {1.19, -3.22},
          {-0.89, -5.36},
        },
      },
      ["7ed624"] = {
        ["Black"] = {
          {-2.51, 3.01},
          {-1.1, 3.0},
          {1.11, 3.09},
          {-2.8, -1.07},
          {-0.97, -1.09},
          {0.16, -1.16},
          {1.27, -0.61},
          {-2.01, -2.61},
        },
        ["White"] = {
          {-2.41, 0.91},
          {-0.85, 1.14},
          {0.3, 1.03},
          {-2.28, -4.88},
          {-0.71, -4.75},
          {0.37, -3.27},
          {1.28, -2.48},
        },
      }
    }

    local actBag = getObjectFromGUID(ACT_COMPONENTS[act]["Bag"])
    if actBag then
      -- WADE TODO: This is where the map deploy failed randomly
      local mapBoard = FindAndDeployObject(ACT_COMPONENTS[act]["Map"], mapTargetPos, {0,180,0})
      delayedComponentLock({mapBoard.getGUID(), 2})

      -- Allow the board to spawn
      Wait.frames(function()
        if MAP_TOKEN_GUIDS == nil then
          MAP_TOKEN_GUIDS = {["Black"] = {}, ["White"] = {}}
        end

        Wait.time(function()
          for tokenColor, tokenBagGUID in pairs(MAP_TOKEN_BAGS) do
            local tokenBag = getObjectFromGUID(tokenBagGUID)
            tokenBag.shuffle()

            if tokenBag then
              for _, tokenOffset in ipairs(mapTokenOffsets[ACT_COMPONENTS[act]["Map"]][tokenColor]) do
                local tokenTargetPos = {mapTargetPos[1] + tokenOffset[1], mapTargetPos[2] + 1, mapTargetPos[3] + tokenOffset[2]}
                local token = tokenBag.takeObject({position=tokenTargetPos, rotation={0,180,180}})
                table.insert(MAP_TOKEN_GUIDS[tokenColor], token.guid)

                -- Once deployed, flip the map tokens
                Wait.time(function()
                  -- Sanity check that the token actually exists
                  if getObjectFromGUID(token.guid) then
                    token.flip()
                  end
                end, 2)

                -- Move the deployed character standees to the side momentarily
                for _, cur_char in pairs(PLAYER_TO_CHARACTER) do
                  local player_board = getObjectFromGUID(CHARACTER_INFO[cur_char]["Board"])
                  if player_board then
                    local character_model = getObjectFromGUID(player_board.getVar("STANDEE_GUID"))
                    if character_model then
                      local target_pos = character_model.getPosition()
                      target_pos[2] = target_pos[2] + 0.1

                      local offset_pos = {target_pos[1] + 2, target_pos[2], target_pos[3]}
                      character_model.setPositionSmooth(offset_pos)
                      character_model.setRotationSmooth({0, 180, 0})    -- Sometimes the standees fall over

                      -- Once deployed, and some additional time for intial setup, move up the deployed character standees
                      if act ~= 1 then    -- Don't do it for initial act
                        Wait.time(function()
                          character_model.setPositionSmooth(target_pos)
                          character_model.setRotationSmooth({0, 180, 0})    -- Sometimes the standees fall over
                        end, 2)
                      end
                    end
                  end
                end

                -- Add a snap point. Get the existing snap points and add to the list
                local snap_points = mapBoard.getSnapPoints()
                local map_scale = mapBoard.getScale()
                table.insert(snap_points, {position = {-tokenOffset[1] / map_scale[1], 0.0, -tokenOffset[2] / map_scale[3]}, rotation_snap = true})
                mapBoard.setSnapPoints(snap_points)
              end
            else
              broadcastToAll("WARNING: Unable to find " .. tostring(tokenColor) .. " token bag")
            end
          end

          -- Add a snap points for the character slots
          local snap_points = mapBoard.getSnapPoints()
          local map_scale = mapBoard.getScale()
          local map_character_slot_offsets = {
            {-2.99, 7.02},
            {-2.99, 3.14},
            {-2.99, -0.63},
            {-2.99, -4.53},
          }
          for _, xz_offset in ipairs(map_character_slot_offsets) do
            table.insert(snap_points, {position = {xz_offset[1] / map_scale[1], 0.0, xz_offset[2] / map_scale[3]}, rotation_snap = true})
          end
          mapBoard.setSnapPoints(snap_points)

          -- Place the player Pawn
          local pawn_offset = {-0.26, 2, -8.06}
          local pawn_target_pos = {mapTargetPos[1] + pawn_offset[1], mapTargetPos[2] + pawn_offset[2], mapTargetPos[3] + pawn_offset[3]}
          MAP_PAWN.setPositionSmooth(pawn_target_pos)

          cacheSaveData()
        end, 1)

        -- Add the button to go to the next act, if we aren't in act 3
        if act == 1 then
          showFirstEncounterButton()
        elseif act < 4 then
          createMapButtons()
        end
      end, 1)

      -- Set the Decks
      local decks_to_shuffle = {}

      --Enemy Decks
      local enemy_deck_target_pos = {
        ["Encounters"] = getEnemyDeckLocation("Encounters"),
        ["Summons"] = getEnemyDeckLocation("Summons"),
        ["Elites"] = getEnemyDeckLocation("Elites"),
      }
      local enemy_deck_target_rot = {0, 180, 180}
      for deck_type, deck_info in pairs(ACT_COMPONENTS[act]["EnemyDecks"]) do
        local deck = FindAndDeployObject(deck_info["Deck"], enemy_deck_target_pos[deck_type], enemy_deck_target_rot)
        if deck_info["Shuffle"] then
          table.insert(decks_to_shuffle, deck)
        end
      end

      -- Question Mark Deck
      local question_target_pos = {-12.26, 2, 1.44}
      local question_target_rot = {0, 180, 180}
      local deck = FindAndDeployObject(ACT_COMPONENTS[act]["QuestionDeck"], question_target_pos, question_target_rot)
      table.insert(decks_to_shuffle, deck)

      -- Boss deck. Deploy the deck first, shuffle it, draw one, then put the deck back into the bag
      local boss_deck_target_pos = {-1.68, 2, 15.16}
      local boss_target_rot = {0, 180, 180}
      local boss_deck = FindAndDeployObject(ACT_COMPONENTS[act]["BossDeck"], boss_deck_target_pos, boss_target_rot)
      Wait.frames(function()
        boss_deck.shuffle()

        local boss_card_target_pos = {boss_deck_target_pos[1], boss_deck_target_pos[2] + 1, boss_deck_target_pos[3]}

        if (ASCENSION_LEVEL >= 10 and act == 3) or DEBUG_USE_ALL_BOSSES then
          -- If at ASCENSION_LEVEL 10, deploy the deck and then remove down to 2 bosses by sending cards back to the bag
          boss_deck.setPositionSmooth(boss_card_target_pos)
          boss_deck.setRotationSmooth(boss_target_rot)

          -- Somewhat hacky, but ACTIVE_BOSS_CARDS will store a list where the 1st one is the full deck, then it'll contain all the GUIDs for the chosen cards
          ACTIVE_BOSS_CARDS = { boss_deck.getGUID() }

          -- Allow the shuffle to finish
          Wait.frames(function()
            for idx, boss_card in ipairs(boss_deck.getObjects()) do
              -- First 2 cards, keep them and add them as active boss cards
              if idx <= 2 or DEBUG_USE_ALL_BOSSES then
                table.insert(ACTIVE_BOSS_CARDS, boss_card.guid)
              else
                -- 3rd and greater cards, return it to the bag
                actBag.putObject(boss_deck.takeObject({guid=boss_card.guid}))
              end
            end
          end, 1)
        else
          local boss_card = boss_deck.takeObject({position=boss_card_target_pos, rotation=boss_target_rot})
          ACTIVE_BOSS_CARDS = {boss_card.guid}
          actBag.putObject(boss_deck)
        end

        -- Clear out any listing of bosses that have been spawned
        SPAWNED_BOSSES = {}

        cacheSaveData()
      end, 1)

      -- Deploy the boss summon deck if it exists
      if ACT_COMPONENTS[act]["BossSummon"] then
        local boss_summon_target_pos = {3.53, 5, 20.22}
        local boss_summon_target_rot = {0, 180, 180}
        local deck = FindAndDeployObject(ACT_COMPONENTS[act]["BossSummon"], boss_summon_target_pos, boss_summon_target_rot)
      end


      -- First encounter, if applicable
      if ACT_COMPONENTS[act]["FirstEncounterDeck"] ~= nil then
        local first_encounter_target_pos = {4.90, 2, -2.29}
        local first_encounter_target_rot = {0, 180, 180}
        local deck = FindAndDeployObject(ACT_COMPONENTS[act]["FirstEncounterDeck"], first_encounter_target_pos, first_encounter_target_rot)
        table.insert(decks_to_shuffle, deck)
      end

      -- Shuffle all the decks we've deployed
      Wait.frames(function()
        for _, deck in ipairs(decks_to_shuffle) do
          deck.shuffle()
        end
      end, 1)
    else
      broadcastToAll("WARNING: Unable to find bag for Act " .. tostring(act))
    end
  end, 3)
end

function initiateFirstEncounter()
  if ACT_COMPONENTS[ACTIVE_ACT]["FirstEncounterDeck"] ~= nil then
    spawnFirstEncounter()
  end

  createMapButtons()

  -- Move all deployed Neow cards off to the side
  for _, neow_guid in ipairs(DEPLOYED_NEOW_CARDS) do
    local neow_card = getObjectFromGUID(neow_guid)
    if neow_card then
      neow_card.setPositionSmooth({-15.81, 1.5, 17.11})
      neow_card.setRotationSmooth({0, 180, 0})
    end
  end
end

function cleanupEncounters()
  hideRemoveEnemiesButton()

  local discardTargetPos = getEnemyDiscardLocation()
  local discardTargetRot = {0, 180, 0}

  -- Discard all the enemies
  local enemyList = getEnemies()
  for _, enemyCard in ipairs(enemyList) do
    enemyCard.setPositionSmooth(discardTargetPos)
    enemyCard.setRotationSmooth(discardTargetRot)
  end

  -- Discard all boss revealed enemies in the boss area
  local revealedBossEnemyList = getDeployedEnemiesInBossArea()
  for _, revealedBossCard in ipairs(revealedBossEnemyList) do
    revealedBossCard.setPositionSmooth(discardTargetPos)
    revealedBossCard.setRotationSmooth(discardTargetRot)
  end

  -- Return HP Cubes back to the HP Bag
  local hpCubes = getHPCubes()
  if hpCubes and #hpCubes > 0 then
    if HP_CUBE_BAG then
      for _, hpCube in ipairs(hpCubes) do
        HP_CUBE_BAG.putObject(hpCube)
      end
    else
      broadcastToAll("WARNING: Could not find HP token bag...")
    end
  end

  -- Return the Elite/Boss HP Board. Confirm that no-one deleted them (whyyyyyy????)
  if getObjectFromGUID(HP_BOARD["Board"].guid) ~= nil then
    HP_BOARD["Board"].setPositionSmooth({15.57, 1.25, 13.36})
  else
    broadcastToAll("WARNING: Enemy HP Board could not be found.")
  end
  if getObjectFromGUID(HP_BOARD["TensCube"].guid) ~= nil then
    HP_BOARD["TensCube"].setPositionSmooth({15.34, 2.25, 14.48})
  else
    -- Spawn a new Tens Cube
    HP_BOARD["TensCube"] = HP_CUBE_BAG.takeObject({position={15.34, 2.25, 14.48}})
  end
  if getObjectFromGUID(HP_BOARD["OnesCube"].guid) ~= nil then
    HP_BOARD["OnesCube"].setPositionSmooth({15.80, 2.25, 14.48})
  else
    -- Spawn a new Ones Cube
    HP_BOARD["OnesCube"] = HP_CUBE_BAG.takeObject({position={15.80, 2.25, 14.48}})
  end
end

-- Checks if a specific card has already been deployed
function CheckCanBeSummoned(potential_summon_guid)
  local containingDeckGUID = FindContainerWithCard(potential_summon_guid)
  if containingDeckGUID ~= nil then
    -- Check if the containing object is within the play area
    for _, playAreaObj in ipairs(ENEMY_ZONE.getObjects()) do
      if containingDeckGUID == playAreaObj.getGUID() then
        return false
      end
    end

    local containingDeck = getObjectFromGUID(containingDeckGUID)

    -- Check if the object is not in the summon deck, but is just next to the summons deck, meaning we are probably deploying it
    local summonDeck = getObjectFromGUID(ACT_COMPONENTS[ACTIVE_ACT]["EnemyDecks"]["Summons"]["Deck"])
    local bossSummonDeck = getObjectFromGUID(ACT_COMPONENTS[ACTIVE_ACT]["BossSummon"])
    if containingDeckGUID ~= ACT_COMPONENTS[ACTIVE_ACT]["EnemyDecks"]["Summons"]["Deck"] and
       PosWithinTolerance(containingDeck, summonDeck.getPosition(), 0.5) then
      return false
    elseif ACT_COMPONENTS[ACTIVE_ACT]["BossSummon"] ~= nil and containingDeckGUID ~= ACT_COMPONENTS[ACTIVE_ACT]["BossSummon"] and
           PosWithinTolerance(containingDeck, bossSummonDeck.getPosition(), 0.5) then
      return false
    else
      return true
    end
  end

  return false
end

function FindAndAssociateEnemyDeckAsync(type, shuffle, callback, callback_params)
  function FindAndAssociateEnemyDeckAsyncInternal()
    local targetPos = getEnemyDeckLocation(type)
    local targetRot = {0, 180, 180}
    local target_scale = {2.46, 4, 3.38}

    local zone = createScriptingZone(targetPos, targetRot, target_scale)
    local combined_deck = nil
    for _, obj in ipairs(zone.getObjects()) do
      if obj.name == "Deck" or obj.name == "DeckCustom" then
        if combined_deck == nil then
          combined_deck = obj
        else
          broadcastToAll("WARNING: Multiple decks found when recombining " ..tostring(type) .. " deck. Deck may not behave correctly")
        end
      end
    end

    if combined_deck then
      -- Re-associate the enemy deck for other scripts
      ACT_COMPONENTS[ACTIVE_ACT]["EnemyDecks"][type]["Deck"] = combined_deck.getGUID()

      if shuffle then
        combined_deck.shuffle()
      end

      if callback ~= nil then
        Wait.frames(function()
          callback(callback_params)
        end, 1)
      end
    end

    zone.destruct()
    return 1
  end

  startLuaCoroutine(Global, "FindAndAssociateEnemyDeckAsyncInternal")
end

-- Re-combines all cards from a particular enemy type into a deck again
-- You can specify a callback which will be called after the deck has been recombined
function RecombineDeck(type, shuffle, callback, callback_params)
  local targetPos = getEnemyDeckLocation(type)
  local targetRot = {0, 180, 180}

  for _, enemyCardGUID in ipairs(ENEMY_TYPE_ASSOCIATION[ACTIVE_ACT][type]) do
    local enemyCard = FindAndDeployObject(enemyCardGUID, targetPos, targetRot)
    if not enemyCard then
      broadcastToAll("WARNING: Unable to locate card " .. tostring(enemyCardGUID))
    end
  end

  Wait.time(function()
    FindAndAssociateEnemyDeckAsync(type, shuffle, callback, callback_params)
  end, 2)
end

function SpawnSummon(lane, enemy_slot, summon_guid, face_down)
  local map_obj = getActiveMapObj()
  if map_obj == nil then
    broadcastToAll("WARNING: Unable to find base position for first encounter spawns")
    return
  end
  local map_base_pos = map_obj.getPosition()

  local target_rot = {0, 180, 0}
  if face_down ~= nil and face_down then
    target_rot[3] = 180
  end

  local summon_target_pos = {map_base_pos[1] + getStartingCardHorizontalOffset() + (enemy_slot * getEnemyHorizontalSpacing()), map_base_pos[2] + 0.5, map_base_pos[3] + getLaneVerticalOffset(lane)}
  local enemy_found = FindAndDeployObject(summon_guid, summon_target_pos, target_rot, true) -- Only deploy from decks
  if enemy_found ~= nil then
    setEnemyHP(enemy_found.guid, summon_target_pos)
    setEnemyIntent(enemy_found.guid, summon_target_pos)
    return true
  else
    broadcastToAll("WARNING: Unable to spawn summon with GUID " .. tostring(summon_guid))
    return false
  end
end

-- First encounters and base encounters behave the same. 1 enemy spawned per player on the left, any summons to the right
-- Will return False if we have run out of deck, otherwise will return true
function spawnEncountersFromDeck(deckObj)
  local numPlayers = getNumPlayers()

  local remainingDeckCards = getNumCardsInDeck(deckObj)

  local map_obj = getActiveMapObj()
  if map_obj == nil then
    broadcastToAll("WARNING: Unable to find base position for encounter spawns")
    return
  end
  local map_base_pos = map_obj.getPosition()

  for lane_idx=1, numPlayers do
    if deckObj then
      local target_pos = {map_base_pos[1] + getStartingCardHorizontalOffset(), map_base_pos[2] + 0.5, map_base_pos[3] + getLaneVerticalOffset(lane_idx)}
      local spawned_enemy = nil
      if deckObj.name == "Deck" or deckObj.name == "DeckCustom" then
        spawned_enemy = deckObj.takeObject({position=target_pos, rotation={0, 180, 0}})
      elseif deckObj.name == "Card" or deckObj.name == "CardCustom" then
        spawned_enemy = deckObj
        spawned_enemy.setPositionSmooth(target_pos)
        spawned_enemy.setRotationSmooth({0, 180, 0})
        deckObj = nil
      end
      setEnemyHP(spawned_enemy.guid, target_pos)
      setEnemyIntent(spawned_enemy.guid, target_pos)

      -- Check if there are any summons for the spawned enemies
      if SUMMON_ASSOCIATION[spawned_enemy.guid] ~= nil then
        debugLog(DEBUG_LOG_SUMMON_ASSOCIATIONS, "[Summons] Summon detected for enemy " .. tostring(spawned_enemy.guid))

        -- Check summon type
        if SUMMON_ASSOCIATION[spawned_enemy.guid]["Flavor"] == nil then
          debugLog(DEBUG_LOG_SUMMON_ASSOCIATIONS, "[Summons] Standard Summon" .. tostring(spawned_enemy.guid))

          -- outer loop is for total enemies summoned
          for summon_idx, potential_enemy_guid_list in ipairs(SUMMON_ASSOCIATION[spawned_enemy.guid]["Summons"]) do
            -- inner loop is for finding an appropriate spawn
            for __, potential_enemy_guid in ipairs(potential_enemy_guid_list) do
              debugLog(DEBUG_LOG_SUMMON_ASSOCIATIONS, "[Summons] Attempting to summon " .. tostring(potential_enemy_guid))

              if CheckCanBeSummoned(potential_enemy_guid) then
                debugLog(DEBUG_LOG_SUMMON_ASSOCIATIONS, "[Summons] Summoning " .. tostring(potential_enemy_guid) .. " to lane " .. tostring(lane_idx) .. " and slot " .. tostring(summon_idx))

                SpawnSummon(lane_idx, summon_idx, potential_enemy_guid)
                break   -- Default behavior lists options for the summons and we just summon one
              end
            end
          end
        else
          -- Special flavor rules...
          if SUMMON_ASSOCIATION[spawned_enemy.guid]["Flavor"]["Random"] ~= nil then
            local num_enemies_to_summon = SUMMON_ASSOCIATION[spawned_enemy.guid]["Flavor"]["Random"]
            debugLog(DEBUG_LOG_SUMMON_ASSOCIATIONS, "[Summons] Random summon: " .. tostring(num_enemies_to_summon))

            -- Iterate over each list, and create a list of unsummoned/available summons from that list
            for summon_idx, potential_enemy_guid_list in ipairs(SUMMON_ASSOCIATION[spawned_enemy.guid]["Summons"]) do
              local available_summon_guids = {}
              for __, potential_enemy_guid in ipairs(potential_enemy_guid_list) do
                if CheckCanBeSummoned(potential_enemy_guid) then
                  debugLog(DEBUG_LOG_SUMMON_ASSOCIATIONS, "[Summons] Available GUID added to random summon: " .. tostring(potential_enemy_guid))

                  table.insert(available_summon_guids, potential_enemy_guid)
                end
              end

              if #available_summon_guids < num_enemies_to_summon then
                broadcastToAll("WARNING: Could not find enough available enemies to summon from list. Not all enemies will be properly summoned.")
                num_enemies_to_summon = #available_summon_guids
              end

              -- Randomly select up to the random number specified from the available list
              for summon_idx=1, num_enemies_to_summon do
                local enemy_guid = table.remove(available_summon_guids, math.random(#available_summon_guids))

                debugLog(DEBUG_LOG_SUMMON_ASSOCIATIONS, "[Summons] Summoning GUID: " .. tostring(enemy_guid))

                local face_down = false
                if SUMMON_ASSOCIATION[spawned_enemy.guid]["Flavor"]["Face Down"] ~= nil and SUMMON_ASSOCIATION[spawned_enemy.guid]["Flavor"]["Face Down"] then
                  face_down = true
                end
                SpawnSummon(lane_idx, summon_idx, enemy_guid, face_down)
              end
            end
          end
        end
      end
    else
      broadcastToAll("WARNING: Unable to locate encounter deck. Encounters will not be spawned")
    end
  end

  -- Since we draw all at the same time, if multiple players sometimes the .remainder field doesn't work properly
  return deckObj == nil or remainingDeckCards <= numPlayers
end

function spawnFirstEncounter()
  cleanupEncounters()
  showRemoveEnemiesButton()

  local first_encounter_deck = getObjectFromGUID(ACT_COMPONENTS[ACTIVE_ACT]["FirstEncounterDeck"])
  if first_encounter_deck then
    local outOfCards = spawnEncountersFromDeck(first_encounter_deck)
    if outOfCards then
      ACT_COMPONENTS[ACTIVE_ACT]["FirstEncounterDeck"] = nil
    elseif first_encounter_deck.remainder then
      ACT_COMPONENTS[ACTIVE_ACT]["FirstEncounterDeck"] = first_encounter_deck.remainder.guid
    end
  else
    broadcastToAll("First Encounter Deck has been exhausted. No enemies will be spawned")
  end

  -- Send the remainder of the first encounter deck to the discard pile. Re-grab it in case the deck has run out or changed
  local first_encounter_deck = getObjectFromGUID(ACT_COMPONENTS[ACTIVE_ACT]["FirstEncounterDeck"])
  if first_encounter_deck then
    first_encounter_deck.setPositionSmooth(getEnemyDiscardLocation())
    first_encounter_deck.setRotationSmooth({0, 180, 0})
  end
end

function spawnBaseEncounter()
  cleanupEncounters()
  showRemoveEnemiesButton()

  local encounters_deck = getObjectFromGUID(ACT_COMPONENTS[ACTIVE_ACT]["EnemyDecks"]["Encounters"]["Deck"])
  if encounters_deck then
    local remainingDeckCards = getNumCardsInDeck(encounters_deck)
    if remainingDeckCards >= getNumPlayers() then
      local outOfCards = spawnEncountersFromDeck(encounters_deck)
      if outOfCards then
        ACT_COMPONENTS[ACTIVE_ACT]["EnemyDecks"]["Encounters"]["Deck"] = nil
      elseif encounters_deck.remainder then
        ACT_COMPONENTS[ACTIVE_ACT]["EnemyDecks"]["Encounters"]["Deck"] = encounters_deck.remainder.guid
      end
    else
      broadcastToAll("Encounter Deck does not have enough cards for player count. Re-combining encounter deck, shuffling, and re-attempting spawn")
      RecombineDeck("Encounters", true, spawnBaseEncounter)
    end
  else
    broadcastToAll("Encounter Deck has been exhausted. Re-combining encounter deck, shuffling, and re-attempting spawn")
    RecombineDeck("Encounters", true, spawnBaseEncounter)
  end
end

-- Elites spawn a single elite in lane 1, but summons get spawned first
function spawnElite()
  cleanupEncounters()
  showRemoveEnemiesButton()

  local numPlayers = getNumPlayers()

  local map_obj = getActiveMapObj()
  if map_obj == nil then
    broadcastToAll("WARNING: Unable to find base position for Elite spawns")
    return
  end
  local map_base_pos = map_obj.getPosition()

  -- Track the number of summons in each lane so we know where to place them
  local summonsPerLane = {0, 0, 0, 0}

  local deckObj = getObjectFromGUID(ACT_COMPONENTS[ACTIVE_ACT]["EnemyDecks"]["Elites"]["Deck"])
  if deckObj then
    -- get the first elite's GUID
    local elite_guid = nil
    if deckObj.name == "Deck" or deckObj.name == "DeckCustom" then
      elite_guid = deckObj.getObjects()[1].guid
    else
      elite_guid = deckObj.getGUID()
    end

    -- Check if there are any summons for the spawned enemies
    if SUMMON_ASSOCIATION[elite_guid] ~= nil then
      debugLog(DEBUG_LOG_SUMMON_ASSOCIATIONS, "[Summons] Summon detected for Elite " .. tostring(elite_guid))

      -- Check summon type
      if SUMMON_ASSOCIATION[elite_guid]["Flavor"] == nil then
        broadcastToAll("WARNING: Unsupported summon type for Elite. No summon flavor detected")
      else
        -- Special flavor rules...
        if SUMMON_ASSOCIATION[elite_guid]["Flavor"]["Type"] == "Random" then
          local num_enemies_to_summon = SUMMON_ASSOCIATION[elite_guid]["Flavor"]["Per Player"]
          debugLog(DEBUG_LOG_SUMMON_ASSOCIATIONS, "[Summons] Random summon per player: " .. tostring(num_enemies_to_summon))

          -- Iterate over each player, each list, and create a list of unsummoned/available summons from that list
          for lane_idx = 1, numPlayers do
            for summon_idx, potential_enemy_guid_list in ipairs(SUMMON_ASSOCIATION[elite_guid]["Summons"]) do
              local available_summon_guids = {}
              for __, potential_enemy_guid in ipairs(potential_enemy_guid_list) do
                if CheckCanBeSummoned(potential_enemy_guid) then
                  debugLog(DEBUG_LOG_SUMMON_ASSOCIATIONS, "[Summons] Available GUID added to random summon: " .. tostring(potential_enemy_guid))

                  table.insert(available_summon_guids, potential_enemy_guid)
                end
              end

              if #available_summon_guids < num_enemies_to_summon then
                broadcastToAll("WARNING: Could not find enough available enemies to summon from list. Not all enemies will be properly summoned.")
                num_enemies_to_summon = #available_summon_guids
              end

              -- Randomly select up to the random number specified from the available list
              for summon_idx=1, num_enemies_to_summon do
                local enemy_guid = table.remove(available_summon_guids, math.random(#available_summon_guids))

                debugLog(DEBUG_LOG_SUMMON_ASSOCIATIONS, "[Summons] Summoning GUID: " .. tostring(enemy_guid))

                summonsPerLane[lane_idx] = summonsPerLane[lane_idx] + 1

                local face_down = false
                if SUMMON_ASSOCIATION[elite_guid]["Flavor"]["Face Down"] ~= nil and SUMMON_ASSOCIATION[elite_guid]["Flavor"]["Face Down"] then
                  face_down = true
                end
                SpawnSummon(lane_idx, summonsPerLane[lane_idx]-1, enemy_guid, face_down)
              end
            end
          end
        elseif SUMMON_ASSOCIATION[elite_guid]["Flavor"]["Type"] == "Alternating" then
          local num_enemies_to_summon = SUMMON_ASSOCIATION[elite_guid]["Flavor"]["Per Player"]
          local include_elite = SUMMON_ASSOCIATION[elite_guid]["Flavor"]["Include Elite"]

          debugLog(DEBUG_LOG_SUMMON_ASSOCIATIONS, "[Summons] Alternating summon per player: " .. tostring(num_enemies_to_summon) .. ", " ..tostring(include_elite))

          -- Create an available list for each enemy type
          local available_summon_guids = {}
          for type_idx, potential_enemy_guid_list in ipairs(SUMMON_ASSOCIATION[elite_guid]["Summons"]) do
            table.insert(available_summon_guids, {})

            for __, potential_enemy_guid in ipairs(potential_enemy_guid_list) do
              if CheckCanBeSummoned(potential_enemy_guid) then
                debugLog(DEBUG_LOG_SUMMON_ASSOCIATIONS, "[Summons] Available GUID added to summon for enemy type " .. tostring(type_idx) .. ": " .. tostring(potential_enemy_guid))

                table.insert(available_summon_guids[type_idx], potential_enemy_guid)
              end
            end
          end

          -- For each player, cycle through each enemy type and adding summons until we reach that lane's max
          local cur_enemy_type_idx = 1
          local total_summoned = 0
          for lane_idx = 1, numPlayers do
            local summoned_enemies_this_lane = num_enemies_to_summon
            if lane_idx == 1 and include_elite then
              summoned_enemies_this_lane = summoned_enemies_this_lane - 1
            end

            for summon_idx=1, summoned_enemies_this_lane do
              if #available_summon_guids[cur_enemy_type_idx] > 0 then
                local enemy_guid = table.remove(available_summon_guids[cur_enemy_type_idx])
                debugLog(DEBUG_LOG_SUMMON_ASSOCIATIONS, "[Summons] Summoning GUID: " .. tostring(enemy_guid))

                summonsPerLane[lane_idx] = summonsPerLane[lane_idx] + 1

                local face_down = false
                if SUMMON_ASSOCIATION[elite_guid]["Flavor"]["Face Down"] ~= nil and SUMMON_ASSOCIATION[elite_guid]["Flavor"]["Face Down"] then
                  face_down = true
                end
                SpawnSummon(lane_idx, summonsPerLane[lane_idx]-1, enemy_guid, face_down)

                cur_enemy_type_idx = cur_enemy_type_idx + 1
                if cur_enemy_type_idx > #available_summon_guids then
                  cur_enemy_type_idx = 1
                end
              else
                broadcastToAll("WARNING: Could not find enough available enemies to summon from list. Not all enemies will be properly summoned.")
              end
            end
          end
        end
      end
    end

    -- Now actually spawn the elite to the right of the bottom lane
    local elite_target_pos = {map_base_pos[1] + getStartingCardHorizontalOffset() + (summonsPerLane[1] * getEnemyHorizontalSpacing()), map_base_pos[2] + 0.5, map_base_pos[3] + getLaneVerticalOffset(1)}
    local spawned_enemy = nil
    if deckObj.name == "Deck" or deckObj.name == "DeckCustom" then
      spawned_enemy = deckObj.takeObject({position=elite_target_pos, rotation={0, 180, 0}})
      if deckObj.remainder then
        ACT_COMPONENTS[ACTIVE_ACT]["EnemyDecks"]["Elites"]["Deck"] = deckObj.remainder.guid
      end
    elseif deckObj.name == "Card" or deckObj.name == "CardCustom" then
      spawned_enemy = deckObj
      spawned_enemy.setPositionSmooth(elite_target_pos)
      spawned_enemy.setRotationSmooth({0, 180, 0})
      ACT_COMPONENTS[ACTIVE_ACT]["EnemyDecks"]["Elites"]["Deck"] = nil
    end

    setEnemyHP(spawned_enemy.guid, elite_target_pos, true)
    setEnemyIntent(spawned_enemy.guid, elite_target_pos)
  else
    broadcastToAll("Elite Deck has been exhausted. Re-combining Elite deck, shuffling, and re-attempting spawn")
    RecombineDeck("Elites", true, spawnElite)
  end
end

function spawnBoss()
  cleanupEncounters()
  showRemoveEnemiesButton()

  local numPlayers = getNumPlayers()

  local map_obj = getActiveMapObj()
  if map_obj == nil then
    broadcastToAll("WARNING: Unable to find base position for Boss spawns")
    return
  end
  local map_base_pos = map_obj.getPosition()

  -- Track the number of summons in each lane so we know where to place them
  local summonsPerLane = {0, 0, 0, 0}

  -- Find an appropriate boss card
  local spawned_boss = nil
  for _, boss_card_guid in ipairs(ACTIVE_BOSS_CARDS) do
    -- Confirm we haven't already spawned this boss
    local alreadySpawned = false
    for _, spawned_guid in ipairs(SPAWNED_BOSSES) do
      if boss_card_guid == spawned_guid then
        alreadySpawned = true
      end
    end

    if not alreadySpawned then
      local potential_boss_card_obj = getObjectFromGUID(boss_card_guid)
      if potential_boss_card_obj then
        if potential_boss_card_obj.name == "Deck" or potential_boss_card_obj.name == "DeckCustom" then
          spawned_boss = potential_boss_card_obj.takeObject()
        elseif potential_boss_card_obj.name == "Card" or potential_boss_card_obj.name == "CardCustom" then
          spawned_boss = potential_boss_card_obj
        end

        -- Boss has been found
        table.insert(SPAWNED_BOSSES, spawned_boss.guid)
        break
      end
    end
  end

  if spawned_boss == nil then
    if #SPAWNED_BOSSES > 0 then
      broadcastToAll("WARNING: Boss Deck has been exhausted. Respawning prior boss...")

      -- See if the boss card is just around...
      local boss_guid = SPAWNED_BOSSES[1]
      spawned_boss = getObjectFromGUID(boss_guid)
      if not spawned_boss then
        local deck_guid = FindContainerWithCard(boss_guid)
        local deck = getObjectFromGUID(deck_guid)
        if deck then
          spawned_boss = deck.takeObject({guid=boss_guid})
        end
      end
    else
      broadcastToAll("WARNING: Boss could not be found. Boss will not be spawned.")
    end
  end


  -- get the first boss's GUID
  local boss_guid = spawned_boss.guid

  -- Track a list of boss summons to do, as these use the position of the boss
  local boss_summon_guids = {}

  -- Check if there are any summons for the spawned enemies
  if SUMMON_ASSOCIATION[boss_guid] ~= nil then
    debugLog(DEBUG_LOG_SUMMON_ASSOCIATIONS, "[Summons] Summon detected for Boss " .. tostring(boss_guid))

    -- Check summon type
    if SUMMON_ASSOCIATION[boss_guid]["Flavor"] == nil then
      debugLog(DEBUG_LOG_SUMMON_ASSOCIATIONS, "[Summons] Boss 'Standard' Summon" .. tostring(boss_guid))

      -- Iterate over normal "Summons" and "Boss Summons"
      local summon_info = {
        ["Summons"] = {
          ["Boss Positioning"] = false,
        },
        ["Boss Summons"] = {
          ["Boss Positioning"] = true,
        }
      }
      for summon_type, summon_type_info in pairs(summon_info) do
        debugLog(DEBUG_LOG_SUMMON_ASSOCIATIONS, "[Summons] Processing summon type " .. tostring(summon_type) .. ": " ..tostring(#SUMMON_ASSOCIATION[boss_guid][summon_type]))

        -- outer loop is for total enemies summoned
        for summon_idx, potential_enemy_guid_list in ipairs(SUMMON_ASSOCIATION[boss_guid][summon_type]) do
          -- inner loop is for finding an appropriate spawn
          for __, potential_enemy_guid in ipairs(potential_enemy_guid_list) do
            debugLog(DEBUG_LOG_SUMMON_ASSOCIATIONS, "[Summons] Attempting to summon " .. tostring(potential_enemy_guid))

            if summon_type_info["Boss Positioning"] then
              debugLog(DEBUG_LOG_SUMMON_ASSOCIATIONS, "[Summons] Summoning " .. tostring(potential_enemy_guid) .. " as a boss summon")

              table.insert(boss_summon_guids, potential_enemy_guid)
            else
              if CheckCanBeSummoned(potential_enemy_guid, true) then
                debugLog(DEBUG_LOG_SUMMON_ASSOCIATIONS, "[Summons] Summoning " .. tostring(potential_enemy_guid) .. " to lane " .. tostring(lane_idx) .. " and slot " .. tostring(summon_idx))

                summonsPerLane[lane_idx] = summonsPerLane[lane_idx] + 1
                SpawnSummon(lane_idx, summon_idx, potential_enemy_guid)
                break   -- Default behavior lists options for the summons and we just summon one
              end
            end
          end
        end
      end
    else
      -- Special flavor rules...
      if SUMMON_ASSOCIATION[boss_guid]["Flavor"]["Type"] == "Random" then
        local num_enemies_to_summon = SUMMON_ASSOCIATION[boss_guid]["Flavor"]["Per Player"]
        debugLog(DEBUG_LOG_SUMMON_ASSOCIATIONS, "[Summons] Random summon per player: " .. tostring(num_enemies_to_summon))

        -- Iterate over each player, each list, and create a list of unsummoned/available summons from that list
        for lane_idx = 1, numPlayers do
          for summon_idx, potential_enemy_guid_list in ipairs(SUMMON_ASSOCIATION[boss_guid]["Summons"]) do
            local available_summon_guids = {}
            for __, potential_enemy_guid in ipairs(potential_enemy_guid_list) do
              if CheckCanBeSummoned(potential_enemy_guid, true) then
                debugLog(DEBUG_LOG_SUMMON_ASSOCIATIONS, "[Summons] Available GUID added to random summon: " .. tostring(potential_enemy_guid))

                table.insert(available_summon_guids, potential_enemy_guid)
              end
            end

            if #available_summon_guids < num_enemies_to_summon then
              broadcastToAll("WARNING: Could not find enough available enemies to summon from list. Not all enemies will be properly summoned.")
              num_enemies_to_summon = #available_summon_guids
            end

            -- Randomly select up to the random number specified from the available list
            for summon_idx=1, num_enemies_to_summon do
              local enemy_guid = table.remove(available_summon_guids, math.random(#available_summon_guids))

              debugLog(DEBUG_LOG_SUMMON_ASSOCIATIONS, "[Summons] Summoning GUID: " .. tostring(enemy_guid))

              summonsPerLane[lane_idx] = summonsPerLane[lane_idx] + 1

              local face_down = false
              if SUMMON_ASSOCIATION[boss_guid]["Flavor"]["Face Down"] ~= nil and SUMMON_ASSOCIATION[boss_guid]["Flavor"]["Face Down"] then
                face_down = true
              end
              SpawnSummon(lane_idx, summonsPerLane[lane_idx]-1, enemy_guid, face_down)
            end
          end
        end
      end

      -- Check for boss summons. Outer loop is for total enemies summoned
      for summon_idx, potential_enemy_guid_list in ipairs(SUMMON_ASSOCIATION[boss_guid]["Boss Summons"]) do
        -- inner loop is for finding an appropriate spawn
        for __, potential_enemy_guid in ipairs(potential_enemy_guid_list) do
          debugLog(DEBUG_LOG_SUMMON_ASSOCIATIONS, "[Summons] Summoning " .. tostring(potential_enemy_guid) .. " as a boss summon")

          table.insert(boss_summon_guids, potential_enemy_guid)
        end
      end
    end
  end

  -- Position the boss now that we know how many summons
  local boss_target_pos = getBossPositioning()
  local numSummons = math.max(summonsPerLane[1], 1)   -- Adjust positioning for summons, minimum assumption of 1 summon
  if #boss_summon_guids > 0 and numSummons < 2 then
    numSummons = 2
  end
  boss_target_pos[1] = boss_target_pos[1] + (getEnemyHorizontalSpacing() * numSummons)
  spawned_boss.setPositionSmooth(boss_target_pos)
  spawned_boss.setRotationSmooth({0, 180, 0})

  setEnemyHP(boss_guid, boss_target_pos, true, true)
  setEnemyIntent(boss_guid, boss_target_pos)

  if #boss_summon_guids > 0 then
    -- Summon the boss summons. Determine the variables based on the flavor metadata first
    local boss_summon_pos_offset = {-5.34, 0, 0}
    local boss_summon_target_rot = {0, 180, 0}
    local deploy_cubes = true
    if SUMMON_ASSOCIATION[boss_guid]["Flavor"] ~= nil then
      -- Offset positioning should always exist / is required
      if SUMMON_ASSOCIATION[boss_guid]["Flavor"]["Boss Summon Offset"] ~= nil then
        boss_summon_pos_offset = SUMMON_ASSOCIATION[boss_guid]["Flavor"]["Boss Summon Offset"]
      else
        broadcastToAll("WARNING: Boss summon offset could not be found. Boss Summon's positioning may be incorrect")
      end

      -- Facedown check (optional)
      if SUMMON_ASSOCIATION[boss_guid]["Flavor"]["Boss Summon Face Down"] ~= nil and SUMMON_ASSOCIATION[boss_guid]["Flavor"]["Boss Summon Face Down"] then
        boss_summon_target_rot[3] = 180
      end

      -- Cube deployment (optional)
      if SUMMON_ASSOCIATION[boss_guid]["Flavor"]["Boss Summon Deploy Cubes"] ~= nil then
        deploy_cubes = SUMMON_ASSOCIATION[boss_guid]["Flavor"]["Boss Summon Deploy Cubes"]
      end
    else
      broadcastToAll("WARNING: Boss summon metadata could not be found. Boss Summon summoning procedure may be incorrect")
    end

    local boss_summon_target_pos = {boss_target_pos[1] + boss_summon_pos_offset[1], boss_target_pos[2] + boss_summon_pos_offset[2], boss_target_pos[3] + boss_summon_pos_offset[3]}
    for _, boss_summon_guid in ipairs(boss_summon_guids) do
      local enemy_found = FindAndDeployObject(boss_summon_guid, boss_summon_target_pos, boss_summon_target_rot)

      if ACT_COMPONENTS[ACTIVE_ACT]["BossSummon"] ~= nil then
        local boss_summon_deck = getObjectFromGUID(ACT_COMPONENTS[ACTIVE_ACT]["BossSummon"])
        if (boss_summon_deck.name == "Deck" or boss_summon_deck.name == "DeckCustom") and boss_summon_deck.remainder then
          ACT_COMPONENTS[ACTIVE_ACT]["BossSummon"] = boss_summon_deck.remainder.guid
        end

        if deploy_cubes then
          setEnemyHP(boss_summon_guid, boss_summon_target_pos, false, true)
          setEnemyIntent(boss_summon_guid, boss_summon_target_pos)
        end
      end
    end
  end

  --We've adjusted the spawned bosses, so we need to invalidate the save
  cacheSaveData()
end

function setEnemyHP(enemyGUID, deploy_pos, useHPBoard, isBoss)
  if HP_CUBE_BAG then
    if ENEMY_HP_ASSOCIATION[enemyGUID] then
      local starting_HP = ENEMY_HP_ASSOCIATION[enemyGUID]
      if useHPBoard == nil or not useHPBoard or starting_HP <= 10 then
        local tensXOffset = -1.13
        local tensYStart = 0.74

        -- Some enemies have more or fewer rewards, so set the tensYStart as appropriate
        if getEnemyNumRewards(enemyGUID) == 0 then
          tensYStart = 1.1
        elseif getEnemyNumRewards(enemyGUID) == 3 then
          tensYStart = 0.43
        end

        local verticalSpacing = 0.3325
        local onesXOffset = 1.13
        local onesYStart = 1.49

        if isBoss then
          tensXOffset = 1.99
          tensYStart = 1.49
          verticalSpacing = 0.3325
          onesXOffset = 2.4
          onesYStart = 1.49

          -- Just for funsies, place an HP cube on the player count HP used
          local target_pos = {deploy_pos[1] - 2.17, deploy_pos[2] + 1, deploy_pos[3] + 1.48 - (0.293 * (getNumPlayers() - 1))}

          HP_CUBE_BAG.takeObject({position=target_pos})
        end

        while starting_HP > 100 do
          local target_pos = {deploy_pos[1] + tensXOffset, deploy_pos[2] + 2 + ((math.floor(starting_HP / 100) / 2)), deploy_pos[3] + tensYStart - (verticalSpacing * 9)}
          HP_CUBE_BAG.takeObject({position=target_pos})

          starting_HP = starting_HP - 100
        end

        if starting_HP > 10 then
          local tensHealth = math.floor(starting_HP / 10)
          local target_pos = {deploy_pos[1] + tensXOffset, deploy_pos[2] + 1, deploy_pos[3] + tensYStart - (verticalSpacing * (tensHealth - 1))}
          HP_CUBE_BAG.takeObject({position=target_pos})

          -- Update the remaining to be just the 1s position. Adjust by 1 as the units with >10 health have a "0" HP marker as well
          starting_HP = (starting_HP % 10) + 1
        end

        local target_pos = {deploy_pos[1] + onesXOffset, deploy_pos[2] + 1, deploy_pos[3] + onesYStart - (verticalSpacing * (starting_HP - 1))}
        HP_CUBE_BAG.takeObject({position=target_pos})
      else
        local board_horizontal_spacing = getEnemyHorizontalSpacing() * 0.75
        if isBoss then
          board_horizontal_spacing = 3.25
        end

        local hundredsHP = math.floor(starting_HP / 100)
        local tensHP = math.floor((starting_HP % 100) / 10)
        local onesHP = starting_HP % 10
        local board_target_pos = {deploy_pos[1] + board_horizontal_spacing, deploy_pos[2] + 0.25, deploy_pos[3]}
        local hundreds_target_pos = {board_target_pos[1] - getHPBoardXOffset(), board_target_pos[2] + 1, board_target_pos[3] + (getHPBoardYOffset(10))}
        local tens_target_pos = {board_target_pos[1] - getHPBoardXOffset(), board_target_pos[2] + 1, board_target_pos[3] + (getHPBoardYOffset(tensHP))}
        local ones_target_pos = {board_target_pos[1] + getHPBoardXOffset(), board_target_pos[2] + 1, board_target_pos[3] + (getHPBoardYOffset(onesHP+1))}   -- The "ones" side has a "0" slot

        if getObjectFromGUID(HP_BOARD["Board"].guid) ~= nil then
          HP_BOARD["Board"].setPositionSmooth(board_target_pos)
          HP_BOARD["Board"].setRotationSmooth({0, 180, 0})
        else
          broadcastToAll("WARNING: Enemy HP Board could not be found.")
        end
        if tensHP > 0 then
          -- There are cases where we have zero "tens" HP, such as HP 105. In these cases, don't move the cube
          if getObjectFromGUID(HP_BOARD["TensCube"].guid) ~= nil then
            HP_BOARD["TensCube"].setPositionSmooth(tens_target_pos)
          else
            HP_BOARD["TensCube"] = HP_CUBE_BAG.takeObject({position=tens_target_pos})
          end
        end

        if getObjectFromGUID(HP_BOARD["OnesCube"].guid) ~= nil then
          HP_BOARD["OnesCube"].setPositionSmooth(ones_target_pos)
        else
          HP_BOARD["OnesCube"] = HP_CUBE_BAG.takeObject({position=ones_target_pos})
        end

        for i=1, hundredsHP do
          local cur_target_pos = {hundreds_target_pos[1], hundreds_target_pos[2] + (0.75*i), hundreds_target_pos[3]}
          HP_CUBE_BAG.takeObject({position=cur_target_pos})
        end

        -- Just for funsies, place an HP cube on the player count HP used
        local target_pos = {deploy_pos[1] + 1.01, deploy_pos[2] + 1, deploy_pos[3] + 1.16 - (0.293 * (getNumPlayers() - 1))}
        if isBoss then
          target_pos = {deploy_pos[1] + 2.23, deploy_pos[2] + 1, deploy_pos[3] + 1.48 - (0.293 * (getNumPlayers() - 1))}
        end

        HP_CUBE_BAG.takeObject({position=target_pos})
      end
    else
      broadcastToAll("WARNING: Could not find starting enemy HP for enemy " .. tostring(enemyGUID))
    end
  else
    broadcastToAll("WARNING: Could not find HP token bag...")
  end
end

function setEnemyIntent(enemyGUID, deploy_pos)
  if HP_CUBE_BAG then
    if ENEMY_INTENT_ASSOCIATION[enemyGUID] and #ENEMY_INTENT_ASSOCIATION[enemyGUID] > 0 then
      local intent_offset = ENEMY_INTENT_ASSOCIATION[enemyGUID]
      if type(intent_offset[1]) == "table" then
        -- Corrupt Heart has multiple cubes, so iterate over them all
        debugLog(DEBUG_LOG_INTENT_ASSOCIATIONS, "[Intent] " .. tostring(enemyGUID) .. " has multiple intents set")
        for _, cur_intent in ipairs(intent_offset) do
          debugLog(DEBUG_LOG_INTENT_ASSOCIATIONS, "  [Intent] : " .. tostring(cur_intent[1]) .. ", " .. tostring(cur_intent[2]))
          local xOffset = cur_intent[1]
          local zOffset = cur_intent[2]

          local target_pos = {deploy_pos[1] + xOffset, deploy_pos[2] + 1, deploy_pos[3] + zOffset}
          HP_CUBE_BAG.takeObject({position=target_pos})
        end
      else
        debugLog(DEBUG_LOG_INTENT_ASSOCIATIONS, "[Intent] " .. tostring(enemyGUID) .. " has intent set to: " .. tostring(intent_offset[1]) .. ", " .. tostring(intent_offset[2]))
        local xOffset = intent_offset[1]
        local zOffset = intent_offset[2]

        local target_pos = {deploy_pos[1] + xOffset, deploy_pos[2] + 1, deploy_pos[3] + zOffset}
        HP_CUBE_BAG.takeObject({position=target_pos})
      end
    end
  else
    broadcastToAll("WARNING: Could not find HP token bag...")
  end
end

function toggleMerchant()
  if IN_MERCHANT_MODE then
    endMerchantMode()
  else
    startMerchantMode()
  end
end

function startMerchantMode()
  hideBattleButtons()
  if not MERCHANT["Board"] then
    broadcastToAll("WARNING: Unable to start Merchant interaction due to missing Merchant board")
    return
  end

  IN_MERCHANT_MODE = true
  showMerchantButton()

  MERCHANT["Board"].call("startMerchantMode")

  cacheSaveData()
end

function endMerchantMode()
  hideMerchantButton()

  if not MERCHANT["Board"] then
    broadcastToAll("WARNING: Unable to start Merchant interaction due to missing Merchant board")
    return
  end

  MERCHANT["Board"].call("endMerchantMode")

  Wait.time(function()
    IN_MERCHANT_MODE = false
    showMerchantButton()

    cacheSaveData()

    showBattleButtons()
  end, 1)
end

function associateComponents()
  CHARACTER_INFO = {
    ["Ironclad"] = {
      ["Board"] = "63f2c4",
      ["Bag"] = "a16f5f"
    },
    ["Watcher"] = {
      ["Board"] = "60b3de",
      ["Bag"] = "e91d62"
    },
    ["Defect"] = {
      ["Board"] = "b293d2",
      ["Bag"] = "50ea04"
    },
    ["Silent"] = {
      ["Board"] = "9ee996",
      ["Bag"] = "92ba85"
    }
  }
  MAP_TOKEN_BAGS = {["Black"] = "b4d7e7", ["White"] = "021340"}
  ACT_COMPONENTS = {
    { -- ACT 1
      ["Bag"] = "8d449a",
      ["Map"] = "0b5712",
      ["EnemyDecks"] = {
        ["Encounters"] = {
          ["Deck"] = "4d2484",
          ["Shuffle"] = true,
        },
        ["Summons"] = {
          ["Deck"] = "66fbad",
          ["Shuffle"] = false,
        },
        ["Elites"] = {
          ["Deck"] = "ff80bf",
          ["Shuffle"] = true
        },
      },
      ["QuestionDeck"] = "49d436",
      ["FirstEncounterDeck"] = "e21cbf",
      ["BossDeck"] = "589beb",
    },
    { -- ACT 2
      ["Bag"] = "1cf2a7",
      ["Map"] = "9a9d69",
      ["EnemyDecks"] = {
        ["Encounters"] = {
          ["Deck"] = "edac78",
          ["Shuffle"] = true,
        },
        ["Summons"] = {
          ["Deck"] = "485ed8",
          ["Shuffle"] = false,
        },
        ["Elites"] = {
          ["Deck"] = "e6e270",
          ["Shuffle"] = true,
        },
      },
      ["QuestionDeck"] = "770899",
      ["BossDeck"] = "eca962",
    },
    { -- ACT 3
      ["Bag"] = "189af1",
      ["Map"] = "7ed624",
      ["EnemyDecks"] = {
        ["Encounters"] = {
          ["Deck"] = "87f221",
          ["Shuffle"] = true,
        },
        ["Summons"] = {
          ["Deck"] = "e49dd1",
          ["Shuffle"] = false,
        },
        ["Elites"] = {
          ["Deck"] = "b1c504",
          ["Shuffle"] = true,
        },
      },
      ["QuestionDeck"] = "335d47",
      ["BossDeck"] = "2a2330",
      ["BossSummon"] = "c233e1"
    },
    { -- ACT 4
      -- 4th act uses same "components" as act 3
      ["Bag"] = "189af1",
      ["Map"] = "7ed624",
      ["EnemyDecks"] = {
        ["Encounters"] = {
          ["Deck"] = nil,
          ["Shuffle"] = false,
        },
        ["Summons"] = {
          ["Deck"] = nil,
          ["Shuffle"] = false,
        },
        ["Elites"] = {
          ["Deck"] = nil,
          ["Shuffle"] = false,
        },
      },
      ["QuestionDeck"] = "335d47",
      ["BossDeck"] = "dd3174",
      ["BossSummon"] = "c233e1"
    },
  }

  MAP_PAWN = getObjectFromGUID("d4e0e6")

  NEOW_DECK = getObjectFromGUID("938861")

  ASCENDERS_BANE_DECK = getObjectFromGUID("5b8f21")
  SOLO_REWARDS = {
    ["Gold"] = {"5fd055", "14c55c"},
    ["Kindling"] = "01030c",
  }

  COLORLESS_DECK = {
    ["Base"] = "80fcb6",
    ["Upgrades"] = "7f7cc9",
    ["UpgradeText"] = "3c0393",
    ["ColorlessText"] = "a544b1",
  }

  UPGRADE_TOOL = "9e5ba3"

  CURSES_DECK = "9fc22a"
  POTIONS_DECK = "72a869"
  RELIC_DECK = "0f8234"
  BOSS_RELIC_DECK = "d6b384"

  HP_CUBE_BAG = getObjectFromGUID("163aa7")

  HP_BOARD = {
    ["Board"] = getObjectFromGUID("edb7f9"),
    ["TensCube"] = getObjectFromGUID("bb7b28"),
    ["OnesCube"] = getObjectFromGUID("d670ed"),
  }
  CreateHPBoardSnapPoints()

  -- Ascension replacements for loaded games
  if ASCENSION_LEVEL ~= nil then
    if ASCENSION_LEVEL >= 1 then
      ACT_COMPONENTS[1]["EnemyDecks"]["Elites"]["Deck"] = "19e419"
      ACT_COMPONENTS[2]["EnemyDecks"]["Elites"]["Deck"] = "134723"
      ACT_COMPONENTS[3]["EnemyDecks"]["Elites"]["Deck"] = "a76d4d"
    end
    if ASCENSION_LEVEL >= 9 and not PUBLIC then
      ACT_COMPONENTS[1]["BossDeck"] = "3ee034"
      ACT_COMPONENTS[2]["BossDeck"] = "e58442"
      ACT_COMPONENTS[3]["BossDeck"] = "20ba8f"
      ACT_COMPONENTS[4]["BossDeck"] = "3076ab"

      ACT_COMPONENTS[3]["BossSummon"] = "7573b3"
      ACT_COMPONENTS[4]["BossSummon"] = "7573b3"
    end
  end

  ENEMY_ZONE = getObjectFromGUID("79a172")
  BOSS_ENEMY_ZONE = getObjectFromGUID("c2a19f")
  COMBAT_DIE = getObjectFromGUID("efe880")

  -- Encounter buttons
  BATTLE_BUTTONS = {
    ["Encounter"] = getObjectFromGUID("1551d9"),
    ["Elite"] = getObjectFromGUID("696cff"),
    ["Boss"] = getObjectFromGUID("6b2bdb"),
  }

  REMOVE_ENEMIES_BUTTON = getObjectFromGUID('18c61a')

  -- Merchant Button
  MERCHANT = {
    ["Button"] = getObjectFromGUID("703d7f"),
    ["Board"] = getObjectFromGUID("7257b4"),
  }

  if PUBLIC then
    removeStretchGoals()
  end
end

function removeStretchGoals()
  local baseColorlessDeck = getObjectFromGUID(COLORLESS_DECK["Base"])
  local upgradeColorlessDeck = getObjectFromGUID(COLORLESS_DECK["Upgrades"])
  local colorlessText = getObjectFromGUID(COLORLESS_DECK["ColorlessText"])
  local upgradeText = getObjectFromGUID(COLORLESS_DECK["UpgradeText"])
  if baseColorlessDeck then
    baseColorlessDeck.destruct()
  end
  if upgradeColorlessDeck then
    upgradeColorlessDeck.destruct()
  end
  if colorlessText then
    colorlessText.destruct()
  end
  if upgradeText then
    upgradeText.destruct()
  end

  ascension_boss_components = {
    "3ee034",
    "e58442",
    "20ba8f",
    "3076ab",
    "7573b3",
    "7573b3"
  }
  for _, guid in ipairs(ascension_boss_components) do
    local obj = getObjectFromGUID(guid)
    if obj then
      obj.destruct()
    end
  end
end

-- Hide the UI Button and also move the button to the side as these buttons have collision
function hideBattleButtons()
  BATTLE_BUTTONS["Elite"].UI.setAttribute("1stEncounter", "active", "false")
  local offset = 0
  for button_type, button_obj in pairs(BATTLE_BUTTONS) do
    button_obj.UI.setAttribute("Button", "active", "false")
    button_obj.setPosition({9 + offset, 1.5, 16.9})
    offset = offset + 1
  end

  hideRemoveEnemiesButton()
end

function showBattleButtons()
  -- Hide the 1st encounter button
  BATTLE_BUTTONS["Elite"].UI.setAttribute("1stEncounter", "active", "false")

  local button_pos = {
    ["Encounter"] = {2.15, 1.17, -1.26},
    ["Elite"] = {0.0, 1.17, -1.26},
    ["Boss"] = {-4.29, 1.16, -1.26}
  }

  for button_type, button_obj in pairs(BATTLE_BUTTONS) do
    button_obj.setPosition(button_pos[button_type])
    button_obj.UI.setAttribute("Button", "active", "true")
  end
end

function showFirstEncounterButton()
  BATTLE_BUTTONS["Elite"].setPosition({-1.13, 1.17, -1.26})
  BATTLE_BUTTONS["Elite"].UI.setAttribute("1stEncounter", "active", "true")
end

function showOnlyBossButton()
  BATTLE_BUTTONS["Boss"].setPosition({-4.29, 1.17, -1.26})
  BATTLE_BUTTONS["Boss"].UI.setAttribute("Button", "active", "true")
end

function hideMerchantButton()
  MERCHANT["Button"].setPosition({8, 1.5, 16.9})
  MERCHANT["Button"].UI.setAttribute("Button", "active", "false")
end

function showMerchantButton()
  if not IN_MERCHANT_MODE then
    MERCHANT["Button"].setPosition({-2.14, 1.14, -1.26})
    MERCHANT["Button"].UI.setAttribute("Button", "tooltip", "Enter Merchant Mode")
  else
    MERCHANT["Button"].setPosition({-7.79, 1.14, -3.78})
    MERCHANT["Button"].UI.setAttribute("Button", "tooltip", "Exit Merchant Mode")
  end
  MERCHANT["Button"].UI.setAttribute("Button", "active", "true")
end

function hideRemoveEnemiesButton()
  REMOVE_ENEMIES_BUTTON.UI.setAttribute("Button", "active", "false")
  REMOVE_ENEMIES_BUTTON.setPosition({15, 1.5, 16.9})
end

function showRemoveEnemiesButton()
  REMOVE_ENEMIES_BUTTON.UI.setAttribute("Button", "active", "true")
  REMOVE_ENEMIES_BUTTON.setPosition({-1.08, 1.15, -2.77})
end

-- Associate the deck GUIDs with eachother
function StoreCardAssociation(baseCardGuid, baseDeckGuid, upgradeCardGuid, upgradeDeckGuid)
  CARD_UPGRADE_INFO[baseCardGuid] = {}
  CARD_UPGRADE_INFO[baseCardGuid]["Related_Card"] = upgradeCardGuid
  CARD_UPGRADE_INFO[baseCardGuid]["Source_Deck"] = baseDeckGuid
  CARD_UPGRADE_INFO[baseCardGuid]["Card_Type"] = "Base"

  CARD_UPGRADE_INFO[upgradeCardGuid] = {}
  CARD_UPGRADE_INFO[upgradeCardGuid]["Related_Card"] = baseCardGuid
  CARD_UPGRADE_INFO[upgradeCardGuid]["Source_Deck"] = upgradeDeckGuid
  CARD_UPGRADE_INFO[upgradeCardGuid]["Card_Type"] = "Upgrade"
end

function associateUpgrades()
  CARD_UPGRADE_INFO = {}

  for _, character in ipairs({"Ironclad", "Watcher", "Silent", "Defect"}) do
    debugLog(DEBUG_LOG_UPGRADE_ASSOCIATIONS, "Associating upgrades for " .. tostring(character))
    local player_board = getObjectFromGUID(CHARACTER_INFO[character]["Board"])
    local deck_info = player_board.getTable("DECK_GUIDS")

    -- All the associated decks
    local starter_deck = nil
    local starter_upgrades = nil
    local basic_deck = nil
    local basic_upgrades = nil
    local rare_deck = nil
    local rare_upgrades = nil

    -- Get all the cards
    local starter_cards = {}
    local starter_upgrade_cards = {}
    local basic_cards = {}
    local basic_upgrade_cards = {}
    local rare_cards = {}
    local rare_upgrade_cards = {}

    if deck_info["Starter"]["Base"] ~= nil then
      starter_deck = getObjectFromGUID(deck_info["Starter"]["Base"])
      if starter_deck then
        starter_cards = starter_deck.getObjects()
      end
    end
    if deck_info["Starter"]["Upgrades"] ~= nil then
      starter_upgrades = getObjectFromGUID(deck_info["Starter"]["Upgrades"])
      if starter_upgrades then
        starter_upgrade_cards = starter_upgrades.getObjects()
      end
    end
    if deck_info["Rewards"]["Base"] ~= nil then
      basic_deck = getObjectFromGUID(deck_info["Rewards"]["Base"])
      if basic_deck then
        basic_cards = basic_deck.getObjects()
      end
    end
    if deck_info["Rewards"]["Upgrades"] ~= nil then
      basic_upgrades = getObjectFromGUID(deck_info["Rewards"]["Upgrades"])
      if basic_upgrades then
        basic_upgrade_cards = basic_upgrades.getObjects()
      end
    end
    if deck_info["Rare"]["Base"] ~= nil then
      rare_deck = getObjectFromGUID(deck_info["Rare"]["Base"])
      if rare_deck then
        rare_cards = rare_deck.getObjects()
      end
    end
    if deck_info["Rare"]["Upgrades"] ~= nil then
      rare_upgrades = getObjectFromGUID(deck_info["Rare"]["Upgrades"])
      if rare_upgrades then
        rare_upgrade_cards = rare_upgrades.getObjects()
      end
    end

    -- Validate that the upgrade deck is smaller than the basic deck
    if #starter_upgrade_cards > #starter_cards then
      broadcastToAll("WARNING: Starter deck is smaller than its associated upgrade deck for " .. tostring(character))
    end
    if #basic_upgrade_cards > #basic_cards then
      broadcastToAll("WARNING: Reward deck is smaller than its associated upgrade deck for " .. tostring(character))
    end
    if #rare_upgrade_cards > #rare_cards then
      broadcastToAll("WARNING: Rare deck is smaller than its associated upgrade deck for " .. tostring(character))
    end

    for i=1, #starter_upgrade_cards do
      if i <= #starter_cards then
        StoreCardAssociation(starter_cards[i].guid, starter_deck.getGUID(), starter_upgrade_cards[i].guid, starter_upgrades.getGUID())
        debugLog(DEBUG_LOG_UPGRADE_ASSOCIATIONS, "Associating Starter: " ..tostring(starter_cards[i].guid) .. " <=> " ..tostring(starter_upgrade_cards[i].guid))
      end
    end
    for i=1, #basic_upgrade_cards do
      if i <= #basic_cards then
        StoreCardAssociation(basic_cards[i].guid, basic_deck.getGUID(), basic_upgrade_cards[i].guid, basic_upgrades.getGUID())
        debugLog(DEBUG_LOG_UPGRADE_ASSOCIATIONS, "Associating Basic: " ..tostring(basic_cards[i].guid) .. " <=> " ..tostring(basic_upgrade_cards[i].guid))
      end
    end
    for i=1, #rare_upgrade_cards do
      if i <= #rare_cards then
        StoreCardAssociation(rare_cards[i].guid, rare_deck.getGUID(), rare_upgrade_cards[i].guid, rare_upgrades.getGUID())
        debugLog(DEBUG_LOG_UPGRADE_ASSOCIATIONS, "Associating Rare: " ..tostring(rare_cards[i].guid) .. " <=> " ..tostring(rare_upgrade_cards[i].guid))
      end
    end
  end

  if not PUBLIC then
    -- Associate colorless deck
    local baseColorlessDeck = getObjectFromGUID(COLORLESS_DECK["Base"])
    local upgradeColorlessDeck = getObjectFromGUID(COLORLESS_DECK["Upgrades"])
    if baseColorlessDeck and upgradeColorlessDeck then
      local base_colorless_cards = baseColorlessDeck.getObjects()
      local upgrade_colorless_cards = upgradeColorlessDeck.getObjects()
      if #upgrade_colorless_cards > #base_colorless_cards then
        broadcastToAll("WARNING: Colorless is smaller than its associated upgrade deck")
      end
      for i=1, #upgrade_colorless_cards do
        if i <= #base_colorless_cards then
          StoreCardAssociation(base_colorless_cards[i].guid, baseColorlessDeck.getGUID(), upgrade_colorless_cards[i].guid, upgradeColorlessDeck.getGUID())
          debugLog(DEBUG_LOG_UPGRADE_ASSOCIATIONS, "Associating Colorless: " ..tostring(base_colorless_cards[i].guid) .. " <=> " ..tostring(upgrade_colorless_cards[i].guid))
        end
      end
    else
      broadcastToAll("WARNING: Colorless deck or Colorless upgrade deck not found. Could not associate colorless cards for upgrade tool.")
    end
  end

  cacheSaveData()
end

function associateEnemyTypes()
  -- Creates a list of GUIDs for each enemy type (elite vs encounter) for each act
  ENEMY_TYPE_ASSOCIATION = {}
  for act, act_info in ipairs(ACT_COMPONENTS) do
    ENEMY_TYPE_ASSOCIATION[act] = {}
    for enemy_type, enemy_info in pairs(act_info["EnemyDecks"]) do
      ENEMY_TYPE_ASSOCIATION[act][enemy_type] = {}
      if enemy_info["Deck"] then    -- ACT 4 does not have decks
        local enemyDeck = getObjectFromGUID(enemy_info["Deck"])
        if enemyDeck then
          for _, card in ipairs(enemyDeck.getObjects()) do
            table.insert(ENEMY_TYPE_ASSOCIATION[act][enemy_type], card.guid)
          end
        else
          broadcastToAll("WARNING: Unable to create enemy association for Act " ..tostring(act) .. " " .. tostring(enemy_type) .. ". Deck could not be found.")
        end
      end
    end
  end
end

function associateSummons()
  -- This list links the card number in the deck to the card number in the summon deck
  starter_encounter_summon_links = {
    -- ACT 1
    {
      {},
      {},
      {  -- Red Louse
        {9, 10}   -- Green Louse
      },
      {  -- Small Slime
        {28, 29, 30, 31}  -- Acid Slime
      },
    },
    {
      -- ACT 2
    },
    {
      -- ACT 3
    },
    {
      -- ACT 4
    },
  }

  -- Encounter associations
  encounter_summon_links = {
    -- ACT 1
    {
      {     -- Cultist
        {32, 33, 34, 35},   -- Spike Slime
      },
      {     -- Cultist
        {9, 10},  -- Green Louse
      },
      {     -- Fungi Beast
        {12},   -- Fungi Beast
      },
      {     -- Small Slime
        {28, 29, 30, 31},   -- Acid Slime
        {32, 33, 34, 35},   -- Spike Slime
      },
      {     -- Red Louse
        {9, 10},  -- Green Louse
        {11},   -- Red Louse
      },
      {},   -- Large slime
      {     -- Sneaky Gremlin
        {1, 2, 3, 4, 5, 6, 7, 8},   -- Gremlins
        ["Flavor"] = {
          ["Random"] = 3,
        },
      },
      {     -- Mad Gremlin
        {1, 2, 3, 4, 5, 6, 7, 8},   -- Gremlins
        ["Flavor"] = {
          ["Random"] = 3,
        }
      },
      {},   -- Blue Slaver
      {},   -- Red Slaver
      {},   -- Looter
      {},   -- Jaw Worm
    },
    {
      -- ACT 2
      {},   -- Snecko
      {},   -- Snake Plant
      {},   -- Spheric Guardian
      {     -- Byrd
        {1},    -- Byrd
        {2, 3}, -- Byrd
      },
      {     -- Cultist
        {4, 5},  -- Cultist
        {6, 7},  -- Cultist
      },
      {},   -- Shelled Parasite
      {     -- Chosen
        {2, 3}, -- Byrd
      },
      {     -- Chosen
        {4, 5},  -- Cultist
      },
      {     -- Looter
        {20, 21},  -- Mugger
      },
      {     -- Looter
        {20, 21},  -- Mugger
      },
      {     -- Centurion
        {22, 23},  -- Mystic
      },
      {     -- Centurion
        {22, 23},  -- Mystic
      },
    },
    {
      -- ACT 3
      {     -- Jaw Worm
        {13}, -- Jaw Worm
        {14}, -- Jaw Worm
      },
      {},   -- Spire Growth
      {     -- Exploder
        {18},     -- Repulsor
        {16, 17}, -- Spiker
      },
      {     -- Repulsor
        {15},     -- Exploder
        {16, 17}, -- Spiker
      },
      {},   -- Orb Walker
      {},   -- Orb Walker
      {},   -- Transient
      {},   -- The Maw
      {},   -- Writhing Mass
    },
    {
      -- ACT 4
    }
  }

  -- Elites
  elite_summon_links = {
    -- ACT 1
    {
      {},   -- Lagavulin
      {},   -- Gremlin Nob
      {     -- Sentries
        {13, 15, 17, 19, 21, 23},
        {14, 16, 18, 20, 22},
        ["Flavor"] = {
          ["Per Player"] = 3,
          ["Include Elite"] = true,
          ["Type"] = "Alternating",
        },
      },
    },
    {
      -- ACT 2
      {},   -- Book of Stabbing
      {     -- Gremlin Leader
        {32, 33, 34, 35, 36, 37, 38, 39},   -- Gremlins, cloned from Act 1's summon deck programmatically
        ["Flavor"] = {
          ["Per Player"] = 2,
          ["Type"] = "Random",
        },
      },
      {     -- Taskmaster
        {24, 25, 26, 27},   -- Blue Slaver
        {28, 29, 30, 31},   -- Red Slaver
        ["Flavor"] = {
          ["Per Player"] = 1,
          ["Type"] = "Random",
        },
      },
    },
    {
      -- ACT 3
      {},  -- Giant Head
      {},  -- Nemesis
      {},  -- Retomancer
    },
    {
      -- ACT 4
    }
  }

  ascension_elite_summon_links = {
    -- ACT 1
    {
      {},   -- Gremlin Nob
      {},   -- Lagavulin
      {
        {13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23},   -- Sentries
        ["Flavor"] = {
          ["Per Player"] = 3,
          ["Include Elite"] = true,
          ["Type"] = "Alternating",
        },
      }
    },
    {
      -- ACT 2
      {},   -- Book of Stabbing
      {     -- Gremlin Leader
        {32, 33, 34, 35, 36, 37, 38, 39},   -- Gremlins, cloned from Act 1's summon deck programmatically
        ["Flavor"] = {
          ["Per Player"] = 2,
          ["Type"] = "Random",
        },
      },
      {     -- Taskmaster
        {24, 25, 26, 27},   -- Blue Slaver
        {28, 29, 30, 31},   -- Red Slaver
        ["Flavor"] = {
          ["Per Player"] = 1,
          ["Type"] = "Random",
        },
      },
    },
    {
      -- ACT 3
      {},  -- Giant Head
      {},  -- Nemesis
      {},  -- Retomancer
    },
    {
      -- ACT 4
    }
  }

  -- Bosses
  boss_summon_links = {
    {
      -- ACT 1
      {}, -- Slime Boss
      {}, -- Hexaghost
      {}, -- The Guardian
    },
    {
      -- ACT 2
      { -- Bronze Automaton
        {8, 9, 10, 11},   -- Bronze Orb
        ["Flavor"] = {
          ["Per Player"] = 1,
          ["Type"] = "Random",
        },
      },
      { -- The Collector
        {12, 13, 14, 15, 16, 17, 18, 19},   -- Torchhead
        ["Flavor"] = {
          ["Per Player"] = 2,
          ["Type"] = "Random",
          ["Face Down"] = true,
        }
      },
      {}, -- The Champ
    },
    {
      -- ACT 3
      { -- Awakened One
        {9, 10, 11, 12, 19, 20, 21, 22},   -- Cultist
        ["Flavor"] = {
          ["Per Player"] = 2,
          ["Type"] = "Random",
          ["Boss Summon Offset"] = {0, 0, -3.81},
          ["Boss Summon Face Down"] = true,
          ["Boss Summon Deploy Cubes"] = false,
        },
        ["Boss Summon"] = {{1}},    -- Awakened One: Phase 2
      },
      { -- Donu
        ["Flavor"] = {
          ["Boss Summon Offset"] = {-5.34, 0, 0},
        },
        ["Boss Summon"] = {{2}},    -- Deca
      },
      {}, -- Time Eater
    },
    {
      -- ACT 4
      {},
    },
  }

  ascension_boss_summon_links = {
    {
      -- ACT 1
      {}, -- Slime Boss
      {}, -- Hexaghost
      {}, -- The Guardian
    },
    {
      -- ACT 2
      { -- Bronze Automaton
        {8, 9, 10, 11},   -- Bronze Orb
        ["Flavor"] = {
          ["Per Player"] = 1,
          ["Type"] = "Random",
        },
      },
      { -- The Collector
        {12, 13, 14, 15, 16, 17, 18, 19},   -- Torchhead
        ["Flavor"] = {
          ["Per Player"] = 2,
          ["Type"] = "Random",
          ["Face Down"] = true,
        }
      },
      {}, -- The Champ
    },
    {
      -- ACT 3
      { -- Awakened One
        {9, 10, 11, 12, 19, 20, 21, 22},   -- Cultist
        ["Flavor"] = {
          ["Per Player"] = 2,
          ["Type"] = "Random",
          ["Boss Summon Offset"] = {0, 0, -3.81},
          ["Boss Summon Face Down"] = true,
          ["Boss Summon Deploy Cubes"] = false,
        },
        ["Boss Summon"] = {{1}},    -- Awakened One: Phase 2
      },
      { -- Donu
        ["Flavor"] = {
          ["Boss Summon Offset"] = {-5.34, 0, 0},
        },
        ["Boss Summon"] = {{2}},    -- Deca
      },
      {}, -- Time Eater
    },
    {
      -- ACT 4
      {},
    },
  }

  -- Associates some starter enemy cards with a list of appropriate cards that they are attempting to summon. Create GUID associations.
  -- These lists can list multiple options in case one was already spawned
  SUMMON_ASSOCIATION = {}
  for act, act_info in ipairs(ACT_COMPONENTS) do
    -- Sanity checks...
    local firstEncounterDeckGuid = act_info["FirstEncounterDeck"]
    local firstEncounterDeck = getObjectFromGUID(firstEncounterDeckGuid)
    if firstEncounterDeckGuid and not firstEncounterDeck then
      broadcastToAll("WARNING: Unable to find first encounter deck for act " .. tostring(act) .. ". Summon association not set.")
      return
    end

    local encounterDeckGuid = act_info["EnemyDecks"]["Encounters"]["Deck"]
    local encounterDeck = getObjectFromGUID(encounterDeckGuid)
    if encounterDeckGuid and not encounterDeck then
      broadcastToAll("WARNING: Unable to find Encounters deck for act " .. tostring(act) .. ". Summon association not set.")
      return
    end

    local summonDeckGuid = act_info["EnemyDecks"]["Summons"]["Deck"]
    local summonDeck = getObjectFromGUID(summonDeckGuid)
    if summonDeckGuid and not summonDeck then
      broadcastToAll("WARNING: Unable to find summon deck for act " .. tostring(act) .. ". Summon association not set.")
      return
    end

    -- The elite deck will be either the main or the ascended one by this point
    local eliteDeckGuid = act_info["EnemyDecks"]["Elites"]["Deck"]
    local eliteDeck = getObjectFromGUID(eliteDeckGuid)
    if eliteDeckGuid and not eliteDeck then
      broadcastToAll("WARNING: Unable to find elite deck for act " .. tostring(act) .. ". Summon association not set.")
      return
    end

    -- The boss deck will be either the main or the ascended one by this point
    local bossDeckGuid = act_info["BossDeck"]
    local bossDeck = getObjectFromGUID(bossDeckGuid)
    local bossSummonDeckGuid = act_info["BossSummon"]
    local bossSummonDeck = getObjectFromGUID(bossSummonDeckGuid)
    if (bossDeckGuid and not bossDeck) or (bossSummonDeckGuid and not bossSummonDeck) then
      broadcastToAll("WARNING: Unable to find Boss or Boss Summon deck for act " .. tostring(act) .. ". Summon association not set.")
      return
    end

    -- create a list of all the objects within each deck. Not all acts will have all the decks
    local starter_enemies = {}
    if firstEncounterDeck ~= nil then
      starter_enemies = firstEncounterDeck.getObjects()
    end

    local encounter_enemies = {}
    if encounterDeck ~= nil then
      encounter_enemies = encounterDeck.getObjects()
    end

    local summon_enemies = {}
    if summonDeck ~= nil then
      summon_enemies = summonDeck.getObjects()
    end

    local elite_enemies = {}
    if eliteDeck ~= nil then
      elite_enemies = eliteDeck.getObjects()
    end

    local boss_enemies = {}
    if bossDeck ~= nil then
      if bossDeck.name == "Deck" or bossDeck.name == "DeckCustom" then
        boss_enemies = bossDeck.getObjects()
      elseif bossDeck.name == "Card" or bossDeck.name == "CardCustom" then
        boss_enemies = {bossDeck}
      end
    end

    local boss_summon_enemies = {}
    if bossSummonDeck ~= nil then
      boss_summon_enemies = bossSummonDeck.getObjects()
    end


    -- Process each list
    local elite_summon_links_used = elite_summon_links
    if ASCENSION_LEVEL >= 1 then
      elite_summon_links_used = ascension_elite_summon_links
    end
    local boss_summon_links_used = boss_summon_links
    if ASCENSION_LEVEL >= 9 and not PUBLIC then
      boss_summon_links_used = ascension_boss_summon_links
    end
    local listsToProcess = {
      {
        ["type"] = "1st Encounter",
        ["links"] = starter_encounter_summon_links,
        ["enemies"] = starter_enemies,
      },
      {
        ["type"] = "Encounters",
        ["links"] = encounter_summon_links,
        ["enemies"] = encounter_enemies,
      },
      {
        ["type"] = "Elite",
        ["links"] = elite_summon_links_used,
        ["enemies"] = elite_enemies,
      },
      {
        ["type"] = "Boss",
        ["links"] = boss_summon_links_used,
        ["enemies"] = boss_enemies,
      },
    }

    for _, list_info in ipairs(listsToProcess) do
      if #list_info["enemies"] ~= #list_info["links"][act] then
        broadcastToAll("WARNING: " .. tostring(list_info["type"]) .. " deck for Act " .. tostring(act) .. " size mismatch with summon metadata (" .. tostring(#list_info["enemies"]) .. " vs " .. tostring(#list_info["links"][act])  .. "). Summon association not set.")
        return
      end

      for i=1, #(list_info["links"][act]) do
        local source_guid = list_info["enemies"][i].guid
        for summon_enemy_idx, summon_enemy_type_list in ipairs(list_info["links"][act][i]) do
          for __, associated_option in ipairs(summon_enemy_type_list) do
            if associated_option > 0 and associated_option <= #summon_enemies then
              local target_guid = summon_enemies[associated_option].guid

              if SUMMON_ASSOCIATION[source_guid] == nil then
                SUMMON_ASSOCIATION[source_guid] = {
                  ["Summons"] = {},
                  ["Flavor"] = nil,
                  ["Boss Summons"] = {},
                }

                debugLog(DEBUG_LOG_SUMMON_ASSOCIATIONS, "[Summons] First entry found for " .. tostring(source_guid))
              end

              for j=#(SUMMON_ASSOCIATION[source_guid]["Summons"])+1, summon_enemy_idx do
                table.insert(SUMMON_ASSOCIATION[source_guid]["Summons"], {})

                debugLog(DEBUG_LOG_SUMMON_ASSOCIATIONS, "[Summons] Adding entry slot found for " .. tostring(source_guid) .. " at enemy index " .. tostring(summon_enemy_idx))
              end

              table.insert(SUMMON_ASSOCIATION[source_guid]["Summons"][summon_enemy_idx], target_guid)

              debugLog(DEBUG_LOG_SUMMON_ASSOCIATIONS, "[Summons] Adding entry " .. tostring(#SUMMON_ASSOCIATION[source_guid]["Summons"][summon_enemy_idx]) .. " for enemy index " ..tostring(summon_enemy_idx) .. ": Source GUID: " .. tostring(source_guid) .. " to: " .. tostring(target_guid))
            else
              broadcastToAll("WARNING: Summon metadata is outside the scope of the summon deck for act " .. tostring(act) ..". Attempted to grab card #" ..tostring(associated_option))
            end
          end
        end

        -- Check for "Boss Summmons"
        if list_info["links"][act][i]["Boss Summon"] ~= nil then
          debugLog(DEBUG_LOG_SUMMON_ASSOCIATIONS, "[Summons] Boss Summon detected.")
          for summon_enemy_idx, summon_enemy_type_list in ipairs(list_info["links"][act][i]["Boss Summon"]) do
            for __, associated_option in ipairs(summon_enemy_type_list) do
              if associated_option > 0 and associated_option <= #boss_summon_enemies then
                local target_guid = boss_summon_enemies[associated_option].guid

                if SUMMON_ASSOCIATION[source_guid] == nil then
                  SUMMON_ASSOCIATION[source_guid] = {
                    ["Summons"] = {},
                    ["Flavor"] = nil,
                    ["Boss Summons"] = {},
                  }

                  debugLog(DEBUG_LOG_SUMMON_ASSOCIATIONS, "[Summons] (Boss Summon) First entry found for " .. tostring(source_guid))
                end

                for j=#(SUMMON_ASSOCIATION[source_guid]["Boss Summons"])+1, summon_enemy_idx do
                  table.insert(SUMMON_ASSOCIATION[source_guid]["Boss Summons"], {})

                  debugLog(DEBUG_LOG_SUMMON_ASSOCIATIONS, "[Summons] Adding Boss Summon entry slot found for " .. tostring(source_guid) .. " at boss summon index " .. tostring(summon_enemy_idx))
                end

                table.insert(SUMMON_ASSOCIATION[source_guid]["Boss Summons"][summon_enemy_idx], target_guid)

                debugLog(DEBUG_LOG_SUMMON_ASSOCIATIONS, "[Summons] Adding Boss Summon entry " .. tostring(#SUMMON_ASSOCIATION[source_guid]["Boss Summons"][summon_enemy_idx]) .. " for enemy index " ..tostring(summon_enemy_idx) .. ": Source GUID: " .. tostring(source_guid) .. " to: " .. tostring(target_guid))
              else
                broadcastToAll("WARNING: Boss Summon metadata is outside the scope of the boss summon deck for act " .. tostring(act) ..". Attempted to grab card #" ..tostring(associated_option))
              end
            end
          end
        end

        if list_info["links"][act][i]["Flavor"] ~= nil then
          if SUMMON_ASSOCIATION[source_guid] == nil then
            SUMMON_ASSOCIATION[source_guid] = {
              ["Summons"] = {},
              ["Flavor"] = nil,
              ["Boss Summons"] = {},
            }

            debugLog(DEBUG_LOG_SUMMON_ASSOCIATIONS, "[Summons] (Boss Summon) First entry found for " .. tostring(source_guid))
          end

          SUMMON_ASSOCIATION[source_guid]["Flavor"] = list_info["links"][act][i]["Flavor"]
        end
      end
    end
  end

  cacheSaveData()
end

function associateEnemyHP()
  -- These lists link the card number in the deck to the HP for the card
  starter_enemy_hp_list = {
    {
      -- ACT 1
      9,    -- Cultist
      8,    -- Jaw Worm
      3,    -- Red Louse
      3,    -- Small Slime
    },
    {
      -- ACT 2
    },
    {
      -- ACT 3
    },
    {
      -- ACT 4
    },
  }

  summon_enemy_hp_list = {
    {
      -- ACT 1
      4, 2, 2, 4, 2, 5, 5, 2, 3, 3,
      3, 5, 8, 8, 8, 8, 8, 8, 8, 8,
      8, 8, 8, 12, 12, 12, 12, 5, 5, 5,
      5, 5, 5, 5, 5
    },
    {
      -- ACT 2
      4, 4, 4, 9, 9, 9, 9, 19, 19, 19,
      19, 9, 9, 9, 9, 9, 9, 9, 9, 10,
      10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
      10,
      4, 2, 2, 4, 2, 5, 5, 2,   -- Gremlins which are brought in from ACT 1 summons
    },
    {
      -- ACT 3
      5, 5, 5, 5, 5, 5, 5, 5, 9, 9,
      9, 9, 10, 10, 8, 10, 10, 7,
      9, 9, 9, 9,   -- Cultists which are brought in from ACT 2 summons
    },
    {
      -- ACT 4
    },
  }

  encounters_enemy_hp_list = {
    {
      -- ACT 1
      9, 9, 6, 3, 4, 6, 2, 4, 10, 10,
      9, 10
    },
    {
      -- ACT 2
      23, 17, 5, 4, 9, 18, 16,
      14,
      10, 10,
      15,
      15
    },
    {
      -- ACT 3
      10, 28, 8, 7, 22, 22, 2, 28, 27,
    },
    {
      -- ACT 4
    },
  }

  elite_enemy_hp_list = {
    {
      -- ACT 1
      {22, 44, 66, 88},   -- Lagavulin
      {17, 33, 48, 64},   -- Gremlin Nob
      {8, 8, 8, 8},       -- Sentries
    },
    {
      -- ACT 2
      {30, 60, 90, 120},   -- Book of Stabbing
      {30, 60, 90, 120},   -- Gremlin Leader
      {13, 26, 39, 52},    -- Taskmaster
    },
    {
      -- ACT 3
      {80, 160, 240, 320}, -- Giant Head
      {30, 60, 90, 120},   -- Nemesis
      {35, 70, 105, 140},  -- Reptomancer
    },
    {
      -- ACT 4
    },
  }

  ascension_elite_enemy_hp_list = {
    {
      -- ACT 1
      {18, 36, 53, 70},   -- Gremlin Nob
      {22, 44, 66, 88},   -- Lagavulin
      {9, 9, 9, 9},       -- Sentries
    },
    {
      -- ACT 2
      {35, 70, 105, 140},   -- Book of Stabbing
      {35, 70, 105, 140},   -- Gremlin Leader
      {14, 28, 44, 56},    -- Taskmaster
    },
    {
      -- ACT 3
      {85, 170, 255, 340}, -- Giant Head
      {35, 70, 105, 140},   -- Nemesis
      {40, 80, 120, 160},  -- Reptomancer
    },
    {
      -- ACT 4
    },
  }

   -- Bosses
   boss_hp_list = {
     {
       -- ACT 1
       {22, 44, 66, 88},   -- Slime Boss
       {35, 70, 105, 140}, -- Hexaghost
       {40, 80, 120, 160}, -- The Guardian
     },
     {
       -- ACT 2
       {55, 110, 165, 220}, -- Bronze Automaton
       {57, 114, 171, 228}, -- The Collector
       {40, 80, 120, 160},  -- The Champ
     },
     {
       -- ACT 3
       {50, 100, 150, 200}, -- Awakened One
       {50, 100, 150, 200}, -- Donu
       {60, 120, 180, 240}, -- Time Eater
     },
     {
       -- ACT 4
       {100, 200, 300, 400},  -- Corrupt Heart
     },
   }

   ascension_boss_hp_list = {
     {
       -- ACT 1
       {23, 46, 68, 92},   -- Slime Boss
       {38, 75, 112, 150}, -- Hexaghost
       {40, 80, 120, 160}, -- The Guardian
     },
     {
       -- ACT 2
       {60, 120, 180, 240}, -- Bronze Automaton
       {60, 120, 180, 240}, -- The Collector
       {45, 90, 135, 180},  -- The Champ
     },
     {
       -- ACT 3
       {50, 100, 150, 200}, -- Awakened One
       {55, 110, 165, 220}, -- Donu
       {64, 128, 192, 256}, -- Time Eater
     },
     {
       -- ACT 4
       {120, 240, 360, 480},  -- Corrupt Heart
     },
   }

   boss_summon_hp_list = {
     {
       -- ACT 1
     },
     {
       -- ACT 2

     },
     {
       -- ACT 3
       {50, 100, 150, 200}, -- Awakened One Phase 2
       {50, 100, 150, 200}, -- Deca
     },
     {
       -- ACT 4
       {50, 100, 150, 200}, -- Awakened One Phase 2
       {50, 100, 150, 200}, -- Deca
     },
   }

   ascension_boss_summon_hp_list = {
     {
       -- ACT 1
     },
     {
       -- ACT 2

     },
     {
       -- ACT 3
       {50, 100, 150, 200}, -- Awakened One Phase 2
       {55, 110, 165, 220}, -- Deca
     },
     {
       -- ACT 4
       {50, 100, 150, 200}, -- Awakened One Phase 2
       {55, 110, 165, 220}, -- Deca
     },
   }

  -- Build the GUID linkage
  ENEMY_HP_ASSOCIATION = {}
  for act, act_info in ipairs(ACT_COMPONENTS) do
    debugLog(DEBUG_LOG_HP_ASSOCIATIONS, "[HP] Processing HPs for Act " .. tostring(act))

    -- Process each list for each act
    local elite_hp_list_used = elite_enemy_hp_list[act]
    if ASCENSION_LEVEL >= 1 then
      debugLog(DEBUG_LOG_HP_ASSOCIATIONS, "[HP] Ascension 1 Elites detected")
      elite_hp_list_used = ascension_elite_enemy_hp_list[act]
    end
    local boss_hp_list_used = boss_hp_list[act]
    local boss_summon_hp_list_used = boss_summon_hp_list[act]
    if ASCENSION_LEVEL >= 9 and not PUBLIC then
      debugLog(DEBUG_LOG_HP_ASSOCIATIONS, "[HP] Ascension 9 Bosses detected")
      boss_hp_list_used = ascension_boss_hp_list[act]
      boss_summon_hp_list_used = ascension_boss_summon_hp_list[act]
    end
    local listsToProcess = {
      {
        ["type"] = "1st Encounter",
        ["HP List"] = starter_enemy_hp_list[act],
        ["Deck GUID"] = act_info["FirstEncounterDeck"],
      },
      {
        ["type"] = "Summons",
        ["HP List"] = summon_enemy_hp_list[act],
        ["Deck GUID"] = act_info["EnemyDecks"]["Summons"]["Deck"],
      },
      {
        ["type"] = "Encounters",
        ["HP List"] = encounters_enemy_hp_list[act],
        ["Deck GUID"] = act_info["EnemyDecks"]["Encounters"]["Deck"],
      },
      {
        ["type"] = "Elite",
        ["HP List"] = elite_hp_list_used,
        ["Deck GUID"] = act_info["EnemyDecks"]["Elites"]["Deck"],
      },
      {
        ["type"] = "Boss",
        ["HP List"] = boss_hp_list_used,
        ["Deck GUID"] = act_info["BossDeck"],
      },
      {
        ["type"] = "Boss Summon",
        ["HP List"] = boss_summon_hp_list_used,
        ["Deck GUID"] = act_info["BossSummon"],
      },
    }

    -- Process each list
    for _, list_info in ipairs(listsToProcess) do
      debugLog(DEBUG_LOG_HP_ASSOCIATIONS, "  [HP] Processing " .. tostring(list_info["type"]))
      local deckGuid = list_info["Deck GUID"]
      local hp_list = list_info["HP List"]
      if deckGuid then
        local deck = getObjectFromGUID(deckGuid)
        if deck then
          local enemies = {}
          if deck.name == "Deck" or deck.name == "DeckCustom" then
            enemies = deck.getObjects()
          elseif deck.name == "Card" or deck.name == "CardCustom" then
            enemies = {deck}
          end
          if #enemies == #hp_list then
            for i=1, #hp_list do
              local source_guid = enemies[i].guid

              if ENEMY_HP_ASSOCIATION[source_guid] == nil then
                ENEMY_HP_ASSOCIATION[source_guid] = {}
              end

              if type(hp_list[i]) == "table" then
                ENEMY_HP_ASSOCIATION[source_guid] = hp_list[i][getNumPlayers()]
                debugLog(DEBUG_LOG_HP_ASSOCIATIONS, "    [HP] " .. tostring(source_guid) .. " setting HP to " .. tostring(hp_list[i][getNumPlayers()]))
              else
                ENEMY_HP_ASSOCIATION[source_guid] = hp_list[i]
                debugLog(DEBUG_LOG_HP_ASSOCIATIONS, "    [HP] " .. tostring(source_guid) .. " setting HP to " .. tostring(hp_list[i]))
              end
            end
          else
            broadcastToAll("WARNING: " .. tostring(list_info["type"]) .. " deck for Act " .. tostring(act) .. " size mismatch with HP metadata. HP values may not be correct.")
          end
        else
          broadcastToAll("WARNING: Unable to find " .. tostring(list_info["type"]) .. " deck for act " .. tostring(act) .. ". HP not properly set.")
        end
      end
    end
  end

  cacheSaveData()
end

function associateEnemyIntent()
  -- These lists link the starting X/Z offsets for intents if they exist for the card
  starter_enemy_intent_list = {
    {
      -- ACT 1
      {},    -- Cultist
      {},    -- Jaw Worm
      {},    -- Red Louse
      {},    -- Small Slime
    },
    {
      -- ACT 2
    },
    {
      -- ACT 3
    },
    {
      -- ACT 4
    },
  }

  summon_enemy_intent_list = {
    {
      -- ACT 1
      {-0.43, -0.91},   -- Gremlin Wizard
      {}, {},
      {-0.43, -0.91},   -- Gremlin Wizard
      {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {},
    },
    {
      -- ACT 2
      {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {},
      {-0.93, -0.42},   -- Mugger
      {-0.93, -0.42},   -- Mugger
      {}, {}, {}, {}, {}, {}, {}, {}, {}, {},
      {-0.43, -0.91}, {}, {}, {-0.43, -0.91}, {}, {}, {}, {},   -- Gremlins, cloned from Act 1's summon deck programmatically
    },
    {
      -- ACT 3
      {-0.62, -0.95},   -- Dagger
      {-0.62, -0.95},   -- Dagger
      {-0.62, -0.95},   -- Dagger
      {-0.62, -0.95},   -- Dagger
      {-0.62, -0.95},   -- Dagger
      {-0.62, -0.95},   -- Dagger
      {-0.62, -0.95},   -- Dagger
      {-0.62, -0.95},   -- Dagger
      {}, {}, {}, {}, {}, {},
      {-0.9, -0.6},   -- Exploder
      {-0.89, -1.48},  -- Spiker
      {-0.89, -1.48},  -- Spiker
      {},
      {}, {}, {}, {},       -- Cultists, cloned from Act 2's summon deck programmatically
    },
    {
      -- ACT 4
    },
  }

  encounters_enemy_intent_list = {
    {
      -- ACT 1
      {}, {}, {}, {}, {}, {}, {}, {}, {}, {},
      {-0.9, -0.75},  -- Looter
      {},
    },
    {
      -- ACT 2
      {}, {},
      {-0.35, -0.42},  -- Spheric Guardian
      {}, {},
      {-0.61, -0.66},  -- Shelled Parasite
      {-0.71, -0.47},  -- Chosen
      {-0.71, -0.47},  -- Chosen
      {-0.94, -0.49},  -- Looter
      {-0.94, -0.49},  -- Looter
      {}, {},
    },
    {
      -- ACT 3
      {}, {},
      {-0.91, -0.46},   -- Exploder
      {}, {}, {},
      {-0.98, -0.73},   -- Transient
      {-0.9, -0.37},    -- The Maw
      {},
    },
    {
      -- ACT 4
    },
  }

  elite_enemy_intent_list = {
    {
      -- ACT 1
      {-0.9, -0.37},   -- Lagavulin
      {-0.71, -0.63},   -- Gremlin Nob
      {}
    },
    {
      -- ACT 2
      {},
      {-0.91, -0.39}, -- Gremlin Leader
      {},
    },
    {
      -- ACT 3
      {-0.96, -0.64},  -- Giant Head
      {-0.96, -0.4},   -- Nemesis
      {-0.87, -0.45},  -- Reptomancer
    },
    {
      -- ACT 4
    },
  }

  ascension_elite_enemy_intent_list = {
    {
      -- ACT 1
      {-0.71, -0.62},   -- Gremlin Nob
      {-0.9, -0.74},   -- Lagavulin
      {-0.76, -0.37},       -- Sentries
    },
    {
      -- ACT 2
      {},
      {-0.92, -0.39},   -- Gremlin Leader
      {-0.53, -0.48},    -- Taskmaster
    },
    {
      -- ACT 3
      {-0.96, -0.64}, -- Giant Head
      {-0.97, -0.4},   -- Nemesis
      {-0.88, -0.46},  -- Reptomancer
    },
    {
      -- ACT 4
    },
  }

   -- Bosses
   boss_intent_list = {
     {
       -- ACT 1
       {-2.13, -0.63}, -- Slime Boss
       {-2.11, 0.63},  -- Hexaghost
       {-2.13, -0.53}, -- The Guardian
     },
     {
       -- ACT 2
       {-2.01, 0.41},  -- Bronze Automaton
       {-2.14, 0.58},  -- The Collector
       {-2.15, 1.04},  -- The Champ
     },
     {
       -- ACT 3
       {-2.02, -0.63}, -- Awakened One
       {-2.04, 0.27}, -- Donu
       {-2.14, -0.64}, -- Time Eater
     },
     {
       -- ACT 4
       {{-2.14, 0.89}, {0.09, -1.42}},  -- Corrupt Heart
     },
   }

   ascension_boss_intent_list = {
     {
       -- ACT 1
       {-2.14, -0.64},   -- Slime Boss
       {-2.09, 0.63}, -- Hexaghost
       {-2.13, -0.54}, -- The Guardian
     },
     {
       -- ACT 2
       {-2, 0.42}, -- Bronze Automaton
       {-2.14, 0.58}, -- The Collector
       {-2.16, 1.03},  -- The Champ
     },
     {
       -- ACT 3
       {-2.02, -0.62}, -- Awakened One
       {-2.05, 0.26}, -- Donu
       {-2.14, -0.65}, -- Time Eater
     },
     {
       -- ACT 4
       {{-2.13, 0.88}, {0.1, -1.44}},  -- Corrupt Heart
     },
   }

   boss_summon_intent_list = {
     {
       -- ACT 1
     },
     {
       -- ACT 2

     },
     {
       -- ACT 3
       {-1.42, -0.65}, -- Awakened One Phase 2
       {-2.12, -0.16}, -- Deca
     },
     {
       -- ACT 4
       {-1.42, -0.65}, -- Awakened One Phase 2
       {-2.12, -0.16}, -- Deca
     },
   }

   ascension_boss_summon_intent_list = {
     {
       -- ACT 1
     },
     {
       -- ACT 2

     },
     {
       -- ACT 3
       {-1.55, -0.64}, -- Awakened One Phase 2
       {-2.11, -0.17}, -- Deca
     },
     {
       -- ACT 4
       {-1.55, -0.64}, -- Awakened One Phase 2
       {-2.11, -0.17}, -- Deca
     },
   }

  -- Build the GUID linkage
  ENEMY_INTENT_ASSOCIATION = {}
  for act, act_info in ipairs(ACT_COMPONENTS) do
    debugLog(DEBUG_LOG_INTENT_ASSOCIATIONS, "[INTENT] Processing Intent for Act " .. tostring(act))

    -- Process each list for each act
    local elite_intent_list_used = elite_enemy_intent_list[act]
    if ASCENSION_LEVEL >= 1 then
      debugLog(DEBUG_LOG_INTENT_ASSOCIATIONS, "[INTENT] Ascension 1 Elites detected")
      elite_intent_list_used = ascension_elite_enemy_intent_list[act]
    end
    local boss_intent_list_used = boss_intent_list[act]
    local boss_summon_intent_list_used = boss_summon_intent_list[act]
    if ASCENSION_LEVEL >= 9 and not PUBLIC then
      debugLog(DEBUG_LOG_INTENT_ASSOCIATIONS, "[INTENT] Ascension 9 Bosses detected")
      boss_intent_list_used = ascension_boss_intent_list[act]
      boss_summon_intent_list_used = ascension_boss_summon_intent_list[act]
    end
    local listsToProcess = {
      {
        ["type"] = "1st Encounter",
        ["Intent"] = starter_enemy_intent_list[act],
        ["Deck GUID"] = act_info["FirstEncounterDeck"],
      },
      {
        ["type"] = "Summons",
        ["Intent"] = summon_enemy_intent_list[act],
        ["Deck GUID"] = act_info["EnemyDecks"]["Summons"]["Deck"],
      },
      {
        ["type"] = "Encounters",
        ["Intent"] = encounters_enemy_intent_list[act],
        ["Deck GUID"] = act_info["EnemyDecks"]["Encounters"]["Deck"],
      },
      {
        ["type"] = "Elite",
        ["Intent"] = elite_intent_list_used,
        ["Deck GUID"] = act_info["EnemyDecks"]["Elites"]["Deck"],
      },
      {
        ["type"] = "Boss",
        ["Intent"] = boss_intent_list_used,
        ["Deck GUID"] = act_info["BossDeck"],
      },
      {
        ["type"] = "Boss Summon",
        ["Intent"] = boss_summon_intent_list_used,
        ["Deck GUID"] = act_info["BossSummon"],
      },
    }

    -- Process each list
    for _, list_info in ipairs(listsToProcess) do
      debugLog(DEBUG_LOG_INTENT_ASSOCIATIONS, "  [INTENT] Processing " .. tostring(list_info["type"]))
      local deckGuid = list_info["Deck GUID"]
      local intent_list = list_info["Intent"]
      if deckGuid then
        local deck = getObjectFromGUID(deckGuid)
        if deck then
          local enemies = {}
          if deck.name == "Deck" or deck.name == "DeckCustom" then
            enemies = deck.getObjects()
          elseif deck.name == "Card" or deck.name == "CardCustom" then
            enemies = {deck}
          end
          if #enemies == #intent_list then
            for i=1, #intent_list do
              local source_guid = enemies[i].guid

              ENEMY_INTENT_ASSOCIATION[source_guid] = intent_list[i]
              debugLog(DEBUG_LOG_INTENT_ASSOCIATIONS, "    [INTENT] " .. tostring(source_guid) .. " setting Intent to (" .. tostring(intent_list[i][1]) .. ", " .. tostring(intent_list[i][2]) .. ")")
            end
          else
            broadcastToAll("WARNING: " .. tostring(list_info["type"]) .. " deck for Act " .. tostring(act) .. " size mismatch with Intent metadata (" ..tostring(#enemies) .. ") vs  (" ..tostring(#intent_list) .. "). Intent values may not be correct.")
          end
        else
          broadcastToAll("WARNING: Unable to find " .. tostring(list_info["type"]) .. " deck for act " .. tostring(act) .. ". Intent not properly set.")
        end
      end
    end
  end

  cacheSaveData()
end

function associateEnemyRewards()
  -- These lists link the reward type for each card. Each reward type is a string.
  -- Reward types are: Potion, Card, Rare Card, Relic, Boss Relic, Gold_X (where X is the number)
  starter_enemy_reward_list = {
    {
      -- ACT 1
      {"Gold_1", "Card"},    -- Cultist
      {"Gold_1", "Potion", "Card"},    -- Jaw Worm
      {"Gold_1", "Card"},    -- Red Louse
      {"Potion", "Card"},    -- Small Slime
    },
    {
      -- ACT 2
    },
    {
      -- ACT 3
    },
    {
      -- ACT 4
    },
  }

  -- Encounter associations
  encounters_enemy_reward_list = {
    -- ACT 1
    {
      {"Gold_1", "Potion", "Card"},    -- Cultist
      {"Gold_1", "Card"},     -- Cultist
      {"Gold_1", "Potion", "Card"},     -- Fungi Beast
      {"Gold_1", "Card"},     -- Small Slime
      {"Gold_1", "Card"},     -- Red Louse
      {"Gold_1", "Potion", "Card"},   -- Large slime
      {"Gold_1", "Potion", "Card"},     -- Sneaky Gremlin
      {"Gold_2", "Card"},     -- Mad Gremlin
      {"Gold_2", "Card"},   -- Blue Slaver
      {"Gold_1", "Card"},   -- Red Slaver
      {"Potion", "Card"},   -- Looter
      {"Gold_1", "Card"},   -- Jaw Worm
    },
    {
      -- ACT 2
      {"Gold_1", "Card"},   -- Snecko
      {"Gold_1", "Card"},   -- Snake Plant
      {"Gold_1", "Card"},   -- Spheric Guardian
      {"Gold_1", "Card"},     -- Byrd
      {"Gold_2", "Card"},     -- Cultist
      {"Potion", "Card"},   -- Shelled Parasite
      {"Gold_2", "Card"},     -- Chosen
      {"Gold_1", "Potion", "Card"},     -- Chosen
      {"Potion", "Card"},     -- Looter
      {"Potion", "Card"},     -- Looter
      {"Gold_1", "Potion", "Card"},   -- Centurion
      {"Gold_1", "Card"},     -- Centurion
    },
    {
      -- ACT 3
      {"Gold_2", "Card"},     -- Jaw Worm
      {"Gold_1", "Potion", "Card"},   -- Spire Growth
      {"Gold_2", "Card"},     -- Exploder
      {"Potion", "Card"},     -- Repulsor
      {"Gold_1", "Card"},   -- Orb Walker
      {"Gold_1", "Card"},   -- Orb Walker
      {"Gold_2", "Card"},   -- Transient
      {"Gold_1", "Card"},   -- The Maw
      {"Potion", "Card"},   -- Writhing Mass
    },
    {
      -- ACT 4
    }
  }

  -- Elites
  elite_enemy_reward_list = {
    -- ACT 1
    {
      {"Gold_2", "Relic", "Card"},   -- Lagavulin
      {"Gold_2", "Relic", "Card"},   -- Gremlin Nob
      {"Gold_2", "Relic", "Card"},   -- Sentries
    },
    {
      -- ACT 2
      {"Gold_2", "Relic", "Card"},   -- Book of Stabbing
      {"Gold_2", "Relic", "Card"},   -- Gremlin Leader
      {"Gold_2", "Relic", "Card"},   -- Taskmaster
    },
    {
      -- ACT 3
      {"Gold_2", "Relic", "Card"},  -- Giant Head
      {"Gold_2", "Relic", "Card"},  -- Nemesis
      {"Gold_2", "Relic", "Card"},  -- Retomancer
    },
    {
      -- ACT 4
    }
  }

  ascension_elite_enemy_reward_list = {
    -- ACT 1
    {
      {"Gold_2", "Relic", "Card"},   -- Gremlin Nob
      {"Gold_2", "Relic", "Card"},   -- Lagavulin
      {"Gold_2", "Relic", "Card"},   -- Sentries
    },
    {
      -- ACT 2
      {"Gold_2", "Relic", "Card"},   -- Book of Stabbing
      {"Gold_2", "Relic", "Card"},   -- Gremlin Leader
      {"Gold_2", "Relic", "Card"},   -- Taskmaster
    },
    {
      -- ACT 3
      {"Gold_2", "Relic", "Card"},  -- Giant Head
      {"Gold_2", "Relic", "Card"},  -- Nemesis
      {"Gold_2", "Relic", "Card"},  -- Retomancer
    },
    {
      -- ACT 4
    }
  }

  -- Bosses
  boss_reward_list = {
    {
      -- ACT 1
      {"Gold_3", "Boss Relic", "Rare Card"}, -- Slime Boss
      {"Gold_3", "Boss Relic", "Rare Card"}, -- Hexaghost
      {"Gold_3", "Boss Relic", "Rare Card"}, -- The Guardian
    },
    {
      -- ACT 2
      {"Gold_3", "Boss Relic", "Rare Card"}, -- Bronze Automaton
      {"Gold_3", "Boss Relic", "Rare Card"}, -- The Collector
      {"Gold_3", "Boss Relic", "Rare Card"}, -- The Champ
    },
    {
      -- ACT 3
      {},  -- Awakened One
      {},  -- Donu
      {},  -- Time Eater
    },
    {
      -- ACT 4
      {},
    },
  }

  ascension_boss_reward_list = {
    {
      -- ACT 1
      {"Gold_2", "Boss Relic", "Rare Card"}, -- Slime Boss
      {"Gold_2", "Boss Relic", "Rare Card"}, -- Hexaghost
      {"Gold_2", "Boss Relic", "Rare Card"}, -- The Guardian
    },
    {
      -- ACT 2
      {"Gold_2", "Boss Relic", "Rare Card"},  -- Bronze Automaton
      {"Gold_2", "Boss Relic", "Rare Card"},  -- The Collector
      {"Gold_2", "Boss Relic", "Rare Card"},  -- The Champ
    },
    {
      -- ACT 3
      {},  -- Awakened One
      {},  -- Donu
      {},  -- Time Eater
    },
    {
      -- ACT 4
      {},
    },
  }

  -- Build the GUID linkage
  ENEMY_REWARD_ASSOCIATION = {}
  for act, act_info in ipairs(ACT_COMPONENTS) do
    debugLog(DEBUG_LOG_REWARDS_ASSOCIATIONS, "[REWARD] Processing Reward for Act " .. tostring(act))

    -- Process each list for each act
    local elite_reward_list_used = elite_enemy_reward_list[act]
    if ASCENSION_LEVEL >= 1 then
      debugLog(DEBUG_LOG_REWARDS_ASSOCIATIONS, "[REWARD] Ascension 1 Elites detected")
      elite_reward_list_used = ascension_elite_enemy_reward_list[act]
    end
    local boss_reward_list_used = boss_reward_list[act]
    if ASCENSION_LEVEL >= 9 and not PUBLIC then
      debugLog(DEBUG_LOG_REWARDS_ASSOCIATIONS, "[REWARD] Ascension 9 Bosses detected")
      boss_reward_list_used = ascension_boss_reward_list[act]
    end
    local listsToProcess = {
      {
        ["type"] = "1st Encounter",
        ["Reward"] = starter_enemy_reward_list[act],
        ["Deck GUID"] = act_info["FirstEncounterDeck"],
      },
      {
        ["type"] = "Encounters",
        ["Reward"] = encounters_enemy_reward_list[act],
        ["Deck GUID"] = act_info["EnemyDecks"]["Encounters"]["Deck"],
      },
      {
        ["type"] = "Elite",
        ["Reward"] = elite_reward_list_used,
        ["Deck GUID"] = act_info["EnemyDecks"]["Elites"]["Deck"],
      },
      {
        ["type"] = "Boss",
        ["Reward"] = boss_reward_list_used,
        ["Deck GUID"] = act_info["BossDeck"],
      },
    }

    -- Process each list
    for _, list_info in ipairs(listsToProcess) do
      debugLog(DEBUG_LOG_REWARDS_ASSOCIATIONS, "  [REWARD] Processing " .. tostring(list_info["type"]))
      local deckGuid = list_info["Deck GUID"]
      local reward_list = list_info["Reward"]
      if deckGuid then
        local deck = getObjectFromGUID(deckGuid)
        if deck then
          local enemies = {}
          if deck.name == "Deck" or deck.name == "DeckCustom" then
            enemies = deck.getObjects()
          elseif deck.name == "Card" or deck.name == "CardCustom" then
            enemies = {deck}
          end
          if #enemies == #reward_list then
            for i=1, #reward_list do
              local source_guid = enemies[i].guid

              ENEMY_REWARD_ASSOCIATION[source_guid] = reward_list[i]
              debugLog(DEBUG_LOG_REWARDS_ASSOCIATIONS, "    [REWARD] " .. tostring(source_guid) .. " setting Reward to (" .. tostring(table.concat(reward_list[i], ", ")) .. ")")
            end
          else
            broadcastToAll("WARNING: " .. tostring(list_info["type"]) .. " deck for Act " .. tostring(act) .. " size mismatch with Reward metadata (" ..tostring(#enemies) .. ") vs  (" ..tostring(#reward_list) .. "). Reward values may not be correct.")
          end
        else
          broadcastToAll("WARNING: Unable to find " .. tostring(list_info["type"]) .. " deck for act " .. tostring(act) .. ". Reward not properly set.")
        end
      end
    end
  end

  cacheSaveData()
end

function registerNeowCardForReturn(guid)
  if DEPLOYED_NEOW_CARDS == nil then
    DEPLOYED_NEOW_CARDS = {}
  end

  table.insert(DEPLOYED_NEOW_CARDS, guid)
end

function GetAssociatedUpgradeCardGUID(guid)
  if CARD_UPGRADE_INFO[guid] then
    return CARD_UPGRADE_INFO[guid]["Related_Card"]
  end
  return nil
end

function GetOriginalDeckGUID(guid)
  if CARD_UPGRADE_INFO[guid] then
    return CARD_UPGRADE_INFO[guid]["Source_Deck"]
  end
  return nil
end

-- Whether a card is an upgrade or not
function IsUpgradeCard(guid)
  if CARD_UPGRADE_INFO[guid] then
    return CARD_UPGRADE_INFO[guid]["Card_Type"] == "Upgrade"
  end
  broadcastToAll("WARNING: Unable to determine if card (" ..tostring(guid) ..") is an upgraded card or not.")
  return false
end

-- Takes in a card GUID and returns the deck/bag GUID which contains the card
function FindContainerWithCard(target_obj_guid)
  -- First check if our GUID is associated with any "original deck"
  local assumed_deck_guid = GetOriginalDeckGUID(target_obj_guid)
  local assumed_deck_obj = getObjectFromGUID(assumed_deck_guid)
  if assumed_deck_obj then
    for _, target_deck_card in ipairs(assumed_deck_obj.getObjects()) do
      if target_deck_card.guid == target_obj_guid then
        return assumed_deck_guid
      end
    end
  end

  -- Not found in the deck it is supposed to be in...
  -- Check all other decks in the game...
  local all_game_objects = getObjects()
  for _, game_obj in ipairs(all_game_objects) do
    if game_obj.name == "Deck" or game_obj.name == "DeckCustom" or game_obj.name == "Bag" then
      for __, internal_obj in ipairs(game_obj.getObjects()) do
        if internal_obj.guid == target_obj_guid then
          -- We found the card in a different container. Re-associate that card with this new deck/bag as its original source
          -- Only update if we've been tracking this deck
          if CARD_UPGRADE_INFO[game_obj.getGUID()] ~= nil then
            CARD_UPGRADE_INFO[game_obj.getGUID()]["Source_Deck"] = game_obj.getGUID()
          end
          return game_obj.getGUID()
        end
      end
    end
  end

  return nil
end

-- Searches for and deploys the object to the desired position and rotation
-- Returns the object if successfully finding the object or nil otherwise
function FindAndDeployObject(target_obj_guid, target_pos, target_rot, onlyDecks)
  -- First check if the object just exists in the world, unless we only want decks
  if onlyDecks == nil or onlyDecks == false then
    local target_card_obj = getObjectFromGUID(target_obj_guid)
    if target_card_obj then
      target_card_obj.setPositionSmooth(target_pos)
      if target_rot then
        target_card_obj.setRotationSmooth(target_rot)
      end

      return target_card_obj
    end
  end

  -- Find the deck/bag that this object is in
  local source_container_guid = FindContainerWithCard(target_obj_guid)
  if source_container_guid then
    local source_container = getObjectFromGUID(source_container_guid)
    if not target_rot then
      target_rot = source_container.getRotation()
    end
    local obj = source_container.takeObject({guid=target_obj_guid, position=target_pos, rotation=target_rot})
    return obj
  end

  return nil
end

function FindAndDeployObjectExternal(args)
  return FindAndDeployObject(args[1], args[2], args[3])
end

function FindComponent(componentType, override_dist_check, broadcastOnFail)
  componentInfo = {
    ["Starter"] = {
      ["name"] = "Starter Deck",
      ["guid"] = '3a0392',
      ["pos"] = {4.81, 1.03, -10.26}
    },
  }
  local search_info = componentInfo[componentType]

  local obj_found = nil
  local cur_priority = 1000
  for _, obj in ipairs(getObjects()) do
    -- Check by name / description
    if string.find(string.lower(obj.getName()), string.lower(search_info["name"])) ~= nil or
      string.find(string.lower(obj.getDescription()), string.lower(search_info["name"])) ~= nil then
      if obj_found == nil or cur_priority > 1 then
        obj_found = obj
        cur_priority = 1
      end
    -- Check by GUID
    elseif obj.getGUID() == search_info["guid"] then
      if obj_found == nil or cur_priority > 2 then
        obj_found = obj
        cur_priority = 2
      end
    -- Check by position
    elseif PosWithinTolerance(obj, search_info["pos"], override_dist_check or 3) then
      if obj_found == nil or cur_priority > 3 then
        obj_found = obj
        cur_priority = 3
      end
    end
  end

  if obj_found == nil and (broadcastOnFail == nil or broadcastOnFail) then
    broadcastToAll("WARNING: Unable to find component " .. componentType .. ".\nEither set name to: '" .. search_info["name"] .. "',\nposition to near (" .. search_info["pos"][1] .. "," .. search_info["pos"][2] .. "," .. search_info["pos"][3] .. "),\nor update the script's associated GUID", "Orange")
  end

  return obj_found
end

function getActiveMapObj()
  for _, act_info in ipairs(ACT_COMPONENTS) do
    local poll_obj = getObjectFromGUID(act_info["Map"])
    if poll_obj then
      return poll_obj
    end
  end

  return nil
end

function getNumPlayers()
  local numPlayers = 0
  for _, __ in pairs(PLAYER_TO_CHARACTER) do
    numPlayers = numPlayers + 1
  end
  return numPlayers
end

function getPlayerColorForCharacter(character)
  return CHARACTER_TO_PLAYER[character]
end

function getCharacterForPlayerColor(color)
  return PLAYER_TO_CHARACTER[color]
end

function getStartingCardHorizontalOffset()
  return 5.46
end

function getEnemyHorizontalSpacing()
  return 2.7
end

function getLaneVerticalOffset(laneIdx)
  local vertical_lane_offsets = {-7.02, -3.14, 0.63, 4.53}
  if laneIdx > 0 and laneIdx <= #vertical_lane_offsets then
    return vertical_lane_offsets[laneIdx]
  else
    broadcastToAll("WARNING: Lane index " .. tostring(laneIdx) .. "out of range. Enemy positioning may be incorrect")
    return vertical_lane_offsets[1]
  end
end

function getBossPositioning()
  return {5.76, 2, 1.55}
end

function getBossSummonPositioning()
  local base_pos = getBossPositioning()
  base_pos[2] = base_pos[2] - 0.25
  return base_pos
end

function getUnusedGoldToken()
  local goldZone = getObjectFromGUID("5d67a9")

  if goldZone then
    for _, obj in ipairs(goldZone.getObjects()) do
      if obj.getName() == "Gold" then
        local is_in_use = false
        for __, used_gold in ipairs(USED_GOLD_TRACKER) do
          if obj.getGUID() == used_gold then
            is_in_use = true
          end
        end

        if not is_in_use then
          table.insert(USED_GOLD_TRACKER, obj.getGUID())
          Wait.time(function()
            -- Remove ourselves from USED_GOLD_TRACKER
            for i=#USED_GOLD_TRACKER,1,-1 do
              local guid = USED_GOLD_TRACKER[i]
              if guid == obj.getGUID() then
                table.remove(USED_GOLD_TRACKER, i)
              end
            end
          end, 1)

          return obj
        end
      end
    end
  else
    broadcastToAll("WARNING: Unable to find Gold tokens")
  end

  return nil
end

function getEnemies()
  local enemyList = {}
  for _, obj in ipairs(ENEMY_ZONE.getObjects()) do
    if obj.name == "Card" or obj.name == "CardCustom" then
      -- Further check if it is in the HP list
      if ENEMY_HP_ASSOCIATION[obj.getGUID()] ~= nil then
        table.insert(enemyList, obj)
      end
    elseif obj.name == "Deck" or obj.name == "DeckCustom" then
      table.insert(enemyList, obj)
    end
  end
  return enemyList
end

function getDeployedEnemiesInBossArea()
  local enemyList = {}
  for _, obj in ipairs(BOSS_ENEMY_ZONE.getObjects()) do
    if obj.name == "Card" or obj.name == "CardCustom" then
      -- Only count it if it is face up
      if obj.getRotation()[3] < 10 or obj.getRotation()[3] > 350 then
        table.insert(enemyList, obj)
      end
    end
  end
  return enemyList
end

function getHPCubes()
  local hpCubes = {}
  for _, obj in ipairs(ENEMY_ZONE.getObjects()) do
    if obj.getName() == "HP" then
      table.insert(hpCubes, obj)
    end
  end
  return hpCubes
end

function getHPBoardXOffset()
  return 0.23
end

function getHPBoardStep()
  return 0.32
end

-- Returns the relative Y offset for a slot on the HP Board. Slot 1 would be the top slot
function getHPBoardYOffset(slot)
  local topSlotOffset = (getHPBoardStep()*4.5)
  return topSlotOffset - (getHPBoardStep() * (slot-1))
end

function CreateHPBoardSnapPoints()
  local hp_board = HP_BOARD["Board"]

  -- Add a snap point. Get the existing snap points and add to the list
  local snap_points = hp_board.getSnapPoints()
  local map_scale = hp_board.getScale()

  -- Start from the middle and radiate outward
  for i=1, 10 do
    table.insert(snap_points, {position = {-getHPBoardXOffset() / map_scale[1], 0.0, getHPBoardYOffset(i) / map_scale[3]}, rotation_snap = true})
    table.insert(snap_points, {position = {getHPBoardXOffset() / map_scale[1], 0.0, getHPBoardYOffset(i) / map_scale[3]}, rotation_snap = true})
  end
  hp_board.setSnapPoints(snap_points)
end

function getPlayerDiscardLocation(baseLocation)
  if baseLocation[1] <= 0 then
    if baseLocation[3] <= 0 then
      return {-42.21, 2, -23.78}
    else
      return {-42.32, 2, 24.05}
    end
  else
    if baseLocation[3] <= 0 then
      return {42.36, 2, -24.07}
    else
      return {42.37, 2, 24.03}
    end
  end
  return {42.37, 2, 24.03}
end

function getEnemyDiscardLocation()
  return {17.58, 2, 13.36}
end

function getEnemyDeckLocation(type)
  local enemy_deck_pos = {
    ["Encounters"] = {-6.65, 2, 5.34},
    ["Summons"] = {-9.46, 2, 5.33},
    ["Elites"] = {-12.31, 2, 5.36}
  }

  return enemy_deck_pos[type]
end

function getEnemyNumRewards(enemyGUID)
  if ENEMY_REWARD_ASSOCIATION[enemyGUID] ~= nil then
    return #ENEMY_REWARD_ASSOCIATION[enemyGUID] or 0
  end

  return 0
end

function PosWithinTolerance(checkObj, targetPos, tolerance)
  local dx = targetPos[1] - checkObj.getPosition()[1]
  local dz = targetPos[3] - checkObj.getPosition()[3]
  distSq = (dx * dx) + (dz * dz)
  return distSq <= (tolerance * tolerance)
end

function GetDeckOrCardInZone(zoneGUID)
  for _, obj in ipairs(getObjectFromGUID(zoneGUID).getObjects()) do
    if obj.name == "Card" or obj.name == "CardCustom" or obj.name == "Deck" or obj.name == "DeckCustom" then
      return obj
    end
  end

 return nil
end

function delayedComponentLock(params)
  local GUID = params[1]
  local lock_delay_secs = params[2]
  local Time = os.clock() + lock_delay_secs
  Wait.time(function()
    local obj = getObjectFromGUID(GUID)
    if obj == nil then
      log("Unable to lock component " .. GUID)
    else
      obj.setLock(true)
    end
  end,
  lock_delay_secs)
end

function createScriptingZone(position, rot, scale)
    local zone = spawnObject({type='ScriptingTrigger', position=position, rotation=rot, scale=scale})
    repeat
        coroutine.yield(0)
    until zone.getGUID() ~= nil
    coroutine.yield(0)
    return zone
end

function getNumCardsInDeck(deckObj)
  local remainingDeckCards = 0
  if deckObj then
    if deckObj.name == "Deck" or deckObj.name == "DeckCustom" then
      remainingDeckCards = #deckObj.getObjects()
    else
      remainingDeckCards = 1
    end
  end

  return remainingDeckCards
end

function debugLog(flag, msg)
  if flag then
    log(msg)
  end
end