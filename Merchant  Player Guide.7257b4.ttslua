MERCHANT_MODE_POS = {-1.74, 1.30, -3.78}
RESTING_POS = {-9.89, 1.06, 14.39}

local CARD_OFFSETS = {
  ["Relic"] = {
    {3.33, 1, -1.55},
    {1.12, 1, -1.55},
    {-1.1, 1, -1.55},
  },
  ["Potion"] = {
    {3.33, 1, 1.55},
    {1.12, 1, 1.55},
    {-1.1, 1, 1.55},
  },
  ["Discard"] = {
    {-3.32, 1, -1.55},
    {-3.32, 1, 1.55},
  }
}

function startMerchantMode()
  local board_pos = MERCHANT_MODE_POS
  self.setPositionSmooth(board_pos)
  self.setRotationSmooth({0, 180, 0})

  Wait.time(function()
    -- Deploy cards from the relic and potion decks into their respective slots
    local decks = {
      ["Relic"] = Global.getVar("RELIC_DECK"),
      ["Potion"] = Global.getVar("POTIONS_DECK"),
    }

    for type, pos_list in pairs(decks) do
      local deck = getObjectFromGUID(decks[type])
      if deck then
        for slot_idx = 1, 3 do
          local card_pos = getSlotPosition(type, slot_idx, 1, board_pos)

          -- Have to always check if it still exists
          if deck then
            if deck.name == "Deck" or deck.name == "DeckCustom" then
              deck.takeObject({position=card_pos, rotation={0, 180, 0}})

              -- Check if we're on the last card
              if deck.remainder ~= nil then
                deck = deck.remainder
                if type == "Relic" then
                  Global.setVar("RELIC_DECK", deck.guid)
                else
                  Global.setVar("POTIONS_DECK", deck.guid)
                end
              end
            elseif deck.name == "Card" or deck.name == "CardCustom" then
              deck.setPositionSmooth(card_pos)
              deck.setRotationSmooth({0, 180, 0})

              deck = nil
            end
          else
            broadcastToAll("WARNING: " .. tostring(type) .. " deck has run out of cards. Cannot fill merchant board.")
          end
        end
      else
        broadcastToAll("WARNING: Unable to find " .. tostring(type) .. " deck. Merchant board will not be populated properly.")
      end
    end
  end, 1)
end

function endMerchantMode()
  returnItemsAsync()

  -- Give time for the system to detect and return items
  Wait.frames(function()
    self.setPositionSmooth(RESTING_POS)
    self.setRotationSmooth({0, 180, 180})
  end, 30)
end

-- Retrieves relics and items on the tool and returns them to their associated deck. Does this by spawning a temporary scripting zone on each area and getting objects
function returnItemsAsync(callback_function, callback_func_args)
  -- Internal coroutine
  function returnItemsAsyncInternal()
    local target_scale = {2.0, 3, 3.0}

    local decks = {
      ["Relic"] = Global.getVar("RELIC_DECK"),
      ["Potion"] = Global.getVar("POTIONS_DECK"),
    }

    for type, pos_list in pairs(decks) do
      local warning_sent = false  -- Prevent multiple repeated warnings
      for slot_idx = 1, 3 do
        local zone = createScriptingZone(getSlotPosition(type, slot_idx), self.getRotation(), target_scale)
        local zoneObjects = {}
        for _, obj in ipairs(zone.getObjects()) do
          if obj.name == "Card" or obj.name == "CardCustom" or obj.name == "Deck" or obj.name == "DeckCustom" then
            table.insert(zoneObjects, obj)
          end
        end

        -- We have a zone now, get the cards/decks in that zone and send them to the correct deck
        local deck = getObjectFromGUID(decks[type])
        if deck then
          -- Put the object onto the bottom of the deck
          for idx, card in ipairs(zoneObjects) do
            -- Hacky way to get this put onto the bottom of the deck. Move it under the table, then put it in the deck
            local underPos = card.getPosition()
            underPos[2] = 0
            card.setPosition(underPos)
            deck.putObject(card)
          end
        else
          -- Couldn't find the deck, so use a fallback position that is relatively where the deck would have been
          local fallback_pos = {
            ["Relic"] = {-6.32, 0.97, 8.84},
            ["Potion"] = {-8.49, 0.97, 8.76},
          }

          for _, card in ipairs(zoneObjects) do
            card.setPositionSmooth(fallback_pos[type])
          end

          if not warning_sent then
            broadcastToAll("WARNING: " .. tostring(type) .. " deck could not be found. Using fallback position")
            warning_sent = true
          end
        end

        zone.destruct()
      end

      for slot_idx, _ in ipairs(CARD_OFFSETS["Discard"]) do
        local zone = createScriptingZone(getSlotPosition("Discard", slot_idx), self.getRotation(), target_scale)
        local zoneObjects = {}
        for _, obj in ipairs(zone.getObjects()) do
          if obj.name == "Card" or obj.name == "CardCustom" or obj.name == "Deck" or obj.name == "DeckCustom" then
            table.insert(zoneObjects, obj)
          end
        end

        -- Put the object into its proper discard pile
        for idx, card in ipairs(zoneObjects) do
          local targetPos = Global.call("getPlayerDiscardLocation", card.getPosition())
          card.setPositionSmooth(targetPos)
          card.setRotationSmooth({0, 180, 0})
        end

        zone.destruct()
      end
    end
    return 1
  end

  startLuaCoroutine(self, "returnItemsAsyncInternal")
end

function createScriptingZone(position, rot, scale)
    local zone = spawnObject({type='ScriptingTrigger', position=position, rotation=rot, scale=scale})
    repeat
        coroutine.yield(0)
    until zone.getGUID() ~= nil
    coroutine.yield(0)
    return zone
end

function getSlotPosition(type, slotIdx, yOffset, posOverride)
  local X_OFFSET = CARD_OFFSETS[type][slotIdx][1]
  local Z_OFFSET = CARD_OFFSETS[type][slotIdx][3]

  if yOffset == nil then
    yOffset = 0
  end

  local base_pos = self.getPosition()
  if posOverride ~= nil then
    base_pos = posOverride
  end

  local local_x_offset = (X_OFFSET) * math.cos(math.rad(self.getRotation()[2])) + (Z_OFFSET) * math.sin(math.rad(self.getRotation()[2]))
  local local_z_offset = (Z_OFFSET) * math.cos(math.rad(self.getRotation()[2])) - (X_OFFSET) * math.sin(math.rad(self.getRotation()[2]))
  local pos = {base_pos[1] + local_x_offset, base_pos[2] + yOffset, base_pos[3] + local_z_offset}

  return pos
end